// ta_Dump File v3.0 -- code v8.2.0.0 rev11077
BpProject .projects[0] { 
 Doc_Group @.docs = [1] {
  taDoc @[0] { };
 };

 Wizard_Group @.wizards = [0] {
 };

 ControlPanel_Group @.ctrl_panels = [1] {
  ClusterRun @[0] { 
   UserDataItem_List @*(.user_data_) {
    UserDataItem @[0] { };
   };

   ControlPanelMember_Group @.mbrs = [0] {
   };

   ControlPanelMethod_Group @.mths = [0] {
   };

   ParamSearchAlgo_List @.search_algos = [0] {
   };
  };
 };

 ParamSet_Group @.active_params = [0] {
 };

 ArchivedParams_Group @.archived_params = [0] {
 };

 DataTable_Group @.data = [0] {
  DataTable_Group @.gp[0] = [2] { 
   DataTable @[0] { 
    DataTableCols @.data = [3] {
     String_Data @[0] { };
     float_Data @[1] { };
     float_Data @[2] { };
    };

    DataOpList @.last_sort_spec.ops = [0] {
    };
   };
   DataTable @[1] { 
    DataTableCols @.data = [3] {
     String_Data @[0] { };
     float_Data @[1] { };
     float_Data @[2] { };
    };

    DataOpList @.last_sort_spec.ops = [0] {
    };
   };
  };
  DataTable_Group @.gp[1] = [4] { 
   DataTable @[0] { 
    DataTableCols @.data = [6] {
     int_Data @[0] { 
      UserDataItem_List @*(.user_data_) {
       UserDataItem @[0] { };
      };
     };
     int_Data @[1] { 
      UserDataItem_List @*(.user_data_) {
       UserDataItem @[0] { };
      };
     };
     int_Data @[2] { 
      UserDataItem_List @*(.user_data_) {
       UserDataItem @[0] { };
      };
     };
     String_Data @[3] { };
     String_Data @[4] { };
     float_Data @[5] { };
    };

    DataOpList @.last_sort_spec.ops = [0] {
    };
   };
   DataTable @[1] { 
    DataTableCols @.data = [6] {
     int_Data @[0] { 
      UserDataItem_List @*(.user_data_) {
       UserDataItem @[0] { };
      };
     };
     int_Data @[1] { 
      UserDataItem_List @*(.user_data_) {
       UserDataItem @[0] { };
      };
     };
     float_Data @[2] { };
     float_Data @[3] { };
     float_Data @[4] { };
     float_Data @[5] { };
    };

    DataOpList @.last_sort_spec.ops = [0] {
    };
   };
   DataTable @[2] { 
    DataTableCols @.data = [9] {
     int_Data @[0] { 
      UserDataItem_List @*(.user_data_) {
       UserDataItem @[0] { };
      };
     };
     int_Data @[1] { 
      UserDataItem_List @*(.user_data_) {
       UserDataItem @[0] { };
      };
     };
     int_Data @[2] { 
      UserDataItem_List @*(.user_data_) {
       UserDataItem @[0] { };
      };
     };
     String_Data @[3] { };
     String_Data @[4] { };
     float_Data @[5] { };
     float_Data @[6] { };
     float_Data @[7] { };
     float_Data @[8] { };
    };

    DataOpList @.last_sort_spec.ops = [0] {
    };
   };
   DataTable @[3] { 
    DataTableCols @.data = [6] {
     int_Data @[0] { 
      UserDataItem_List @*(.user_data_) {
       UserDataItem @[0] { };
      };
     };
     int_Data @[1] { 
      UserDataItem_List @*(.user_data_) {
       UserDataItem @[0] { };
      };
     };
     float_Data @[2] { };
     float_Data @[3] { };
     float_Data @[4] { };
     float_Data @[5] { };
    };

    DataOpList @.last_sort_spec.ops = [0] {
    };
   };
  };
  DataTable_Group @.gp[2] { 
  };
 };

 Program_TopGroup @.programs = [1] {
  Program @[0] { 
   UserDataItem_List @*(.user_data_) {
    UserData_DocLink @[0] { };
   };

   ProgObjList @.objs = [0] {
   };

   ProgVar_List @.objs_vars = [0] {
   };

   ProgType_List @.types = [0] {
   };

   ProgVar_List @.args = [2] {
    ProgVar @[0] { };
    ProgVar @[1] { };
   };

   ProgVar_List @.vars = [14] {
    ProgVar @[0] { };
    ProgVar @[1] { };
    ProgVar @[2] { };
    ProgVar @[3] { };
    ProgVar @[4] { };
    ProgVar @[5] { };
    ProgVar @[6] { };
    ProgVar @[7] { };
    ProgVar @[8] { };
    ProgVar @[9] { };
    ProgVar @[10] { };
    ProgVar @[11] { };
    ProgVar @[12] { };
    ProgVar @[13] { };
   };

   Function_List @.functions = [0] {
   };

   ProgEl_List @.init_code = [0] {
   };

   ProgEl_List @.prog_code = [46] {
    LocalVars @[0] { 
     ProgVar_List @.local_vars = [0] {
     };
    };
    ReturnExpr @[1] { };
    RegisterArgs @[2] { };
    PrintExpr @[3] { };
    PrintExpr @[4] { };
    PrintExpr @[5] { };
    PrintExpr @[6] { };
    PrintExpr @[7] { };
    PrintExpr @[8] { };
    PrintExpr @[9] { };
    Comment @[10] { };
    ProgVarFmArg @[11] { };
    ProgVarFmArg @[12] { };
    ProgVarFmArg @[13] { };
    ProgVarFmArg @[14] { };
    ProgVarFmArg @[15] { };
    ProgVarFmArg @[16] { };
    ProgVarFmArg @[17] { };
    ProgVarFmArg @[18] { };
    ProgVarFmArg @[19] { };
    ProgVarFmArg @[20] { };
    ProgVarFmArg @[21] { };
    ProgVarFmArg @[22] { };
    ProgVarFmArg @[23] { };
    PrintExpr @[24] { };
    PrintExpr @[25] { };
    AssignExpr @[26] { };
    PrintExpr @[27] { };
    If @[28] { 
     ProgEl_List @.true_code = [7] {
      PrintExpr @[0] { };
      PrintExpr @[1] { };
      MethodCall @[2] { 
       ProgArg_List @.meth_args = [2] {
	ProgArg @[0] { };
	ProgArg @[1] { };
       };
      };
      PrintExpr @[3] { };
      ProgramCall @[4] { 
       ProgArg_List @.prog_args = [2] {
	ProgArg @[0] { };
	ProgArg @[1] { };
       };
      };
      ProgramCall @[5] { 
       ProgArg_List @.prog_args = [1] {
	ProgArg @[0] { };
       };
      };
      ProgramCall @[6] { 
       ProgArg_List @.prog_args = [2] {
	ProgArg @[0] { };
	ProgArg @[1] { };
       };
      };
     };
    };
    Else @[29] { 
     ProgEl_List @.true_code = [6] {
      PrintExpr @[0] { };
      PrintExpr @[1] { };
      PrintExpr @[2] { };
      PrintExpr @[3] { };
      ProgramCall @[4] { 
       ProgArg_List @.prog_args = [2] {
	ProgArg @[0] { };
	ProgArg @[1] { };
       };
      };
      MiscCall @[5] { 
       ProgArg_List @.meth_args = [1] {
	ProgArg @[0] { };
       };
      };
     };
    };
    Comment @[30] { };
    Comment @[31] { };
    MethodCall @[32] { 
     ProgArg_List @.meth_args = [3] {
      ProgArg @[0] { };
      ProgArg @[1] { };
      ProgArg @[2] { };
     };
    };
    PrintVar @[33] { };
    Comment @[34] { };
    MethodCall @[35] { 
     ProgArg_List @.meth_args = [3] {
      ProgArg @[0] { };
      ProgArg @[1] { };
      ProgArg @[2] { };
     };
    };
    PrintVar @[36] { };
    OtherProgramVar @[37] { };
    PrintExpr @[38] { };
    ProgramCall @[39] { 
     ProgArg_List @.prog_args = [3] {
      ProgArg @[0] { };
      ProgArg @[1] { };
      ProgArg @[2] { };
     };
    };
    PrintVar @[40] { };
    PrintExpr @[41] { };
    ProgramCall @[42] { 
     ProgArg_List @.prog_args = [1] {
      ProgArg @[0] { };
     };
    };
    PrintExpr @[43] { };
    PrintExpr @[44] { };
    ProgramCall @[45] { 
     ProgArg_List @.prog_args = [2] {
      ProgArg @[0] { };
      ProgArg @[1] { };
     };
    };
   };
  };
  Program_Group @.gp[0] = [11] { 
   Program @[0] { 
    UserDataItem_List @*(.user_data_) {
     UserData_DocLink @[0] { };
    };

    ProgObjList @.objs = [0] {
    };

    ProgVar_List @.objs_vars = [0] {
    };

    ProgType_List @.types = [0] {
    };

    ProgVar_List @.args = [3] {
     ProgVar @[0] { };
     ProgVar @[1] { };
     ProgVar @[2] { };
    };

    ProgVar_List @.vars = [1] {
     ProgVar @[0] { };
    };

    Function_List @.functions = [0] {
    };

    ProgEl_List @.init_code = [1] {
     NetCounterInit @[0] { };
    };

    ProgEl_List @.prog_code = [2] {
     NetCounterInit @[0] { };
     WhileLoop @[1] { 
      ProgEl_List @.loop_code = [2] {
       ProgramCall @[0] { 
	ProgArg_List @.prog_args = [3] {
	 ProgArg @[0] { };
	 ProgArg @[1] { };
	 ProgArg @[2] { };
	};
       };
       NetCounterIncr @[1] { };
      };
     };
    };
   };
   Program @[1] { 
    UserDataItem_List @*(.user_data_) {
     UserData_DocLink @[0] { };
    };

    ProgObjList @.objs = [2] {
     RndSeed_List @[0] { 
      taList @.seeds = [25] {
       RndSeed @[0] { };
       RndSeed @[1] { };
       RndSeed @[2] { };
       RndSeed @[3] { };
       RndSeed @[4] { };
       RndSeed @[5] { };
       RndSeed @[6] { };
       RndSeed @[7] { };
       RndSeed @[8] { };
       RndSeed @[9] { };
       RndSeed @[10] { };
       RndSeed @[11] { };
       RndSeed @[12] { };
       RndSeed @[13] { };
       RndSeed @[14] { };
       RndSeed @[15] { };
       RndSeed @[16] { };
       RndSeed @[17] { };
       RndSeed @[18] { };
       RndSeed @[19] { };
       RndSeed @[20] { };
       RndSeed @[21] { };
       RndSeed @[22] { };
       RndSeed @[23] { };
       RndSeed @[24] { };
      };
     };
     RndSeed @[1] { };
    };

    ProgVar_List @.objs_vars = [2] {
     ProgVar @[0] { };
     ProgVar @[1] { };
    };

    ProgType_List @.types = [1] {
     DynEnumType @[0] { 
      DynEnumItem_List @.enums = [3] {
       DynEnumItem @[0] { };
       DynEnumItem @[1] { };
       DynEnumItem @[2] { };
      };
     };
    };

    ProgVar_List @.args = [3] {
     ProgVar @[0] { };
     ProgVar @[1] { };
     ProgVar @[2] { };
    };

    ProgVar_List @.vars = [10] {
     ProgVar @[0] { };
     ProgVar @[1] { };
     ProgVar @[2] { };
     ProgVar @[3] { };
     ProgVar @[4] { };
     ProgVar @[5] { };
     ProgVar @[6] { };
     ProgVar @[7] { };
     ProgVar @[8] { };
     ProgVar @[9] { };
    };

    Function_List @.functions = [1] {
     Function @[0] { 
      ProgVar_List @.args = [0] {
      };

      ProgEl_List @.fun_code = [2] {
       LocalVars @[0] { 
	ProgVar_List @.local_vars = [0] {
	};
       };
       Switch @[1] { 
	ProgEl_List @.cases = [3] {
	 CaseBlock @[0] { 
	  ProgEl_List @.prog_code = [1] {
	   MethodCall @[0] { 
	    ProgArg_List @.meth_args = [0] {
	    };
	   };
	  };
	 };
	 CaseBlock @[1] { 
	  ProgEl_List @.prog_code = [1] {
	   MethodCall @[0] { 
	    ProgArg_List @.meth_args = [0] {
	    };
	   };
	  };
	 };
	 CaseBlock @[2] { 
	  ProgEl_List @.prog_code = [1] {
	   MethodCall @[0] { 
	    ProgArg_List @.meth_args = [1] {
	     ProgArg @[0] { };
	    };
	   };
	  };
	 };
	};
       };
      };
     };
    };

    ProgEl_List @.init_code = [7] {
     AssignExpr @[0] { };
     MethodCall @[1] { 
      ProgArg_List @.meth_args = [1] {
       ProgArg @[0] { };
      };
     };
     AssignExpr @[2] { };
     AssignExpr @[3] { };
     FunctionCall @[4] { 
      ProgArg_List @.fun_args = [0] {
      };
     };
     WtInitPrompt @[5] { 
      ProgEl_List @.yes_code = [2] {
       MethodCall @[0] { 
	ProgArg_List @.meth_args = [0] {
	};
       };
       PrintExpr @[1] { };
      };
     };
     AssignExpr @[6] { };
    };

    ProgEl_List @.prog_code = [10] {
     AssignExpr @[0] { };
     MethodCall @[1] { 
      ProgArg_List @.meth_args = [1] {
       ProgArg @[0] { };
      };
     };
     AssignExpr @[2] { };
     MemberAssign @[3] { };
     FunctionCall @[4] { 
      ProgArg_List @.fun_args = [0] {
      };
     };
     If @[5] { 
      ProgEl_List @.true_code = [2] {
       MethodCall @[0] { 
	ProgArg_List @.meth_args = [0] {
	};
       };
       PrintExpr @[1] { };
      };
     };
     AssignExpr @[6] { };
     WhileLoop @[7] { 
      ProgEl_List @.loop_code = [5] {
       ProgramCall @[0] { 
	ProgArg_List @.prog_args = [2] {
	 ProgArg @[0] { };
	 ProgArg @[1] { };
	};
       };
       NetCounterIncr @[1] { };
       If @[2] { 
	ProgEl_List @.true_code = [2] {
	 VarIncr @[0] { };
	 IfBreak @[1] { };
	};
       };
       Else @[3] { 
	ProgEl_List @.true_code = [1] {
	 AssignExpr @[0] { };
	};
       };
       If @[4] { 
	ProgEl_List @.true_code = [1] {
	 If @[0] { 
	  ProgEl_List @.true_code = [1] {
	   ProgramCall @[0] { 
	    ProgArg_List @.prog_args = [1] {
	     ProgArg @[0] { };
	    };
	   };
	  };
	 };
	};
       };
      };
     };
     If @[8] { 
      ProgEl_List @.true_code = [1] {
       ProgramCall @[0] { 
	ProgArg_List @.prog_args = [1] {
	 ProgArg @[0] { };
	};
       };
      };
     };
     MethodCall @[9] { 
      ProgArg_List @.meth_args = [0] {
      };
     };
    };
   };
   Program @[2] { 
    UserDataItem_List @*(.user_data_) {
     UserData_DocLink @[0] { };
    };

    ProgObjList @.objs = [0] {
    };

    ProgVar_List @.objs_vars = [0] {
    };

    ProgType_List @.types = [0] {
    };

    ProgVar_List @.args = [2] {
     ProgVar @[0] { };
     ProgVar @[1] { };
    };

    ProgVar_List @.vars = [5] {
     ProgVar @[0] { };
     ProgVar @[1] { };
     ProgVar @[2] { };
     ProgVar @[3] { };
     ProgVar @[4] { };
    };

    Function_List @.functions = [0] {
    };

    ProgEl_List @.init_code = [2] {
     NetCounterInit @[0] { };
     AssignExpr @[1] { };
    };

    ProgEl_List @.prog_code = [9] {
     NetCounterInit @[0] { };
     AssignExpr @[1] { };
     MethodCall @[2] { 
      ProgArg_List @.meth_args = [1] {
       ProgArg @[0] { };
      };
     };
     MethodCall @[3] { 
      ProgArg_List @.meth_args = [0] {
      };
     };
     NetDataLoop @[4] { 
      ProgEl_List @.loop_code = [2] {
       ProgramCall @[0] { 
	ProgArg_List @.prog_args = [2] {
	 ProgArg @[0] { };
	 ProgArg @[1] { };
	};
       };
       If @[1] { 
	ProgEl_List @.true_code = [1] {
	 MethodCall @[0] { 
	  ProgArg_List @.meth_args = [0] {
	  };
	 };
	};
       };
      };
     };
     If @[5] { 
      ProgEl_List @.true_code = [1] {
       MethodCall @[0] { 
	ProgArg_List @.meth_args = [0] {
	};
       };
      };
     };
     MethodCall @[6] { 
      ProgArg_List @.meth_args = [0] {
      };
     };
     MethodCall @[7] { 
      ProgArg_List @.meth_args = [0] {
      };
     };
     ProgramCall @[8] { 
      ProgArg_List @.prog_args = [1] {
       ProgArg @[0] { };
      };
     };
    };
   };
   Program @[3] { 
    UserDataItem_List @*(.user_data_) {
     UserData_DocLink @[0] { };
    };

    ProgObjList @.objs = [0] {
    };

    ProgVar_List @.objs_vars = [0] {
    };

    ProgType_List @.types = [0] {
    };

    ProgVar_List @.args = [2] {
     ProgVar @[0] { };
     ProgVar @[1] { };
    };

    ProgVar_List @.vars = [1] {
     ProgVar @[0] { };
    };

    Function_List @.functions = [0] {
    };

    ProgEl_List @.init_code = [0] {
    };

    ProgEl_List @.prog_code = [6] {
     MethodCall @[0] { 
      ProgArg_List @.meth_args = [0] {
      };
     };
     ProgramCall @[1] { 
      ProgArg_List @.prog_args = [2] {
       ProgArg @[0] { };
       ProgArg @[1] { };
      };
     };
     MethodCall @[2] { 
      ProgArg_List @.meth_args = [0] {
      };
     };
     MethodCall @[3] { 
      ProgArg_List @.meth_args = [0] {
      };
     };
     ProgramCall @[4] { 
      ProgArg_List @.prog_args = [1] {
       ProgArg @[0] { };
      };
     };
     NetUpdateView @[5] { };
    };
   };
   Program @[4] { 
    UserDataItem_List @*(.user_data_) {
     UserData_DocLink @[0] { };
    };

    ProgObjList @.objs = [1] {
     LayerWriter @[0] { 
      LayerDataEl_List @.layer_data = [3] {
       LayerWriterEl @[0] { };
       LayerWriterEl @[1] { };
       LayerWriterEl @[2] { };
      };
     };
    };

    ProgVar_List @.objs_vars = [1] {
     ProgVar @[0] { };
    };

    ProgType_List @.types = [0] {
    };

    ProgVar_List @.args = [2] {
     ProgVar @[0] { };
     ProgVar @[1] { };
    };

    ProgVar_List @.vars = [0] {
    };

    Function_List @.functions = [0] {
    };

    ProgEl_List @.init_code = [2] {
     MethodCall @[0] { 
      ProgArg_List @.meth_args = [2] {
       ProgArg @[0] { };
       ProgArg @[1] { };
      };
     };
     MethodCall @[1] { 
      ProgArg_List @.meth_args = [1] {
       ProgArg @[0] { };
      };
     };
    };

    ProgEl_List @.prog_code = [1] {
     MethodCall @[0] { 
      ProgArg_List @.meth_args = [0] {
      };
     };
    };
   };
   Program @[5] { 
    UserDataItem_List @*(.user_data_) {
     UserData_DocLink @[0] { };
    };

    ProgObjList @.objs = [1] {
     NetMonitor @[0] { 
      NetMonItem_List @.items = [6] {
       NetMonItem @[0] { };
       NetMonItem @[1] { };
       NetMonItem @[2] { };
       NetMonItem @[3] { };
       NetMonItem @[4] { };
       NetMonItem @[5] { };
      };
     };
    };

    ProgVar_List @.objs_vars = [1] {
     ProgVar @[0] { };
    };

    ProgType_List @.types = [0] {
    };

    ProgVar_List @.args = [1] {
     ProgVar @[0] { };
    };

    ProgVar_List @.vars = [1] {
     ProgVar @[0] { };
    };

    Function_List @.functions = [0] {
    };

    ProgEl_List @.init_code = [3] {
     MethodCall @[0] { 
      ProgArg_List @.meth_args = [2] {
       ProgArg @[0] { };
       ProgArg @[1] { };
      };
     };
     MethodCall @[1] { 
      ProgArg_List @.meth_args = [1] {
       ProgArg @[0] { };
      };
     };
     MethodCall @[2] { 
      ProgArg_List @.meth_args = [1] {
       ProgArg @[0] { };
      };
     };
    };

    ProgEl_List @.prog_code = [4] {
     MethodCall @[0] { 
      ProgArg_List @.meth_args = [0] {
      };
     };
     MethodCall @[1] { 
      ProgArg_List @.meth_args = [0] {
      };
     };
     MethodCall @[2] { 
      ProgArg_List @.meth_args = [0] {
      };
     };
     MethodCall @[3] { 
      ProgArg_List @.meth_args = [2] {
       ProgArg @[0] { };
       ProgArg @[1] { };
      };
     };
    };
   };
   Program @[6] { 
    UserDataItem_List @*(.user_data_) {
     UserData_DocLink @[0] { };
    };

    ProgObjList @.objs = [1] {
     NetMonitor @[0] { 
      NetMonItem_List @.items = [6] {
       NetMonItem @[0] { };
       NetMonItem @[1] { };
       NetMonItem @[2] { };
       NetMonItem @[3] { };
       NetMonItem @[4] { };
       NetMonItem @[5] { };
      };
     };
    };

    ProgVar_List @.objs_vars = [1] {
     ProgVar @[0] { };
    };

    ProgType_List @.types = [0] {
    };

    ProgVar_List @.args = [1] {
     ProgVar @[0] { };
    };

    ProgVar_List @.vars = [2] {
     ProgVar @[0] { };
     ProgVar @[1] { };
    };

    Function_List @.functions = [0] {
    };

    ProgEl_List @.init_code = [4] {
     AssignExpr @[0] { };
     MethodCall @[1] { 
      ProgArg_List @.meth_args = [2] {
       ProgArg @[0] { };
       ProgArg @[1] { };
      };
     };
     MethodCall @[2] { 
      ProgArg_List @.meth_args = [1] {
       ProgArg @[0] { };
      };
     };
     MethodCall @[3] { 
      ProgArg_List @.meth_args = [1] {
       ProgArg @[0] { };
      };
     };
    };

    ProgEl_List @.prog_code = [6] {
     MethodCall @[0] { 
      ProgArg_List @.meth_args = [0] {
      };
     };
     MethodCall @[1] { 
      ProgArg_List @.meth_args = [0] {
      };
     };
     AssignExpr @[2] { };
     MethodCall @[3] { 
      ProgArg_List @.meth_args = [4] {
       ProgArg @[0] { };
       ProgArg @[1] { };
       ProgArg @[2] { };
       ProgArg @[3] { };
      };
     };
     MethodCall @[4] { 
      ProgArg_List @.meth_args = [4] {
       ProgArg @[0] { };
       ProgArg @[1] { };
       ProgArg @[2] { };
       ProgArg @[3] { };
      };
     };
     MethodCall @[5] { 
      ProgArg_List @.meth_args = [0] {
      };
     };
    };
   };
   Program @[7] { 
    UserDataItem_List @*(.user_data_) {
     UserData_DocLink @[0] { };
    };

    ProgObjList @.objs = [0] {
    };

    ProgVar_List @.objs_vars = [0] {
    };

    ProgType_List @.types = [0] {
    };

    ProgVar_List @.args = [1] {
     ProgVar @[0] { };
    };

    ProgVar_List @.vars = [7] {
     ProgVar @[0] { };
     ProgVar @[1] { };
     ProgVar @[2] { };
     ProgVar @[3] { };
     ProgVar @[4] { };
     ProgVar @[5] { };
     ProgVar @[6] { };
    };

    Function_List @.functions = [0] {
    };

    ProgEl_List @.init_code = [0] {
    };

    ProgEl_List @.prog_code = [6] {
     If @[0] { 
      ProgEl_List @.true_code = [1] {
       ReturnExpr @[0] { };
      };
     };
     MiscCall @[1] { 
      ProgArg_List @.meth_args = [2] {
       ProgArg @[0] { };
       ProgArg @[1] { };
      };
     };
     MiscCall @[2] { 
      ProgArg_List @.meth_args = [2] {
       ProgArg @[0] { };
       ProgArg @[1] { };
      };
     };
     AssignExpr @[3] { };
     AssignExpr @[4] { };
     MethodCall @[5] { 
      ProgArg_List @.meth_args = [2] {
       ProgArg @[0] { };
       ProgArg @[1] { };
      };
     };
    };
   };
   Program @[8] { 
    UserDataItem_List @*(.user_data_) {
     UserData_DocLink @[0] { };
    };

    ProgObjList @.objs = [0] {
    };

    ProgVar_List @.objs_vars = [0] {
    };

    ProgType_List @.types = [0] {
    };

    ProgVar_List @.args = [2] {
     ProgVar @[0] { };
     ProgVar @[1] { };
    };

    ProgVar_List @.vars = [1] {
     ProgVar @[0] { };
    };

    Function_List @.functions = [0] {
    };

    ProgEl_List @.init_code = [0] {
    };

    ProgEl_List @.prog_code = [4] {
     RegisterArgs @[0] { };
     ProgVarFmArg @[1] { };
     PrintExpr @[2] { };
     MethodCall @[3] { 
      ProgArg_List @.meth_args = [4] {
       ProgArg @[0] { };
       ProgArg @[1] { };
       ProgArg @[2] { };
       ProgArg @[3] { };
      };
     };
    };
   };
   Program @[9] { 
    UserDataItem_List @*(.user_data_) {
     UserData_DocLink @[0] { };
    };

    ProgObjList @.objs = [0] {
    };

    ProgVar_List @.objs_vars = [0] {
    };

    ProgType_List @.types = [0] {
    };

    ProgVar_List @.args = [2] {
     ProgVar @[0] { };
     ProgVar @[1] { };
    };

    ProgVar_List @.vars = [0] {
    };

    Function_List @.functions = [0] {
    };

    ProgEl_List @.init_code = [0] {
    };

    ProgEl_List @.prog_code = [1] {
     MethodCall @[0] { 
      ProgArg_List @.meth_args = [4] {
       ProgArg @[0] { };
       ProgArg @[1] { };
       ProgArg @[2] { };
       ProgArg @[3] { };
      };
     };
    };
   };
   Program @[10] { 
    UserDataItem_List @*(.user_data_) {
     UserData_DocLink @[0] { };
    };

    ProgObjList @.objs = [0] {
    };

    ProgVar_List @.objs_vars = [0] {
    };

    ProgType_List @.types = [0] {
    };

    ProgVar_List @.args = [2] {
     ProgVar @[0] { };
     ProgVar @[1] { };
    };

    ProgVar_List @.vars = [1] {
     ProgVar @[0] { };
    };

    Function_List @.functions = [0] {
    };

    ProgEl_List @.init_code = [0] {
    };

    ProgEl_List @.prog_code = [1] {
     MethodCall @[0] { 
      ProgArg_List @.meth_args = [2] {
       ProgArg @[0] { };
       ProgArg @[1] { };
      };
     };
    };
   };
  };
  Program_Group @.gp[1] = [5] { 
   Program @[0] { 
    UserDataItem_List @*(.user_data_) {
     UserData_DocLink @[0] { };
    };

    ProgObjList @.objs = [0] {
    };

    ProgVar_List @.objs_vars = [0] {
    };

    ProgType_List @.types = [0] {
    };

    ProgVar_List @.args = [1] {
     ProgVar @[0] { };
    };

    ProgVar_List @.vars = [7] {
     ProgVar @[0] { };
     ProgVar @[1] { };
     ProgVar @[2] { };
     ProgVar @[3] { };
     ProgVar @[4] { };
     ProgVar @[5] { };
     ProgVar @[6] { };
    };

    Function_List @.functions = [0] {
    };

    ProgEl_List @.init_code = [2] {
     NetCounterInit @[0] { };
     AssignExpr @[1] { };
    };

    ProgEl_List @.prog_code = [12] {
     NetCounterInit @[0] { };
     MemberAssign @[1] { };
     AssignExpr @[2] { };
     MethodCall @[3] { 
      ProgArg_List @.meth_args = [1] {
       ProgArg @[0] { };
      };
     };
     MethodCall @[4] { 
      ProgArg_List @.meth_args = [0] {
      };
     };
     NetDataLoop @[5] { 
      ProgEl_List @.loop_code = [2] {
       ProgramCall @[0] { 
	ProgArg_List @.prog_args = [2] {
	 ProgArg @[0] { };
	 ProgArg @[1] { };
	};
       };
       If @[1] { 
	ProgEl_List @.true_code = [1] {
	 MethodCall @[0] { 
	  ProgArg_List @.meth_args = [0] {
	  };
	 };
	};
       };
      };
     };
     If @[6] { 
      ProgEl_List @.true_code = [1] {
       MethodCall @[0] { 
	ProgArg_List @.meth_args = [0] {
	};
       };
      };
     };
     MethodCall @[7] { 
      ProgArg_List @.meth_args = [0] {
      };
     };
     MethodCall @[8] { 
      ProgArg_List @.meth_args = [0] {
      };
     };
     ProgramCall @[9] { 
      ProgArg_List @.prog_args = [1] {
       ProgArg @[0] { };
      };
     };
     ProgramCall @[10] { 
      ProgArg_List @.prog_args = [2] {
       ProgArg @[0] { };
       ProgArg @[1] { };
      };
     };
     MemberAssign @[11] { };
    };
   };
   Program @[1] { 
    UserDataItem_List @*(.user_data_) {
     UserData_DocLink @[0] { };
    };

    ProgObjList @.objs = [0] {
    };

    ProgVar_List @.objs_vars = [0] {
    };

    ProgType_List @.types = [0] {
    };

    ProgVar_List @.args = [2] {
     ProgVar @[0] { };
     ProgVar @[1] { };
    };

    ProgVar_List @.vars = [1] {
     ProgVar @[0] { };
    };

    Function_List @.functions = [0] {
    };

    ProgEl_List @.init_code = [0] {
    };

    ProgEl_List @.prog_code = [6] {
     MethodCall @[0] { 
      ProgArg_List @.meth_args = [0] {
      };
     };
     ProgramCall @[1] { 
      ProgArg_List @.prog_args = [2] {
       ProgArg @[0] { };
       ProgArg @[1] { };
      };
     };
     MethodCall @[2] { 
      ProgArg_List @.meth_args = [0] {
      };
     };
     MethodCall @[3] { 
      ProgArg_List @.meth_args = [0] {
      };
     };
     ProgramCall @[4] { 
      ProgArg_List @.prog_args = [1] {
       ProgArg @[0] { };
      };
     };
     NetUpdateView @[5] { };
    };
   };
   Program @[2] { 
    UserDataItem_List @*(.user_data_) {
     UserData_DocLink @[0] { };
    };

    ProgObjList @.objs = [1] {
     LayerWriter @[0] { 
      LayerDataEl_List @.layer_data = [3] {
       LayerWriterEl @[0] { };
       LayerWriterEl @[1] { };
       LayerWriterEl @[2] { };
      };
     };
    };

    ProgVar_List @.objs_vars = [1] {
     ProgVar @[0] { };
    };

    ProgType_List @.types = [0] {
    };

    ProgVar_List @.args = [2] {
     ProgVar @[0] { };
     ProgVar @[1] { };
    };

    ProgVar_List @.vars = [0] {
    };

    Function_List @.functions = [0] {
    };

    ProgEl_List @.init_code = [2] {
     MethodCall @[0] { 
      ProgArg_List @.meth_args = [2] {
       ProgArg @[0] { };
       ProgArg @[1] { };
      };
     };
     MethodCall @[1] { 
      ProgArg_List @.meth_args = [1] {
       ProgArg @[0] { };
      };
     };
    };

    ProgEl_List @.prog_code = [1] {
     MethodCall @[0] { 
      ProgArg_List @.meth_args = [0] {
      };
     };
    };
   };
   Program @[3] { 
    UserDataItem_List @*(.user_data_) {
     UserData_DocLink @[0] { };
    };

    ProgObjList @.objs = [1] {
     NetMonitor @[0] { 
      NetMonItem_List @.items = [9] {
       NetMonItem @[0] { };
       NetMonItem @[1] { };
       NetMonItem @[2] { };
       NetMonItem @[3] { };
       NetMonItem @[4] { };
       NetMonItem @[5] { };
       NetMonItem @[6] { };
       NetMonItem @[7] { };
       NetMonItem @[8] { };
      };
     };
    };

    ProgVar_List @.objs_vars = [1] {
     ProgVar @[0] { };
    };

    ProgType_List @.types = [0] {
    };

    ProgVar_List @.args = [1] {
     ProgVar @[0] { };
    };

    ProgVar_List @.vars = [1] {
     ProgVar @[0] { };
    };

    Function_List @.functions = [0] {
    };

    ProgEl_List @.init_code = [3] {
     MethodCall @[0] { 
      ProgArg_List @.meth_args = [2] {
       ProgArg @[0] { };
       ProgArg @[1] { };
      };
     };
     MethodCall @[1] { 
      ProgArg_List @.meth_args = [1] {
       ProgArg @[0] { };
      };
     };
     MethodCall @[2] { 
      ProgArg_List @.meth_args = [1] {
       ProgArg @[0] { };
      };
     };
    };

    ProgEl_List @.prog_code = [4] {
     MethodCall @[0] { 
      ProgArg_List @.meth_args = [0] {
      };
     };
     MethodCall @[1] { 
      ProgArg_List @.meth_args = [0] {
      };
     };
     MethodCall @[2] { 
      ProgArg_List @.meth_args = [0] {
      };
     };
     MethodCall @[3] { 
      ProgArg_List @.meth_args = [2] {
       ProgArg @[0] { };
       ProgArg @[1] { };
      };
     };
    };
   };
   Program @[4] { 
    UserDataItem_List @*(.user_data_) {
     UserData_DocLink @[0] { };
    };

    ProgObjList @.objs = [1] {
     NetMonitor @[0] { 
      NetMonItem_List @.items = [6] {
       NetMonItem @[0] { };
       NetMonItem @[1] { };
       NetMonItem @[2] { };
       NetMonItem @[3] { };
       NetMonItem @[4] { };
       NetMonItem @[5] { };
      };
     };
    };

    ProgVar_List @.objs_vars = [1] {
     ProgVar @[0] { };
    };

    ProgType_List @.types = [0] {
    };

    ProgVar_List @.args = [1] {
     ProgVar @[0] { };
    };

    ProgVar_List @.vars = [2] {
     ProgVar @[0] { };
     ProgVar @[1] { };
    };

    Function_List @.functions = [0] {
    };

    ProgEl_List @.init_code = [4] {
     AssignExpr @[0] { };
     MethodCall @[1] { 
      ProgArg_List @.meth_args = [2] {
       ProgArg @[0] { };
       ProgArg @[1] { };
      };
     };
     MethodCall @[2] { 
      ProgArg_List @.meth_args = [1] {
       ProgArg @[0] { };
      };
     };
     MethodCall @[3] { 
      ProgArg_List @.meth_args = [1] {
       ProgArg @[0] { };
      };
     };
    };

    ProgEl_List @.prog_code = [6] {
     MethodCall @[0] { 
      ProgArg_List @.meth_args = [0] {
      };
     };
     MethodCall @[1] { 
      ProgArg_List @.meth_args = [0] {
      };
     };
     AssignExpr @[2] { };
     MethodCall @[3] { 
      ProgArg_List @.meth_args = [4] {
       ProgArg @[0] { };
       ProgArg @[1] { };
       ProgArg @[2] { };
       ProgArg @[3] { };
      };
     };
     MethodCall @[4] { 
      ProgArg_List @.meth_args = [4] {
       ProgArg @[0] { };
       ProgArg @[1] { };
       ProgArg @[2] { };
       ProgArg @[3] { };
      };
     };
     MethodCall @[5] { 
      ProgArg_List @.meth_args = [0] {
      };
     };
    };
   };
  };
 };

 taViewer_List @.viewers = [1] {
  MainWindowViewer @[0] { 
   UserDataItem_List @*(.user_data_) {
    UserDataItem @[0] { };
    UserDataItem @[1] { };
    UserDataItem @[2] { };
    UserDataItem @[3] { };
    UserDataItem @[4] { };
    UserDataItem @[5] { };
   };

   ToolBar_List @.toolbars = [1] {
    ToolBar @[0] { 
     UserDataItem_List @*(.user_data_) {
      UserDataItem @[0] { };
     };
    };
   };

   FrameViewer_List @.frames = [3] {
    BrowseViewerTaBase @[0] { };
    PanelViewer @[1] { };
    T3PanelViewer @[2] { 
     UserDataItem_List @*(.user_data_) {
      UserDataItem @[0] { };
     };

     T3Panel_List @.panels = [1] {
      T3Panel @[0] { 
       T3DataView_List @.root_view.children = [0] {
       };

       T3SavedView_List @.saved_views = [10] {
	T3SavedView @[0] { };
	T3SavedView @[1] { };
	T3SavedView @[2] { };
	T3SavedView @[3] { };
	T3SavedView @[4] { };
	T3SavedView @[5] { };
	T3SavedView @[6] { };
	T3SavedView @[7] { };
	T3SavedView @[8] { };
	T3SavedView @[9] { };
       };
      };
     };
    };
   };

   DockViewer_List @.docks = [1] {
    ToolBoxDockViewer @[0] { 
     UserDataItem_List @*(.user_data_) {
      UserDataItem @[0] { };
      UserDataItem @[1] { };
      UserDataItem @[2] { };
      UserDataItem @[3] { };
      UserDataItem @[4] { };
      UserDataItem @[5] { };
     };
    };
   };
  };
 };

 Network_Group @.networks = [1] {
  BpNetwork @[0] { 
   UserDataItem_List @*(.user_data_) {
    UserDataItem @[0] { };
    UserDataItem @[1] { };
    UserDataItem @[2] { };
    UserDataItem @[3] { };
    UserDataItem @[4] { };
    UserDataItem @[5] { };
    UserDataItem @[6] { };
    UserDataItem @[7] { };
    UserDataItem @[8] { };
    UserDataItem @[9] { };
    UserDataItem @[10] { };
    UserDataItem @[11] { };
   };

   BaseSpec_Group @.specs = [3] {
    BpUnitSpec @[0] { 
     BaseSpec_Group @.children = [0] {
     };
    };
    BpConSpec @[1] { 
     BaseSpec_Group @.children = [0] {
     };

     Schedule @.lrate_sched = [0] {
     };
    };
    FullPrjnSpec @[2] { 
     BaseSpec_Group @.children = [0] {
     };
    };
   };

   ParamSeq_Group @.param_seqs = [0] {
   };

   Layer_Group @.layers = [3] {
    BpLayer @[0] { 
     Projection_Group @.projections = [0] {
     };

     Unit_Group @.units = [17] {
     };
    };
    BpLayer @[1] { 
     Projection_Group @.projections = [1] {
      Projection @[0] { };
     };

     Unit_Group @.units = [25] {
     };
    };
    BpLayer @[2] { 
     Projection_Group @.projections = [1] {
      Projection @[0] { };
     };

     Unit_Group @.units = [1] {
     };
    };
   };

   Weights_List @.weights = [0] {
   };
  };
 };
};
BpProject .projects[0] {
 name="good";
 desc=;
 tags=;
 version {
  major=0;
  minor=0;
  step=0;
 };
 author=;
 email=;
 license {
  license=NO_LIC;
  owner_name=;
  org=;
  year="2011";
  custom=;
 };
 pub_cite=;
 wiki {wiki="": page_name="": };
 docs {
  name="docs";
  el_typ=taDoc;
  el_def=0;
  taDoc @[0] {
   name="ChangeLog";
   desc=;
   web_doc=0;
   wiki=;
   url="local";
   full_url="local";
   text_size=1;
   text="<html>
<head>ChangeLog</head>
<body>
<h1>ChangeLog</h1>
<ul>

<li>Tue Jan 13 17:28:22 2009 jwgorman <code>weather_bp6.proj</code><br>
  using a bp network

trying bidirectional

think it's still feed forward

set error level crit

ran test

running new training on 9, 15 and 11

trained on 4500+ trials from nodes 15,11,9

saved as bp6

<li>Tue Jan 13 17:28:20 2009 jwgorman <code>weather_bp6.proj</code><br>
  using a bp network

trying bidirectional

think it's still feed forward

set error level crit

ran test

running new training on 9, 15 and 11

trained on 4500+ trials from nodes 15,11,9

saved as bp6

<li>Fri Dec 19 11:11:04 2008 jwgorman <code>weather_bp6.proj</code><br>
  using a bp network

trying bidirectional

think it's still feed forward

set error level crit

ran test

running new training on 9, 15 and 11

trained on 4500+ trials from nodes 15,11,9

saved as bp6

<li>Thu Nov 20 10:04:11 2008 jwgorman <code>weather_bp5.proj</code><br>
  using a bp network

trying bidirectional

think it's still feed forward

set error level crit

ran test

running new training on 9, 15 and 11

trained on 4500+ trials from nodes 15,11,9

<li>Tue Nov 18 11:47:59 2008 jwrgorman <code>weather_bp5.proj</code><br>
  using a bp network

trying bidirectional

think it's still feed forward

set error level crit

ran test

running new training on 9, 15 and 11

<li>Tue Nov 18 05:53:26 2008 jwrgorman <code>weather_bp5.proj</code><br>
  using a bp network

trying bidirectional

think it's still feed forward

set error level crit

ran test

<li>Tue Nov 18 00:10:51 2008 jwrgorman <code>weather_bp4.proj</code><br>
  using a bp network

trying bidirectional

think it's still feed forward

set error level crit

ran test

<li>Sun Nov 16 21:29:34 2008 jwrgorman <code>weather_bp4.proj</code><br>
  using a bp network

trying bidirectional

think it's still feed forward

set error level crit

<li>Wed Oct  1 22:57:58 2008 jwrgorman <code>weather_bp2.proj</code><br>
  using a bp network

trying bidirectional

think it's still feed forward

set error level crit

<li>Wed Oct  1 17:01:42 2008 jwgorman <code>weather_bp2.proj</code><br>
  using a bp network

trying bidirectional

think it's still feed forward

set error level crit

<li>Wed Oct  1 15:41:26 2008 jwgorman <code>weather_bp2.proj</code><br>
  using a bp network

trying bidirectional

think it's still feed forward

<li>Sat Sep 27 22:34:36 2008 jwrgorman <code>weather_bp1.proj</code><br>
  using a bp network

trying bidirectional

<li>Sat Sep 27 22:32:10 2008 jwrgorman <code>weather_bp1.proj</code><br>
  using a bp network

<li>Sat Sep 27 22:20:12 2008 jwrgorman <code>weather_bp1.proj</code><br>
  using a bp network
</ul>
</body>
</html>
";
   html_text="<html>
<head>ChangeLog</head>
<body>
<h1>ChangeLog</h1>
<ul>
<P>
<li>Tue Jan 13 17:28:22 2009 jwgorman <code>weather_bp6.proj</code><br>
  using a bp network
<P>
trying bidirectional
<P>
think it's still feed forward
<P>
set error level crit
<P>
ran test
<P>
running new training on 9, 15 and 11
<P>
trained on 4500+ trials from nodes 15,11,9
<P>
saved as bp6
<P>
<li>Tue Jan 13 17:28:20 2009 jwgorman <code>weather_bp6.proj</code><br>
  using a bp network
<P>
trying bidirectional
<P>
think it's still feed forward
<P>
set error level crit
<P>
ran test
<P>
running new training on 9, 15 and 11
<P>
trained on 4500+ trials from nodes 15,11,9
<P>
saved as bp6
<P>
<li>Fri Dec 19 11:11:04 2008 jwgorman <code>weather_bp6.proj</code><br>
  using a bp network
<P>
trying bidirectional
<P>
think it's still feed forward
<P>
set error level crit
<P>
ran test
<P>
running new training on 9, 15 and 11
<P>
trained on 4500+ trials from nodes 15,11,9
<P>
saved as bp6
<P>
<li>Thu Nov 20 10:04:11 2008 jwgorman <code>weather_bp5.proj</code><br>
  using a bp network
<P>
trying bidirectional
<P>
think it's still feed forward
<P>
set error level crit
<P>
ran test
<P>
running new training on 9, 15 and 11
<P>
trained on 4500+ trials from nodes 15,11,9
<P>
<li>Tue Nov 18 11:47:59 2008 jwrgorman <code>weather_bp5.proj</code><br>
  using a bp network
<P>
trying bidirectional
<P>
think it's still feed forward
<P>
set error level crit
<P>
ran test
<P>
running new training on 9, 15 and 11
<P>
<li>Tue Nov 18 05:53:26 2008 jwrgorman <code>weather_bp5.proj</code><br>
  using a bp network
<P>
trying bidirectional
<P>
think it's still feed forward
<P>
set error level crit
<P>
ran test
<P>
<li>Tue Nov 18 00:10:51 2008 jwrgorman <code>weather_bp4.proj</code><br>
  using a bp network
<P>
trying bidirectional
<P>
think it's still feed forward
<P>
set error level crit
<P>
ran test
<P>
<li>Sun Nov 16 21:29:34 2008 jwrgorman <code>weather_bp4.proj</code><br>
  using a bp network
<P>
trying bidirectional
<P>
think it's still feed forward
<P>
set error level crit
<P>
<li>Wed Oct  1 22:57:58 2008 jwrgorman <code>weather_bp2.proj</code><br>
  using a bp network
<P>
trying bidirectional
<P>
think it's still feed forward
<P>
set error level crit
<P>
<li>Wed Oct  1 17:01:42 2008 jwgorman <code>weather_bp2.proj</code><br>
  using a bp network
<P>
trying bidirectional
<P>
think it's still feed forward
<P>
set error level crit
<P>
<li>Wed Oct  1 15:41:26 2008 jwgorman <code>weather_bp2.proj</code><br>
  using a bp network
<P>
trying bidirectional
<P>
think it's still feed forward
<P>
<li>Sat Sep 27 22:34:36 2008 jwrgorman <code>weather_bp1.proj</code><br>
  using a bp network
<P>
trying bidirectional
<P>
<li>Sat Sep 27 22:32:10 2008 jwrgorman <code>weather_bp1.proj</code><br>
  using a bp network
<P>
<li>Sat Sep 27 22:20:12 2008 jwrgorman <code>weather_bp1.proj</code><br>
  using a bp network
</ul>
</body>
</html>
";
  };
 };
 wizards {
  name="wizards";
  el_typ=Wizard;
  el_def=0;
 };
 ctrl_panels {
  name="ctrl_panels";
  el_typ=ControlPanel;
  el_def=0;
  master_and_clones=0;
  ClusterRun @[0] {
   UserDataItem_List @*(.user_data_) {
    name=;
    el_typ=UserDataItem;
    el_def=0;
    UserDataItem @[0] {name="user_pinned": value=1: val_type_fixed=0: };
   };
   name="ClusterRun";
   cp_state=REGULAR;
   updt_while_running=0;
   desc=;
   mbrs {
    name="mbrs";
    el_typ=ControlPanelMember;
    el_def=0;
   };
   mths {
    name="mths";
    el_typ=ControlPanelMethod;
    el_def=0;
    group_type=GT_BUTTONS;
   };
   search_algos {
    name="search_algos";
    el_typ=ParamSearchAlgo;
    el_def=0;
   };
   use_search_algo=0;
   cur_search_algo=NULL;
   set_proj_name=0;
   proj_name=;
   auto_updt_interval=10;
   auto_updt_timeout=30;
   cluster=;
   clusters=;
   users=;
   last_submit_time=;
   notes=;
   label=;
   extra_files=;
   svn_repo=;
   repo_url=;
   queue=;
   run_time=;
   exe_cmd="emergent";
   ram_gb=0;
   n_threads=1;
   use_cuda=0;
   use_mpi=0;
   mpi_nodes=10;
   mpi_per_node=1;
   parallel_batch=0;
   pb_batches=10;
   pb_n_batches_per=1;
   nowin_x=0;
   enable_kill=0;
   enable_load=0;
   enable_notes=1;
  };
 };
 active_params {
  name="active_params";
  el_typ=ParamSet;
  el_def=0;
  master_and_clones=0;
 };
 archived_params {
  name="archived_params";
  el_typ=ParamSet;
  el_def=0;
  master_and_clones=0;
 };
 data {
  name="data";
  el_typ=DataTable;
  el_def=0;
  save_tables=1;
  DataTable_Group @.gp[0] {
   name="InputData";
   el_typ=DataTable;
   el_def=0;
   save_tables=1;
   DataTable @[0] {
    name="StdInputData";
    desc=;
    data {
     name="data";
     el_typ=String_Data;
     el_def=0;
     String_Data @[0] {
      name="Name";
      col_flags=SAVE_DATA|AUTO_WIDTH;
      is_matrix=0;
      cell_geom{ 1;      };
      calc_expr {
       expr=;
      };
      dim_names {
       name="dim_names";
      [0]       };
      width=16;
      matrix_col_width=10;
      ar {
       name="ar";
      [0]       };
     };
     float_Data @[1] {
      name="Input";
      col_flags=SAVE_DATA|AUTO_WIDTH;
      is_matrix=1;
      cell_geom{ 13;1;      };
      calc_expr {
       expr=;
      };
      dim_names {
       name="dim_names";
      [2] ;;      };
      width=13;
      matrix_col_width=10;
      ar {
       name="ar";
      [13 1 0]       };
     };
     float_Data @[2] {
      name="Output";
      col_flags=SAVE_DATA|AUTO_WIDTH;
      is_matrix=1;
      cell_geom{ 1;1;      };
      calc_expr {
       expr=;
      };
      dim_names {
       name="dim_names";
      [2] ;;      };
      width=6;
      matrix_col_width=10;
      ar {
       name="ar";
      [1 1 0]       };
     };
    };
    data_flags=SAVE_ROWS|AUTO_CALC;
    auto_load=NO_AUTO_LOAD;
    auto_load_file=;
    row_height=1;
    max_col_width=50;
    keygen 4 0=0;
    row_indexes {
     name="row_indexes";
    [0]     };
    last_sort_spec {
     name="last_sort_spec";
     ops {
      name="ops";
      el_typ=DataSortEl;
      el_def=0;
     };
    };
    row_with_hilite=-1;
   };
   DataTable @[1] {
    name="testInput1";
    desc=;
    data {
     name="data";
     el_typ=String_Data;
     el_def=0;
     String_Data @[0] {
      name="Name";
      col_flags=SAVE_DATA|AUTO_WIDTH;
      is_matrix=0;
      cell_geom{ 1;      };
      calc_expr {
       expr=;
      };
      dim_names {
       name="dim_names";
      [0]       };
      width=16;
      matrix_col_width=10;
      ar {
       name="ar";
      [0]       };
     };
     float_Data @[1] {
      name="Input";
      col_flags=SAVE_DATA|AUTO_WIDTH;
      is_matrix=1;
      cell_geom{ 17;1;      };
      calc_expr {
       expr=;
      };
      dim_names {
       name="dim_names";
      [2] ;;      };
      width=17;
      matrix_col_width=10;
      ar {
       name="ar";
      [17 1 0]       };
     };
     float_Data @[2] {
      name="Output";
      col_flags=SAVE_DATA|AUTO_WIDTH;
      is_matrix=1;
      cell_geom{ 1;1;      };
      calc_expr {
       expr=;
      };
      dim_names {
       name="dim_names";
      [2] ;;      };
      width=6;
      matrix_col_width=10;
      ar {
       name="ar";
      [1 1 0]       };
     };
    };
    data_flags=SAVE_ROWS|AUTO_CALC;
    auto_load=NO_AUTO_LOAD;
    auto_load_file=;
    row_height=1;
    max_col_width=50;
    keygen 4 0=0;
    row_indexes {
     name="row_indexes";
    [0]     };
    last_sort_spec {
     name="last_sort_spec";
     ops {
      name="ops";
      el_typ=DataSortEl;
      el_def=0;
     };
    };
    row_with_hilite=-1;
   };
  };
  DataTable_Group @.gp[1] {
   name="OutputData";
   el_typ=DataTable;
   el_def=0;
   save_tables=1;
   DataTable @[0] {
    name="TrialOutputData";
    desc=;
    data {
     name="data";
     el_typ=int_Data;
     el_def=0;
     int_Data @[0] {
      UserDataItem_List @*(.user_data_) {
       name="UserDataItem_List_15";
       el_typ=UserDataItem;
       el_def=0;
       UserDataItem @[0] {name="NARROW": value=1: val_type_fixed=0: };
      };
      name="batch";
      col_flags=MARK|PIN|SAVE_DATA|AUTO_WIDTH;
      is_matrix=0;
      cell_geom{ 1;      };
      calc_expr {
       expr=;
      };
      dim_names {
       name="dim_names";
      [0]       };
      width=8;
      matrix_col_width=10;
      ar {
       name="ar";
      [0]       };
     };
     int_Data @[1] {
      UserDataItem_List @*(.user_data_) {
       name="UserDataItem_List_16";
       el_typ=UserDataItem;
       el_def=0;
       UserDataItem @[0] {name="NARROW": value=1: val_type_fixed=0: };
      };
      name="epoch";
      col_flags=MARK|PIN|SAVE_DATA|AUTO_WIDTH;
      is_matrix=0;
      cell_geom{ 1;      };
      calc_expr {
       expr=;
      };
      dim_names {
       name="dim_names";
      [0]       };
      width=8;
      matrix_col_width=10;
      ar {
       name="ar";
      [0]       };
     };
     int_Data @[2] {
      UserDataItem_List @*(.user_data_) {
       name="UserDataItem_List_17";
       el_typ=UserDataItem;
       el_def=0;
       UserDataItem @[0] {name="NARROW": value=1: val_type_fixed=0: };
      };
      name="trial";
      col_flags=MARK|PIN|SAVE_DATA|AUTO_WIDTH;
      is_matrix=0;
      cell_geom{ 1;      };
      calc_expr {
       expr=;
      };
      dim_names {
       name="dim_names";
      [0]       };
      width=8;
      matrix_col_width=10;
      ar {
       name="ar";
      [0]       };
     };
     String_Data @[3] {
      name="trial_name";
      col_flags=MARK|PIN|SAVE_DATA|AUTO_WIDTH;
      is_matrix=0;
      cell_geom{ 1;      };
      calc_expr {
       expr=;
      };
      dim_names {
       name="dim_names";
      [0]       };
      width=16;
      matrix_col_width=10;
      ar {
       name="ar";
      [0]       };
     };
     String_Data @[4] {
      name="group_name";
      col_flags=MARK|PIN|SAVE_DATA|AUTO_WIDTH;
      is_matrix=0;
      cell_geom{ 1;      };
      calc_expr {
       expr=;
      };
      dim_names {
       name="dim_names";
      [0]       };
      width=16;
      matrix_col_width=10;
      ar {
       name="ar";
      [0]       };
     };
     float_Data @[5] {
      name="sse";
      col_flags=MARK|PIN|SAVE_DATA|AUTO_WIDTH;
      is_matrix=0;
      cell_geom{ 1;      };
      calc_expr {
       expr=;
      };
      dim_names {
       name="dim_names";
      [0]       };
      width=8;
      matrix_col_width=10;
      ar {
       name="ar";
      [0]       };
     };
    };
    data_flags=SAVE_ROWS|AUTO_CALC;
    auto_load=NO_AUTO_LOAD;
    auto_load_file=;
    row_height=1;
    max_col_width=50;
    keygen 4 0=0;
    row_indexes {
     name="row_indexes";
    [0]     };
    last_sort_spec {
     name="last_sort_spec";
     ops {
      name="ops";
      el_typ=DataSortEl;
      el_def=0;
     };
    };
    row_with_hilite=-1;
   };
   DataTable @[1] {
    name="EpochOutputData";
    desc=;
    data {
     name="data";
     el_typ=int_Data;
     el_def=0;
     int_Data @[0] {
      UserDataItem_List @*(.user_data_) {
       name="UserDataItem_List_16";
       el_typ=UserDataItem;
       el_def=0;
       UserDataItem @[0] {name="NARROW": value=1: val_type_fixed=0: };
      };
      name="batch";
      col_flags=MARK|PIN|SAVE_DATA|AUTO_WIDTH;
      is_matrix=0;
      cell_geom{ 1;      };
      calc_expr {
       expr=;
      };
      dim_names {
       name="dim_names";
      [0]       };
      width=8;
      matrix_col_width=10;
      ar {
       name="ar";
      [0]       };
     };
     int_Data @[1] {
      UserDataItem_List @*(.user_data_) {
       name="UserDataItem_List_17";
       el_typ=UserDataItem;
       el_def=0;
       UserDataItem @[0] {name="NARROW": value=1: val_type_fixed=0: };
      };
      name="epoch";
      col_flags=MARK|PIN|SAVE_DATA|AUTO_WIDTH;
      is_matrix=0;
      cell_geom{ 1;      };
      calc_expr {
       expr=;
      };
      dim_names {
       name="dim_names";
      [0]       };
      width=8;
      matrix_col_width=10;
      ar {
       name="ar";
      [0]       };
     };
     float_Data @[2] {
      name="avg_sse";
      col_flags=MARK|PIN|SAVE_DATA|AUTO_WIDTH;
      is_matrix=0;
      cell_geom{ 1;      };
      calc_expr {
       expr=;
      };
      dim_names {
       name="dim_names";
      [0]       };
      width=8;
      matrix_col_width=10;
      ar {
       name="ar";
      [0]       };
     };
     float_Data @[3] {
      name="cnt_err";
      col_flags=MARK|PIN|SAVE_DATA|AUTO_WIDTH;
      is_matrix=0;
      cell_geom{ 1;      };
      calc_expr {
       expr=;
      };
      dim_names {
       name="dim_names";
      [0]       };
      width=8;
      matrix_col_width=10;
      ar {
       name="ar";
      [0]       };
     };
     float_Data @[4] {
      name="epoch_time_tot";
      col_flags=MARK|PIN|SAVE_DATA|AUTO_WIDTH;
      is_matrix=0;
      cell_geom{ 1;      };
      calc_expr {
       expr=;
      };
      dim_names {
       name="dim_names";
      [0]       };
      width=14;
      matrix_col_width=10;
      ar {
       name="ar";
      [0]       };
     };
     float_Data @[5] {
      name="epoch_time_usr";
      col_flags=MARK|PIN|SAVE_DATA|AUTO_WIDTH;
      is_matrix=0;
      cell_geom{ 1;      };
      calc_expr {
       expr=;
      };
      dim_names {
       name="dim_names";
      [0]       };
      width=14;
      matrix_col_width=10;
      ar {
       name="ar";
      [0]       };
     };
    };
    data_flags=SAVE_ROWS|AUTO_CALC;
    auto_load=NO_AUTO_LOAD;
    auto_load_file=;
    row_height=1;
    max_col_width=50;
    keygen 4 0=0;
    row_indexes {
     name="row_indexes";
    [0]     };
    last_sort_spec {
     name="last_sort_spec";
     ops {
      name="ops";
      el_typ=DataSortEl;
      el_def=0;
     };
    };
    row_with_hilite=-1;
   };
   DataTable @[2] {
    name="TrialTestOutputData";
    desc=;
    data {
     name="data";
     el_typ=int_Data;
     el_def=0;
     int_Data @[0] {
      UserDataItem_List @*(.user_data_) {
       name="UserDataItem_List_15";
       el_typ=UserDataItem;
       el_def=0;
       UserDataItem @[0] {name="NARROW": value=1: val_type_fixed=0: };
      };
      name="batch";
      col_flags=MARK|PIN|SAVE_DATA|AUTO_WIDTH;
      is_matrix=0;
      cell_geom{ 1;      };
      calc_expr {
       expr=;
      };
      dim_names {
       name="dim_names";
      [0]       };
      width=8;
      matrix_col_width=10;
      ar {
       name="ar";
      [0]       };
     };
     int_Data @[1] {
      UserDataItem_List @*(.user_data_) {
       name="UserDataItem_List_16";
       el_typ=UserDataItem;
       el_def=0;
       UserDataItem @[0] {name="NARROW": value=1: val_type_fixed=0: };
      };
      name="epoch";
      col_flags=MARK|PIN|SAVE_DATA|AUTO_WIDTH;
      is_matrix=0;
      cell_geom{ 1;      };
      calc_expr {
       expr=;
      };
      dim_names {
       name="dim_names";
      [0]       };
      width=8;
      matrix_col_width=10;
      ar {
       name="ar";
      [0]       };
     };
     int_Data @[2] {
      UserDataItem_List @*(.user_data_) {
       name="UserDataItem_List_17";
       el_typ=UserDataItem;
       el_def=0;
       UserDataItem @[0] {name="NARROW": value=1: val_type_fixed=0: };
      };
      name="trial";
      col_flags=MARK|PIN|SAVE_DATA|AUTO_WIDTH;
      is_matrix=0;
      cell_geom{ 1;      };
      calc_expr {
       expr=;
      };
      dim_names {
       name="dim_names";
      [0]       };
      width=8;
      matrix_col_width=10;
      ar {
       name="ar";
      [0]       };
     };
     String_Data @[3] {
      name="trial_name";
      col_flags=MARK|PIN|SAVE_DATA|AUTO_WIDTH;
      is_matrix=0;
      cell_geom{ 1;      };
      calc_expr {
       expr=;
      };
      dim_names {
       name="dim_names";
      [0]       };
      width=16;
      matrix_col_width=10;
      ar {
       name="ar";
      [0]       };
     };
     String_Data @[4] {
      name="group_name";
      col_flags=MARK|PIN|SAVE_DATA|AUTO_WIDTH;
      is_matrix=0;
      cell_geom{ 1;      };
      calc_expr {
       expr=;
      };
      dim_names {
       name="dim_names";
      [0]       };
      width=16;
      matrix_col_width=10;
      ar {
       name="ar";
      [0]       };
     };
     float_Data @[5] {
      name="sse";
      col_flags=MARK|PIN|SAVE_DATA|AUTO_WIDTH;
      is_matrix=0;
      cell_geom{ 1;      };
      calc_expr {
       expr=;
      };
      dim_names {
       name="dim_names";
      [0]       };
      width=8;
      matrix_col_width=10;
      ar {
       name="ar";
      [0]       };
     };
     float_Data @[6] {
      name="Output_act";
      col_flags=MARK|PIN|SAVE_DATA|AUTO_WIDTH;
      is_matrix=1;
      cell_geom{ 1;1;      };
      calc_expr {
       expr=;
      };
      dim_names {
       name="dim_names";
      [2] ;;      };
      width=10;
      matrix_col_width=10;
      ar {
       name="ar";
      [1 1 0]       };
     };
     float_Data @[7] {
      name="Output_targ";
      col_flags=MARK|PIN|SAVE_DATA|AUTO_WIDTH;
      is_matrix=1;
      cell_geom{ 1;1;      };
      calc_expr {
       expr=;
      };
      dim_names {
       name="dim_names";
      [2] ;;      };
      width=11;
      matrix_col_width=10;
      ar {
       name="ar";
      [1 1 0]       };
     };
     float_Data @[8] {
      name="Output_Output";
      col_flags=MARK|PIN|SAVE_DATA|AUTO_WIDTH;
      is_matrix=1;
      cell_geom{ 1;1;      };
      calc_expr {
       expr=;
      };
      dim_names {
       name="dim_names";
      [2] ;;      };
      width=13;
      matrix_col_width=10;
      ar {
       name="ar";
      [1 1 0]       };
     };
    };
    data_flags=SAVE_ROWS|AUTO_CALC;
    auto_load=NO_AUTO_LOAD;
    auto_load_file=;
    row_height=1;
    max_col_width=50;
    keygen 4 0=0;
    row_indexes {
     name="row_indexes";
    [0]     };
    last_sort_spec {
     name="last_sort_spec";
     ops {
      name="ops";
      el_typ=DataSortEl;
      el_def=0;
     };
    };
    row_with_hilite=-1;
   };
   DataTable @[3] {
    name="EpochTestOutputData";
    desc=;
    data {
     name="data";
     el_typ=int_Data;
     el_def=0;
     int_Data @[0] {
      UserDataItem_List @*(.user_data_) {
       name="UserDataItem_List_16";
       el_typ=UserDataItem;
       el_def=0;
       UserDataItem @[0] {name="NARROW": value=1: val_type_fixed=0: };
      };
      name="batch";
      col_flags=MARK|PIN|SAVE_DATA|AUTO_WIDTH;
      is_matrix=0;
      cell_geom{ 1;      };
      calc_expr {
       expr=;
      };
      dim_names {
       name="dim_names";
      [0]       };
      width=8;
      matrix_col_width=10;
      ar {
       name="ar";
      [0]       };
     };
     int_Data @[1] {
      UserDataItem_List @*(.user_data_) {
       name="UserDataItem_List_17";
       el_typ=UserDataItem;
       el_def=0;
       UserDataItem @[0] {name="NARROW": value=1: val_type_fixed=0: };
      };
      name="epoch";
      col_flags=MARK|PIN|SAVE_DATA|AUTO_WIDTH;
      is_matrix=0;
      cell_geom{ 1;      };
      calc_expr {
       expr=;
      };
      dim_names {
       name="dim_names";
      [0]       };
      width=8;
      matrix_col_width=10;
      ar {
       name="ar";
      [0]       };
     };
     float_Data @[2] {
      name="avg_sse";
      col_flags=MARK|PIN|SAVE_DATA|AUTO_WIDTH;
      is_matrix=0;
      cell_geom{ 1;      };
      calc_expr {
       expr=;
      };
      dim_names {
       name="dim_names";
      [0]       };
      width=8;
      matrix_col_width=10;
      ar {
       name="ar";
      [0]       };
     };
     float_Data @[3] {
      name="cnt_err";
      col_flags=MARK|PIN|SAVE_DATA|AUTO_WIDTH;
      is_matrix=0;
      cell_geom{ 1;      };
      calc_expr {
       expr=;
      };
      dim_names {
       name="dim_names";
      [0]       };
      width=8;
      matrix_col_width=10;
      ar {
       name="ar";
      [0]       };
     };
     float_Data @[4] {
      name="epoch_time_tot";
      col_flags=MARK|PIN|SAVE_DATA|AUTO_WIDTH;
      is_matrix=0;
      cell_geom{ 1;      };
      calc_expr {
       expr=;
      };
      dim_names {
       name="dim_names";
      [0]       };
      width=14;
      matrix_col_width=10;
      ar {
       name="ar";
      [0]       };
     };
     float_Data @[5] {
      name="epoch_time_usr";
      col_flags=MARK|PIN|SAVE_DATA|AUTO_WIDTH;
      is_matrix=0;
      cell_geom{ 1;      };
      calc_expr {
       expr=;
      };
      dim_names {
       name="dim_names";
      [0]       };
      width=14;
      matrix_col_width=10;
      ar {
       name="ar";
      [0]       };
     };
    };
    data_flags=SAVE_ROWS|AUTO_CALC;
    auto_load=NO_AUTO_LOAD;
    auto_load_file=;
    row_height=1;
    max_col_width=50;
    keygen 4 0=0;
    row_indexes {
     name="row_indexes";
    [0]     };
    last_sort_spec {
     name="last_sort_spec";
     ops {
      name="ops";
      el_typ=DataSortEl;
      el_def=0;
     };
    };
    row_with_hilite=-1;
   };
  };
  DataTable_Group @.gp[2] {
   name="AnalysisData";
   el_typ=DataTable;
   el_def=0;
   save_tables=1;
  };
 };
 programs {
  name="programs";
  el_typ=Program;
  el_def=0;
  tags=;
  desc=;
  debug_mode=0;
  Program @[0] {
   UserDataItem_List @*(.user_data_) {
    name=;
    el_typ=UserData_DocLink;
    el_def=0;
    UserData_DocLink @[0] {name="DocLink": doc=.programs[0].doc$$: };
   };
   name="BpStartup";
   short_nm="Startup";
   tags="Bp, Startup, Parallel Batch";
   desc="run project in the background command line is: emergent -nogui -ni -p <project name>.proj [epochs=xxx] [batches=xxx] [tag=xxx] | [b_start=xxx] [b_end=xxx] for parallel-batch mode";
   version {
    major=0;
    minor=0;
    step=0;
   };
   author=;
   email=;
   flags=NO_STOP_STEP|STARTUP_RUN;
   stop_step_cond {
    expr=;
   };
   objs {
    name="objs";
    el_typ=taNBase;
    el_def=0;
   };
   objs_vars {
    name="objs_vars";
    el_typ=ProgVar;
    el_def=0;
   };
   types {
    name="types";
    el_typ=DynEnumType;
    el_def=0;
   };
   args {
    name="args";
    el_typ=ProgVar;
    el_def=0;
    ProgVar @[0] {
     name="network";
     var_type=T_Object;
     object_type=BpNetwork;
     object_val=.networks[0]$$;
     object_scope=NULL;
     objs_ptr=0;
     flags=CTRL_PANEL|NULL_CHECK|SAVE_VAL|USED|EDIT_VAL|PGRM_ARG;
     reference=0;
     desc="network to operate on -- updates batch counter on network and passes it to train program";
     init_from=NULL;
    };
    ProgVar @[1] {
     name="input_data";
     var_type=T_Object;
     object_type=DataTable;
     object_val=.data.gp[0][1]$$;
     object_scope=NULL;
     objs_ptr=0;
     flags=CTRL_PANEL|NULL_CHECK|SAVE_VAL|USED|EDIT_VAL|PGRM_ARG;
     reference=0;
     desc="datatable with training patterns -- not used by this program, but passed to train program";
     init_from=NULL;
    };
   };
   vars {
    name="vars";
    el_typ=ProgVar;
    el_def=0;
    ProgVar @[0] {
     name="train";
     var_type=T_Object;
     object_type=Program;
     object_val=.programs.gp[0][1]$$;
     object_scope=NULL;
     objs_ptr=0;
     flags=CTRL_PANEL|NULL_CHECK|SAVE_VAL|EDIT_VAL;
     reference=0;
     desc="set this to point to your train process";
     init_from=NULL;
    };
    ProgVar @[1] {
     name="batch";
     var_type=T_Object;
     object_type=Program;
     object_val=.programs.gp[0][0]$$;
     object_scope=NULL;
     objs_ptr=0;
     flags=CTRL_PANEL|NULL_CHECK|SAVE_VAL|USED|EDIT_VAL;
     reference=0;
     desc="set this to point to your batch process";
     init_from=NULL;
    };
    ProgVar @[2] {
     name="tag";
     var_type=T_String;
     string_val="test1";
     object_scope=NULL;
     flags=CTRL_PANEL|NULL_CHECK|SAVE_VAL|USED|EDIT_VAL;
     reference=0;
     desc=;
     init_from=NULL;
    };
    ProgVar @[3] {
     name="mode";
     var_type=T_String;
     string_val="question";
     object_scope=NULL;
     flags=CTRL_PANEL|NULL_CHECK|SAVE_VAL|USED|EDIT_VAL;
     reference=0;
     desc=;
     init_from=NULL;
    };
    ProgVar @[4] {
     name="batch_str";
     var_type=T_String;
     string_val="0";
     object_scope=NULL;
     flags=CTRL_PANEL|NULL_CHECK|SAVE_VAL|EDIT_VAL;
     reference=0;
     desc="batch number as a string (leading zeros)";
     init_from=NULL;
    };
    ProgVar @[5] {
     name="log_dir";
     var_type=T_String;
     string_val="log";
     object_scope=NULL;
     flags=CTRL_PANEL|NULL_CHECK|SAVE_VAL|USED|EDIT_VAL;
     reference=0;
     desc="log file directory";
     init_from=NULL;
    };
    ProgVar @[6] {
     name="output_file";
     var_type=T_String;
     object_scope=NULL;
     flags=CTRL_PANEL|NULL_CHECK|USED|EDIT_VAL;
     reference=0;
     desc="output file of export data";
     init_from=NULL;
    };
    ProgVar @[7] {
     name="input_file";
     var_type=T_String;
     object_scope=NULL;
     flags=CTRL_PANEL|NULL_CHECK|USED|EDIT_VAL;
     reference=0;
     desc="ipout file of new import data content";
     init_from=NULL;
    };
    ProgVar @[8] {
     name="input_weights_file";
     var_type=T_String;
     object_scope=NULL;
     flags=CTRL_PANEL|NULL_CHECK|USED|EDIT_VAL;
     reference=0;
     desc="weights file to load";
     init_from=NULL;
    };
    ProgVar @[9] {
     name="output_weights_file";
     var_type=T_String;
     object_scope=NULL;
     flags=CTRL_PANEL|NULL_CHECK|USED|EDIT_VAL;
     reference=0;
     desc="weights file to load";
     init_from=NULL;
    };
    ProgVar @[10] {
     name="log_file_nm";
     var_type=T_String;
     string_val="/var/www/html/solarquant/emergent/log/logFile1.txt";
     object_scope=NULL;
     flags=CTRL_PANEL|NULL_CHECK|SAVE_VAL|USED|EDIT_VAL;
     reference=0;
     desc="name of log file";
     init_from=NULL;
    };
    ProgVar @[11] {
     name="batch_start";
     var_type=T_Int;
     int_val=1;
     object_scope=NULL;
     flags=CTRL_PANEL|NULL_CHECK|SAVE_VAL|EDIT_VAL;
     reference=0;
     desc="batch starting number";
     init_from=NULL;
    };
    ProgVar @[12] {
     name="EpochOutputData";
     var_type=T_Object;
     object_type=DataTable;
     object_val=.data.gp[1][1]$$;
     object_scope=NULL;
     objs_ptr=0;
     flags=CTRL_PANEL|NULL_CHECK|SAVE_VAL|USED|EDIT_VAL;
     reference=0;
     desc=;
     init_from=NULL;
    };
    ProgVar @[13] {
     name="TrialOutputData";
     var_type=T_Object;
     object_type=DataTable;
     object_val=.data.gp[1][0]$$;
     object_scope=NULL;
     objs_ptr=0;
     flags=CTRL_PANEL|NULL_CHECK|SAVE_VAL|USED|EDIT_VAL;
     reference=0;
     desc=;
     init_from=NULL;
    };
   };
   functions {
    name="functions";
    el_typ=Function;
    el_def=0;
   };
   init_code {
    name="init_code";
    el_typ=ProgCode;
    el_def=0;
   };
   prog_code {
    name="prog_code";
    el_typ=ProgCode;
    el_def=0;
    LocalVars @[0] {
     name="LocalVars_LocalVars0vars";
     desc=;
     flags=CAN_REVERT_TO_CODE;
     code_string="LocalVars (0 vars)";
     local_vars {
      name="local_vars";
      el_typ=ProgVar;
      el_def=0;
     };
    };
    ReturnExpr @[1] {
     name="ReturnExpr_return";
     desc=;
     flags=OFF;
     code_string=;
     expr {
      expr=;
     };
    };
    RegisterArgs @[2] {
     name="RegisterArgs_RegisterArgs";
     desc="This is KEY!!! actually processes all args, including those from ProgVarFmArg guys below";
     flags=CAN_REVERT_TO_CODE;
     code_string="Register Args";
    };
    PrintExpr @[3] {
     name="PrintExpr_PrintLoadedproje_ojects0filename";
     desc=;
     flags=CAN_REVERT_TO_CODE;
     code_string="Print \"Loaded project: \" << .projects[0].file_name";
     expr {
      expr="\"Loaded project: \" << .projects[0].file_name";
     };
     debug=0;
    };
    PrintExpr @[4] {
     name="PrintExpr_Printlogdirlogdir";
     desc=;
     flags=CAN_REVERT_TO_CODE;
     code_string="Print \"log_dir: \" << log_dir";
     expr {
      expr="\"log_dir: \" << log_dir";
     };
     debug=0;
    };
    PrintExpr @[5] {
     name="PrintExpr_Printtagtag";
     desc=;
     flags=CAN_REVERT_TO_CODE;
     code_string="Print \"tag: \" << tag";
     expr {
      expr="\"tag: \" << tag";
     };
     debug=0;
    };
    PrintExpr @[6] {
     name="PrintExpr_Printinputfileinputfile";
     desc=;
     flags=CAN_REVERT_TO_CODE;
     code_string="Print \"input_file: \" << input_file";
     expr {
      expr="\"input_file: \" << input_file";
     };
     debug=0;
    };
    PrintExpr @[7] {
     name="PrintExpr_Printoutputfileoutputfile";
     desc=;
     flags=CAN_REVERT_TO_CODE;
     code_string="Print \"output_file: \" << output_file";
     expr {
      expr="\"output_file: \" << output_file";
     };
     debug=0;
    };
    PrintExpr @[8] {
     name="PrintExpr_Printinputweight_nputweightsfile";
     desc=;
     flags=CAN_REVERT_TO_CODE;
     code_string="Print \"input weights_file: \" << input_weights_file";
     expr {
      expr="\"input weights_file: \" << input_weights_file";
     };
     debug=0;
    };
    PrintExpr @[9] {
     name="PrintExpr_Printoutputweigh_tputweightsfile";
     desc=;
     flags=CAN_REVERT_TO_CODE;
     code_string="Print \"output weights_file: \" << output_weights_file";
     expr {
      expr="\"output weights_file: \" << output_weights_file";
     };
     debug=0;
    };
    Comment @[10] {
     name="Comment_Stdvariablesinst_upprogramitself";
     desc="= Std variables in startup program itself =";
     flags=CAN_REVERT_TO_CODE;
     code_string="// = Std variables in startup program itself =";
    };
    ProgVarFmArg @[11] {
     name="ProgVarFmArg_SetVartaginProgr_artupfromArgtag";
     desc=;
     flags=CAN_REVERT_TO_CODE;
     code_string="Set Var:tag in Program:BpStartup from Arg:tag";
     prog=.programs[0]$$;
     var_name="tag";
     arg_name="tag";
    };
    ProgVarFmArg @[12] {
     name="ProgVarFmArg_SetVarlogdirinPr_upfromArglogdir";
     desc=;
     flags=CAN_REVERT_TO_CODE;
     code_string="Set Var:log_dir in Program:BpStartup from Arg:log_dir";
     prog=$.programs[0]$;
     var_name="log_dir";
     arg_name="log_dir";
    };
    ProgVarFmArg @[13] {
     name="ProgVarFmArg_SetVarlogfilenmi_romArglogfilenm";
     desc=;
     flags=CAN_REVERT_TO_CODE;
     code_string="Set Var:log_file_nm in Program:BpStartup from Arg:log_file_nm";
     prog=$.programs[0]$;
     var_name="log_file_nm";
     arg_name="log_file_nm";
    };
    ProgVarFmArg @[14] {
     name="ProgVarFmArg_SetVarmaxepochin_infromArgepochs";
     desc=;
     flags=CAN_REVERT_TO_CODE;
     code_string="Set Var:max_epoch in Program:BpTrain from Arg:epochs";
     prog=$.programs.gp[0][1]$;
     var_name="max_epoch";
     arg_name="epochs";
    };
    ProgVarFmArg @[15] {
     name="ProgVarFmArg_SetVarrndinitinP_nfromArgrndinit";
     desc=;
     flags=CAN_REVERT_TO_CODE;
     code_string="Set Var:rnd_init in Program:BpTrain from Arg:rnd_init";
     prog=$.programs.gp[0][1]$;
     var_name="rnd_init";
     arg_name="rnd_init";
    };
    ProgVarFmArg @[16] {
     name="ProgVarFmArg_SetVarmaxbatchin_hfromArgbatches";
     desc=;
     flags=CAN_REVERT_TO_CODE;
     code_string="Set Var:max_batch in Program:BpBatch from Arg:batches";
     prog=$.programs.gp[0][0]$;
     var_name="max_batch";
     arg_name="batches";
    };
    ProgVarFmArg @[17] {
     name="ProgVarFmArg_SetVarmaxbatchin_atchfromArgbend";
     desc="b_end is parallel-batch mode of operation (see b_start)";
     flags=CAN_REVERT_TO_CODE;
     code_string="Set Var:max_batch in Program:BpBatch from Arg:b_end";
     prog=$.programs.gp[0][0]$;
     var_name="max_batch";
     arg_name="b_end";
    };
    ProgVarFmArg @[18] {
     name="ProgVarFmArg_SetVarbatchinPro_chfromArgbstart";
     desc="b_start is parallel-batch mode of operation (see also b_end)";
     flags=CAN_REVERT_TO_CODE;
     code_string="Set Var:batch in Program:BpBatch from Arg:b_start";
     prog=$.programs.gp[0][0]$;
     var_name="batch";
     arg_name="b_start";
    };
    ProgVarFmArg @[19] {
     name="ProgVarFmArg_SetVaroutputfile_omArgoutputfile";
     desc=;
     flags=VERBOSE|CAN_REVERT_TO_CODE;
     code_string="Set Var:output_file in Program:BpStartup from Arg:output_file";
     prog=$.programs[0]$;
     var_name="output_file";
     arg_name="output_file";
    };
    ProgVarFmArg @[20] {
     name="ProgVarFmArg_SetVarinputfilei_romArginputfile";
     desc=;
     flags=VERBOSE|CAN_REVERT_TO_CODE;
     code_string="Set Var:input_file in Program:BpStartup from Arg:input_file";
     prog=$.programs[0]$;
     var_name="input_file";
     arg_name="input_file";
    };
    ProgVarFmArg @[21] {
     name="ProgVarFmArg_SetVarinputweigh_nputweightsfile";
     desc=;
     flags=VERBOSE|CAN_REVERT_TO_CODE;
     code_string="Set Var:input_weights_file in Program:BpStartup from Arg:input_weights_file";
     prog=$.programs[0]$;
     var_name="input_weights_file";
     arg_name="input_weights_file";
    };
    ProgVarFmArg @[22] {
     name="ProgVarFmArg_SetVaroutputweig_tputweightsfile";
     desc=;
     flags=VERBOSE|CAN_REVERT_TO_CODE;
     code_string="Set Var:output_weights_file in Program:BpStartup from Arg:output_weights_file";
     prog=$.programs[0]$;
     var_name="output_weights_file";
     arg_name="output_weights_file";
    };
    ProgVarFmArg @[23] {
     name="ProgVarFmArg_SetVarmodeinProg_rtupfromArgmode";
     desc=;
     flags=VERBOSE|CAN_REVERT_TO_CODE;
     code_string="Set Var:mode in Program:BpStartup from Arg:mode";
     prog=$.programs[0]$;
     var_name="mode";
     arg_name="mode";
    };
    PrintExpr @[24] {
     name="PrintExpr_Printlogfilenmsentlogfilenm";
     desc=;
     flags=CAN_REVERT_TO_CODE;
     code_string="Print \"log_file_nm sent: \" << log_file_nm";
     expr {
      expr="\"log_file_nm sent: \" << log_file_nm";
     };
     debug=0;
    };
    PrintExpr @[25] {
     name="PrintExpr_Printmodesentmode";
     desc=;
     flags=CAN_REVERT_TO_CODE;
     code_string="Print \"mode sent: \" << mode";
     expr {
      expr="\"mode sent: \" << mode";
     };
     debug=0;
    };
    AssignExpr @[26] {
     name="AssignExpr_logfilenmlogfilenm";
     desc="last arg is to include dmem proc number";
     flags=CAN_REVERT_TO_CODE;
     code_string="log_file_nm = log_file_nm";
     result_var=.programs[0].vars[10]$$;
     expr {
      expr="log_file_nm";
     };
    };
    PrintExpr @[27] {
     name="PrintExpr_Printlogfilenmjustsetlogfilenm";
     desc=;
     flags=CAN_REVERT_TO_CODE;
     code_string="Print \"log_file_nm just set: \" << log_file_nm";
     expr {
      expr="\"log_file_nm just set: \" << log_file_nm";
     };
     debug=0;
    };
    If @[28] {
     name="If_ifmodequestion";
     desc=;
     flags=CAN_REVERT_TO_CODE;
     code_string="if (mode == \"question\")";
     cond {
      expr="mode == \"question\"";
     };
     true_code {
      name="true_code";
      el_typ=ProgCode;
      el_def=0;
      PrintExpr @[0] {
       name="PrintExpr_Printinmodequestionmode";
       desc=;
       flags=OFF;
       code_string=;
       expr {
	expr="\"in mode question: \" << mode";
       };
       debug=0;
      };
      PrintExpr @[1] {
       name="PrintExpr_Printbeforeloadi_nputweightsfile";
       desc=;
       flags=CAN_REVERT_TO_CODE;
       code_string="Print \"before loadiing weights_file:\" << input_weights_file";
       expr {
	expr="\"before loadiing weights_file:\" << input_weights_file";
       };
       debug=0;
      };
      MethodCall @[2] {
       name="MethodCall_networkLoadWeigh_nputweightsfile";
       desc="load weights from that file name";
       flags=VERBOSE|PROG_ERROR|CAN_REVERT_TO_CODE;
       code_string="network->LoadWeights(input_weights_file, )";
       result_var=NULL;
       obj=.programs[0].args[0]$$;
       method=Network::LoadWeights;
       meth_args {
	name="meth_args";
	el_typ=ProgArg;
	el_def=0;
	ProgArg @[0] {
	 arg_type=const_taString_ref;
	 type="taString&";
	 name="fname";
	 required=0;
	 def_val="\"\"";
	 prev_expr=;
	 expr {
	  expr="input_weights_file";
	 };
	};
	ProgArg @[1] {
	 arg_type=bool;
	 type="bool";
	 name="quiet";
	 required=0;
	 def_val="false";
	 prev_expr=;
	 expr {
	  expr=;
	 };
	};
       };
       meth_sig="bool LoadWeights(taString& fname, bool quiet = false)";
       meth_desc=" read weight values in from a simple ordered list of weights (fmt is read from file) (leave fname empty to pull up file chooser)";
      };
      PrintExpr @[3] {
       name="PrintExpr_Printafterloadii_nputweightsfile";
       desc=;
       flags=CAN_REVERT_TO_CODE;
       code_string="Print \"after loadiing weights_file:\" << input_weights_file";
       expr {
	expr="\"after loadiing weights_file:\" << input_weights_file";
       };
       debug=0;
      };
      ProgramCall @[4] {
       name="ProgramCall_ImportDatainputdatainputfile";
       desc=;
       flags=CAN_REVERT_TO_CODE;
       code_string="ImportData(input_data, input_file)";
       prog_args {
	name="prog_args";
	el_typ=ProgArg;
	el_def=0;
	ProgArg @[0] {
	 arg_type=DataTable;
	 type="DataTable*";
	 name="NewData";
	 required=1;
	 def_val=;
	 prev_expr=;
	 expr {
	  expr="input_data";
	 };
	};
	ProgArg @[1] {
	 arg_type=taString;
	 type="String";
	 name="inputFile";
	 required=1;
	 def_val=;
	 prev_expr=;
	 expr {
	  expr="input_file";
	 };
	};
       };
       target=.programs.gp[0][9]$$;
       targ_ld_init="*ImportData*";
      };
      ProgramCall @[5] {
       name="ProgramCall_BpEpochTestnetwork";
       desc=;
       flags=VERBOSE|CAN_REVERT_TO_CODE;
       code_string="BpEpochTest(network)";
       prog_args {
	name="prog_args";
	el_typ=ProgArg;
	el_def=0;
	ProgArg @[0] {
	 arg_type=BpNetwork;
	 type="BpNetwork*";
	 name="network";
	 required=1;
	 def_val=;
	 prev_expr=;
	 expr {
	  expr="network";
	 };
	};
       };
       target=.programs.gp[1][0]$$;
       targ_ld_init="*BpEpochTest*";
      };
      ProgramCall @[6] {
       name="ProgramCall_ExportDataTrialO_tDataoutputfile";
       desc=;
       flags=CAN_REVERT_TO_CODE;
       code_string="ExportData(TrialOutputData, output_file)";
       prog_args {
	name="prog_args";
	el_typ=ProgArg;
	el_def=0;
	ProgArg @[0] {
	 arg_type=DataTable;
	 type="DataTable*";
	 name="FinalData";
	 required=1;
	 def_val=;
	 prev_expr="TrialOutputData";
	 expr {
	  expr="TrialOutputData";
	 };
	};
	ProgArg @[1] {
	 arg_type=taString;
	 type="String";
	 name="output_file";
	 required=1;
	 def_val=;
	 prev_expr=;
	 expr {
	  expr="output_file";
	 };
	};
       };
       target=.programs.gp[0][8]$$;
       targ_ld_init="*ExportData*";
      };
     };
    };
    Else @[29] {
     name="Else_If_ifmodequestion";
     desc=;
     flags=CAN_REVERT_TO_CODE;
     code_string="else";
     cond {
      expr=;
     };
     true_code {
      name="true_code";
      el_typ=ProgCode;
      el_def=0;
      PrintExpr @[0] {
       name="PrintExpr_Printinmodetrainmode";
       desc=;
       flags=CAN_REVERT_TO_CODE;
       code_string="Print \"in mode train: \" << mode";
       expr {
	expr="\"in mode train: \" << mode";
       };
       debug=0;
      };
      PrintExpr @[1] {
       name="PrintExpr_Printoutputfilesentoutputfile";
       desc=;
       flags=CAN_REVERT_TO_CODE;
       code_string="Print \"output_file sent: \" << output_file";
       expr {
	expr="\"output_file sent: \" << output_file";
       };
       debug=0;
      };
      PrintExpr @[2] {
       name="PrintExpr_Printinputfilesentinputfile";
       desc=;
       flags=CAN_REVERT_TO_CODE;
       code_string="Print \"input_file sent: \" << input_file";
       expr {
	expr="\"input_file sent: \" << input_file";
       };
       debug=0;
      };
      PrintExpr @[3] {
       name="PrintExpr_Printweightsfile_nputweightsfile";
       desc=;
       flags=CAN_REVERT_TO_CODE;
       code_string="Print \"weights_file sent: \" << input_weights_file";
       expr {
	expr="\"weights_file sent: \" << input_weights_file";
       };
       debug=0;
      };
      ProgramCall @[4] {
       name="ProgramCall_ImportDatainputdatainputfile";
       desc=;
       flags=CAN_REVERT_TO_CODE;
       code_string="ImportData(input_data, input_file)";
       prog_args {
	name="prog_args";
	el_typ=ProgArg;
	el_def=0;
	ProgArg @[0] {
	 arg_type=DataTable;
	 type="DataTable*";
	 name="NewData";
	 required=1;
	 def_val=;
	 prev_expr=;
	 expr {
	  expr="input_data";
	 };
	};
	ProgArg @[1] {
	 arg_type=taString;
	 type="String";
	 name="inputFile";
	 required=1;
	 def_val=;
	 prev_expr=;
	 expr {
	  expr="input_file";
	 };
	};
       };
       target=$.programs.gp[0][9]$;
       targ_ld_init="*ImportData*";
      };
      MiscCall @[5] {
       name="MiscCall_taMiscFullArgStr_ToFilelogfilenm";
       desc=;
       flags=CAN_REVERT_TO_CODE;
       code_string="taMisc::FullArgStringToFile(log_file_nm)";
       result_var=NULL;
       object_type=taMisc;
       method=taMisc::FullArgStringToFile;
       meth_args {
	name="meth_args";
	el_typ=ProgArg;
	el_def=0;
	ProgArg @[0] {
	 arg_type=const_taString_ref;
	 type="taString&";
	 name="fname";
	 required=1;
	 def_val="\"\"";
	 prev_expr=;
	 expr {
	  expr="log_file_nm";
	 };
	};
       };
      };
     };
    };
    Comment @[30] {
     name="Comment_Addyourownvariableshere";
     desc="= Add your own variables here =";
     flags=CAN_REVERT_TO_CODE;
     code_string="// = Add your own variables here =";
    };
    Comment @[31] {
     name="Comment_Belowsaveslogfil_ndarddatatables";
     desc="= Below saves log files of standard data tables =";
     flags=CAN_REVERT_TO_CODE;
     code_string="// = Below saves log files of standard data tables =";
    };
    MethodCall @[32] {
     name="MethodCall_EpochOutputDataS_filenmfalsetrue";
     desc="last arg is to restrict log to dmem_proc = 0";
     flags=CAN_REVERT_TO_CODE;
     code_string="EpochOutputData->SaveDataLog(log_file_nm, false, true)";
     result_var=NULL;
     obj=.programs[0].vars[12]$$;
     method=DataTable::SaveDataLog;
     meth_args {
      name="meth_args";
      el_typ=ProgArg;
      el_def=0;
      ProgArg @[0] {
       arg_type=const_taString_ref;
       type="taString&";
       name="fname";
       required=0;
       def_val="\"\"";
       prev_expr=;
       expr {
	expr="log_file_nm";
       };
      };
      ProgArg @[1] {
       arg_type=bool;
       type="bool";
       name="append";
       required=0;
       def_val="false";
       prev_expr=;
       expr {
	expr="false";
       };
      };
      ProgArg @[2] {
       arg_type=bool;
       type="bool";
       name="dmem_proc_0";
       required=0;
       def_val="true";
       prev_expr=;
       expr {
	expr="true";
       };
      };
     };
     meth_sig="void SaveDataLog(taString& fname, bool append = false, bool dmem_proc_0 = true)";
     meth_desc=" incrementally save each new row of data that is written to the datatable (at WriteClose()) to given file. writes the header first if not appending to existing file. if running under demem, dmem_proc_0 determines if only the first processor writes to the log file, or if all processors write";
    };
    PrintVar @[33] {
     name="PrintVar_PrintSavingepoch_datatologfilenm";
     desc=;
     flags=CAN_REVERT_TO_CODE;
     code_string="Print  \"Saving epoch log data to:\" log_file_nm";
     message="Saving epoch log data to:";
     print_var=$.programs[0].vars[10]$;
     print_var2=NULL;
     print_var3=NULL;
     print_var4=NULL;
     print_var5=NULL;
     print_var6=NULL;
     debug=0;
    };
    Comment @[34] {
     name="Comment_SavetriallogOFFbydefault";
     desc="== Save trial log -- OFF by default ==";
     flags=CAN_REVERT_TO_CODE;
     code_string="// == Save trial log -- OFF by default ==";
    };
    MethodCall @[35] {
     name="MethodCall_TrialOutputDataS_ilenmfalsefalse";
     desc="last arg is to restrict log to dmem_proc = 0";
     flags=OFF;
     code_string=;
     result_var=NULL;
     obj=.programs[0].vars[13]$$;
     method=DataTable::SaveDataLog;
     meth_args {
      name="meth_args";
      el_typ=ProgArg;
      el_def=0;
      ProgArg @[0] {
       arg_type=const_taString_ref;
       type="taString&";
       name="fname";
       required=0;
       def_val="\"\"";
       prev_expr=;
       expr {
	expr="log_file_nm";
       };
      };
      ProgArg @[1] {
       arg_type=bool;
       type="bool";
       name="append";
       required=0;
       def_val="false";
       prev_expr=;
       expr {
	expr="false";
       };
      };
      ProgArg @[2] {
       arg_type=bool;
       type="bool";
       name="dmem_proc_0";
       required=0;
       def_val="true";
       prev_expr=;
       expr {
	expr="false";
       };
      };
     };
     meth_sig="void SaveDataLog(taString& fname, bool append = false, bool dmem_proc_0 = true)";
     meth_desc=" incrementally save each new row of data that is written to the datatable (at WriteClose()) to given file. writes the header first if not appending to existing file. if running under demem, dmem_proc_0 determines if only the first processor writes to the log file, or if all processors write";
    };
    PrintVar @[36] {
     name="PrintVar_PrintSavedtriall_datatologfilenm";
     desc=;
     flags=OFF;
     code_string=;
     message="Saved trial log data to:";
     print_var=$.programs[0].vars[10]$;
     print_var2=NULL;
     print_var3=NULL;
     print_var4=NULL;
     print_var5=NULL;
     print_var6=NULL;
     debug=0;
    };
    OtherProgramVar @[37] {
     name="OtherProgramVar_VarsToprogramSav_ilevar2var3var4";
     desc="propagate the tag";
     flags=CAN_REVERT_TO_CODE;
     code_string="Vars To:  program=SaveWeights set=to  var_1=output_weights_file  var_2=?  var_3=?  var_4=? ";
     other_prog=.programs.gp[0][7]$$;
     set_other=1;
     var_1=.programs[0].vars[9]$$;
     var_2=NULL;
     var_3=NULL;
     var_4=NULL;
    };
    PrintExpr @[38] {
     name="PrintExpr_PrintRunningbatchname";
     desc=;
     flags=CAN_REVERT_TO_CODE;
     code_string="Print \"Running: \" << batch.name";
     expr {
      expr="\"Running: \" << batch.name";
     };
     debug=0;
    };
    ProgramCall @[39] {
     name="ProgramCall_BpBatchnetworkinputdata3";
     desc=;
     flags=VERBOSE|CAN_REVERT_TO_CODE;
     code_string="BpBatch(network, input_data, 3)";
     prog_args {
      name="prog_args";
      el_typ=ProgArg;
      el_def=0;
      ProgArg @[0] {
       arg_type=BpNetwork;
       type="BpNetwork*";
       name="network";
       required=1;
       def_val=;
       prev_expr=;
       expr {
	expr="network";
       };
      };
      ProgArg @[1] {
       arg_type=DataTable;
       type="DataTable*";
       name="input_data";
       required=1;
       def_val=;
       prev_expr=;
       expr {
	expr="input_data";
       };
      };
      ProgArg @[2] {
       arg_type=int;
       type="int";
       name="max_batch";
       required=1;
       def_val=;
       prev_expr=;
       expr {
	expr="3";
       };
      };
     };
     target=$.programs.gp[0][0]$;
     targ_ld_init="*BpBatch*";
    };
    PrintVar @[40] {
     name="PrintVar_PrintSavingtrial_datatologfilenm";
     desc=;
     flags=OFF;
     code_string=;
     message="Saving trial log data to:";
     print_var=$.programs[0].vars[10]$;
     print_var2=NULL;
     print_var3=NULL;
     print_var4=NULL;
     print_var5=NULL;
     print_var6=NULL;
     debug=0;
    };
    PrintExpr @[41] {
     name="PrintExpr_PrintbeforeSaveWeights";
     desc=;
     flags=CAN_REVERT_TO_CODE;
     code_string="Print \"before SaveWeights\"";
     expr {
      expr="\"before SaveWeights\"";
     };
     debug=0;
    };
    ProgramCall @[42] {
     name="ProgramCall_SaveWeightsnetwork";
     desc=;
     flags=CAN_REVERT_TO_CODE;
     code_string="SaveWeights(network)";
     prog_args {
      name="prog_args";
      el_typ=ProgArg;
      el_def=0;
      ProgArg @[0] {
       arg_type=Network;
       type="BpNetwork*";
       name="network";
       required=1;
       def_val=;
       prev_expr="output_weights_file";
       expr {
	expr="network";
       };
      };
     };
     target=$.programs.gp[0][7]$;
     targ_ld_init="*SaveWeights*";
    };
    PrintExpr @[43] {
     name="PrintExpr_PrintafterSaveWeights";
     desc=;
     flags=CAN_REVERT_TO_CODE;
     code_string="Print \"after SaveWeights\"";
     expr {
      expr="\"after SaveWeights\"";
     };
     debug=0;
    };
    PrintExpr @[44] {
     name="PrintExpr_Printoutputfilet_tDataoutputfile";
     desc=;
     flags=CAN_REVERT_TO_CODE;
     code_string="Print \"output_file to sent to ExportData: \" << output_file";
     expr {
      expr="\"output_file to sent to ExportData: \" << output_file";
     };
     debug=0;
    };
    ProgramCall @[45] {
     name="ProgramCall_ExportDataTrialO_tDataoutputfile";
     desc=;
     flags=CAN_REVERT_TO_CODE;
     code_string="ExportData(TrialOutputData, output_file)";
     prog_args {
      name="prog_args";
      el_typ=ProgArg;
      el_def=0;
      ProgArg @[0] {
       arg_type=DataTable;
       type="DataTable*";
       name="FinalData";
       required=1;
       def_val=;
       prev_expr="TrialOutputData";
       expr {
	expr="TrialOutputData";
       };
      };
      ProgArg @[1] {
       arg_type=taString;
       type="String";
       name="output_file";
       required=1;
       def_val=;
       prev_expr=;
       expr {
	expr="output_file";
       };
      };
     };
     target=$.programs.gp[0][8]$;
     targ_ld_init="*ExportData*";
    };
   };
   step_prog=.programs.gp[0][3]$$;
   step_n=1;
   doc {
    name="doc";
    desc=;
    web_doc=0;
    wiki=;
    url="local";
    full_url="local";
    text_size=1;
    text=;
    html_text=;
   };
  };
  Program_Group @.gp[0] {
   name="BpAll_Std";
   el_typ=Program;
   el_def=0;
   tags="Bp, Std, All";
   desc="The full set of programs for training a standard Backpropagation network";
   debug_mode=0;
   Program @[0] {
    UserDataItem_List @*(.user_data_) {
     name=;
     el_typ=UserData_DocLink;
     el_def=0;
     UserData_DocLink @[0] {name="DocLink": doc=.programs.gp[0][0].doc$$: };
    };
    name="BpBatch";
    short_nm="Batch";
    tags="Bp, Std";
    desc="Iterate over training runs (a batch of training runs) -- just a simple loop that calls training program";
    version {
     major=0;
     minor=0;
     step=0;
    };
    author=;
    email=;
    flags=0;
    stop_step_cond {
     expr=;
    };
    objs {
     name="objs";
     el_typ=taNBase;
     el_def=0;
    };
    objs_vars {
     name="objs_vars";
     el_typ=ProgVar;
     el_def=0;
    };
    types {
     name="types";
     el_typ=DynEnumType;
     el_def=0;
    };
    args {
     name="args";
     el_typ=ProgVar;
     el_def=0;
     ProgVar @[0] {
      name="network";
      var_type=T_Object;
      object_type=BpNetwork;
      object_val=$.networks[0]$;
      object_scope=NULL;
      objs_ptr=0;
      flags=CTRL_PANEL|NULL_CHECK|SAVE_VAL|USED|EDIT_VAL|PGRM_ARG;
      reference=0;
      desc="network to operate on -- updates batch counter on network and passes it to train program";
      init_from=NULL;
     };
     ProgVar @[1] {
      name="input_data";
      var_type=T_Object;
      object_type=DataTable;
      object_val=$.data.gp[0][1]$;
      object_scope=NULL;
      objs_ptr=0;
      flags=CTRL_PANEL|NULL_CHECK|SAVE_VAL|USED|EDIT_VAL|PGRM_ARG;
      reference=0;
      desc="datatable with training patterns -- not used by this program, but passed to train program";
      init_from=NULL;
     };
     ProgVar @[2] {
      name="max_batch";
      var_type=T_Int;
      int_val=1;
      object_scope=NULL;
      flags=CTRL_PANEL|NULL_CHECK|SAVE_VAL|USED|EDIT_VAL|PGRM_ARG;
      reference=0;
      desc="maximum number of batch runs to perform";
      init_from=NULL;
     };
    };
    vars {
     name="vars";
     el_typ=ProgVar;
     el_def=0;
     ProgVar @[0] {
      name="batch";
      var_type=T_Int;
      int_val=0;
      object_scope=NULL;
      flags=CTRL_PANEL|CTRL_READ_ONLY|NULL_CHECK|SAVE_VAL|USED|EDIT_VAL;
      reference=0;
      desc="batch counter";
      init_from=NULL;
     };
    };
    functions {
     name="functions";
     el_typ=Function;
     el_def=0;
    };
    init_code {
     name="init_code";
     el_typ=ProgCode;
     el_def=0;
     NetCounterInit @[0] {
      name="NetCounterInit_NetCounterInitbatch";
      desc="initializes local batch counter and batch field on network";
      flags=CAN_REVERT_TO_CODE;
      code_string="Net Counter Init: batch";
      network_var=.programs.gp[0][0].args[0]$$;
      local_ctr_var=.programs.gp[0][0].vars[0]$$;
      counter=Network::batch;
      update_after=0;
     };
    };
    prog_code {
     name="prog_code";
     el_typ=ProgCode;
     el_def=0;
     NetCounterInit @[0] {
      name="NetCounterInit_NetCounterInitbatch";
      desc="initializes local batch counter and batch field on network";
      flags=CAN_REVERT_TO_CODE;
      code_string="Net Counter Init: batch";
      network_var=$.programs.gp[0][0].args[0]$;
      local_ctr_var=$.programs.gp[0][0].vars[0]$;
      counter=Network::batch;
      update_after=0;
     };
     WhileLoop @[1] {
      name="WhileLoop_whilebatchmaxbatch";
      desc="the main loop over training runs";
      flags=CAN_REVERT_TO_CODE;
      code_string="while (batch < max_batch)";
      loop_code {
       name="loop_code";
       el_typ=ProgCode;
       el_def=0;
       ProgramCall @[0] {
	name="ProgramCall_BpTrainnetworkinputdatatrue";
	desc="run the training program -- sets the network and input_data args";
	flags=CAN_REVERT_TO_CODE;
	code_string="BpTrain(network, input_data, true)";
	prog_args {
	 name="prog_args";
	 el_typ=ProgArg;
	 el_def=0;
	 ProgArg @[0] {
	  arg_type=BpNetwork;
	  type="BpNetwork*";
	  name="network";
	  required=1;
	  def_val=;
	  prev_expr="network";
	  expr {
	   expr="network";
	  };
	 };
	 ProgArg @[1] {
	  arg_type=DataTable;
	  type="DataTable*";
	  name="input_data";
	  required=1;
	  def_val=;
	  prev_expr="input_data";
	  expr {
	   expr="input_data";
	  };
	 };
	 ProgArg @[2] {
	  arg_type=bool;
	  type="bool";
	  name="no_prompts";
	  required=1;
	  def_val=;
	  prev_expr="true";
	  expr {
	   expr="true";
	  };
	 };
	};
	target=$.programs.gp[0][1]$;
	targ_ld_init="*BpTrain*";
       };
       NetCounterIncr @[1] {
	name="NetCounterIncr_NetCounterIncrbatch";
	desc="increment the local batch counter and copy to network";
	flags=CAN_REVERT_TO_CODE;
	code_string="Net Counter Incr: batch";
	network_var=$.programs.gp[0][0].args[0]$;
	local_ctr_var=$.programs.gp[0][0].vars[0]$;
	counter=Network::batch;
	update_after=0;
       };
      };
      test {
       expr="batch < max_batch";
      };
     };
    };
    step_prog=$.programs.gp[0][3]$;
    step_n=1;
    doc {
     name="doc";
     desc=;
     web_doc=0;
     wiki=;
     url="local";
     full_url="local";
     text_size=1;
     text=;
     html_text=;
    };
   };
   Program @[1] {
    UserDataItem_List @*(.user_data_) {
     name=;
     el_typ=UserData_DocLink;
     el_def=0;
     UserData_DocLink @[0] {name="DocLink": doc=.programs.gp[0][1].doc$$: };
    };
    name="BpTrain";
    short_nm="Train";
    tags="Bp, Train, RndSeedList";
    desc="A complete training run of a Backpropagation network: iterating over epochs until the network has learned the task.  Also has a list of random seeds that are tied to the network batch counter, providing consistent runs regardless of what happens in the training of each network, or where it is run (e.g., on different processors)";
    version {
     major=8;
     minor=0;
     step=0;
    };
    author="Randall C. O'Reilly";
    email="emergent-users@grey.colorado.edu";
    flags=OBJS_UPDT_GUI;
    stop_step_cond {
     expr=;
    };
    objs {
     name="objs";
     el_typ=RndSeed;
     el_def=0;
     RndSeed_List @[0] {
      name="rnd_seeds";
      seeds {
       name="seeds";
       el_typ=RndSeed;
       el_def=0;
       RndSeed @[0] {
	name="RndSeed_1";
	rnd_seed=2883105751;
       };
       RndSeed @[1] {
	name="RndSeed_2";
	rnd_seed=2883105752;
       };
       RndSeed @[2] {
	name="RndSeed_3";
	rnd_seed=2883105753;
       };
       RndSeed @[3] {
	name="RndSeed_4";
	rnd_seed=2883105754;
       };
       RndSeed @[4] {
	name="RndSeed_5";
	rnd_seed=2883105755;
       };
       RndSeed @[5] {
	name="RndSeed_6";
	rnd_seed=2883105756;
       };
       RndSeed @[6] {
	name="RndSeed_7";
	rnd_seed=2883105757;
       };
       RndSeed @[7] {
	name="RndSeed_8";
	rnd_seed=2883105758;
       };
       RndSeed @[8] {
	name="RndSeed_9";
	rnd_seed=2883105759;
       };
       RndSeed @[9] {
	name="RndSeed_10";
	rnd_seed=2883105760;
       };
       RndSeed @[10] {
	name="RndSeed_11";
	rnd_seed=2883105761;
       };
       RndSeed @[11] {
	name="RndSeed_12";
	rnd_seed=2883105762;
       };
       RndSeed @[12] {
	name="RndSeed_13";
	rnd_seed=2883105763;
       };
       RndSeed @[13] {
	name="RndSeed_14";
	rnd_seed=2883105764;
       };
       RndSeed @[14] {
	name="RndSeed_15";
	rnd_seed=2883105765;
       };
       RndSeed @[15] {
	name="RndSeed_16";
	rnd_seed=2883105766;
       };
       RndSeed @[16] {
	name="RndSeed_17";
	rnd_seed=2883105767;
       };
       RndSeed @[17] {
	name="RndSeed_18";
	rnd_seed=2883105768;
       };
       RndSeed @[18] {
	name="RndSeed_19";
	rnd_seed=2883105769;
       };
       RndSeed @[19] {
	name="RndSeed_20";
	rnd_seed=2883105770;
       };
       RndSeed @[20] {
	name="RndSeed_21";
	rnd_seed=2883105771;
       };
       RndSeed @[21] {
	name="RndSeed_22";
	rnd_seed=2883105772;
       };
       RndSeed @[22] {
	name="RndSeed_23";
	rnd_seed=2883105773;
       };
       RndSeed @[23] {
	name="RndSeed_24";
	rnd_seed=2883105774;
       };
       RndSeed @[24] {
	name="RndSeed_25";
	rnd_seed=2883105775;
       };
      };
     };
     RndSeed @[1] {
      name="rnd_seed";
      rnd_seed=2947437512;
     };
    };
    objs_vars {
     name="objs_vars";
     el_typ=ProgVar;
     el_def=0;
     ProgVar @[0] {
      name="rnd_seeds";
      var_type=T_Object;
      object_type=RndSeed_List;
      object_val=.programs.gp[0][1].objs[0]$$;
      object_scope=NULL;
      objs_ptr=1;
      flags=NULL_CHECK|SAVE_VAL|USED|EDIT_VAL;
      reference=0;
      desc=;
      init_from=NULL;
     };
     ProgVar @[1] {
      name="rnd_seed";
      var_type=T_Object;
      object_type=RndSeed;
      object_val=.programs.gp[0][1].objs[1]$$;
      object_scope=NULL;
      objs_ptr=1;
      flags=NULL_CHECK|SAVE_VAL|USED|EDIT_VAL;
      reference=0;
      desc=;
      init_from=NULL;
     };
    };
    types {
     name="types";
     el_typ=DynEnumType;
     el_def=0;
     DynEnumType @[0] {
      name="RndInitType";
      desc=;
      enums {
       name="enums";
       el_typ=DynEnumItem;
       el_def=0;
       DynEnumItem @[0] {
	name="OLD_SEED";
	value=0;
	desc="use stored random seed value (recreates same sequence every time)";
       };
       DynEnumItem @[1] {
	name="NEW_SEED";
	value=1;
	desc="generate new random seed (new sequence of random numbers)";
       };
       DynEnumItem @[2] {
	name="BATCH_SEEDS";
	value=2;
	desc="use a fixed list of random seeds with the current batch number selecting the seed to use -- provides a consistent set of initial conditions for each batch regardless..";
       };
      };
      bits=0;
     };
    };
    args {
     name="args";
     el_typ=ProgVar;
     el_def=0;
     ProgVar @[0] {
      name="network";
      var_type=T_Object;
      object_type=BpNetwork;
      object_val=$.networks[0]$;
      object_scope=NULL;
      objs_ptr=0;
      flags=CTRL_PANEL|NULL_CHECK|SAVE_VAL|USED|EDIT_VAL|PGRM_ARG;
      reference=0;
      desc=;
      init_from=NULL;
     };
     ProgVar @[1] {
      name="input_data";
      var_type=T_Object;
      object_type=DataTable;
      object_val=$.data.gp[0][1]$;
      object_scope=NULL;
      objs_ptr=0;
      flags=CTRL_PANEL|NULL_CHECK|SAVE_VAL|USED|EDIT_VAL|PGRM_ARG;
      reference=0;
      desc=;
      init_from=NULL;
     };
     ProgVar @[2] {
      name="no_prompts";
      var_type=T_Bool;
      bool_val=0;
      object_scope=NULL;
      flags=NULL_CHECK|SAVE_VAL|USED|EDIT_VAL|PGRM_ARG;
      reference=0;
      desc="If train is called by other programs (e.g., Batch), they should set this to true -- otherwise it is reset to false in Init";
      init_from=NULL;
     };
    };
    vars {
     name="vars";
     el_typ=ProgVar;
     el_def=0;
     ProgVar @[0] {
      name="max_epoch";
      var_type=T_Int;
      int_val=50;
      object_scope=NULL;
      flags=CTRL_PANEL|NULL_CHECK|SAVE_VAL|USED|EDIT_VAL;
      reference=0;
      desc=;
      init_from=NULL;
     };
     ProgVar @[1] {
      name="epoch";
      var_type=T_Int;
      int_val=0;
      object_scope=NULL;
      flags=CTRL_PANEL|CTRL_READ_ONLY|NULL_CHECK|SAVE_VAL|USED|EDIT_VAL;
      reference=0;
      desc=;
      init_from=NULL;
     };
     ProgVar @[2] {
      name="train_mode";
      var_type=T_HardEnum;
      int_val=1;
      object_scope=NULL;
      hard_enum_type=Network::TrainMode;
      flags=CTRL_PANEL|NULL_CHECK|SAVE_VAL|USED|EDIT_VAL;
      reference=0;
      desc=;
      init_from=NULL;
     };
     ProgVar @[3] {
      name="rnd_init";
      var_type=T_DynEnum;
      object_scope=NULL;
      dyn_enum_val {
       user_data_=NULL;
       enum_type=.programs.gp[0][1].types[0]$$;
       value=2;
      };
      flags=CTRL_PANEL|NULL_CHECK|SAVE_VAL|USED|EDIT_VAL;
      reference=0;
      desc="how to initialize the random numbers when the Init button is pressed";
      init_from=NULL;
     };
     ProgVar @[4] {
      name="err_stopcrit";
      var_type=T_Real;
      real_val=0;
      object_scope=NULL;
      flags=CTRL_PANEL|NULL_CHECK|SAVE_VAL|USED|EDIT_VAL;
      reference=0;
      desc="stopping criterion -- network avg_sse must be <= this number to stop training -- see n_under_thr too";
      init_from=NULL;
     };
     ProgVar @[5] {
      name="n_under_thr";
      var_type=T_Int;
      int_val=1;
      object_scope=NULL;
      flags=CTRL_PANEL|NULL_CHECK|SAVE_VAL|USED|EDIT_VAL;
      reference=0;
      desc="number of times network needs to be under stopcrit threshold to actually stop";
      init_from=NULL;
     };
     ProgVar @[6] {
      name="save_final_wts";
      var_type=T_Bool;
      bool_val=0;
      object_scope=NULL;
      flags=CTRL_PANEL|NULL_CHECK|SAVE_VAL|USED|EDIT_VAL;
      reference=0;
      desc="save the network's weights at the end of training?  ";
      init_from=NULL;
     };
     ProgVar @[7] {
      name="save_wts_interval";
      var_type=T_Int;
      int_val=-1;
      object_scope=NULL;
      flags=CTRL_PANEL|NULL_CHECK|SAVE_VAL|USED|EDIT_VAL;
      reference=0;
      desc="save the weights every this many epochs, if number is >= 1 (otherwise do not save weights)";
      init_from=NULL;
     };
     ProgVar @[8] {
      name="n_under_cnt";
      var_type=T_Int;
      int_val=0;
      object_scope=NULL;
      flags=NULL_CHECK|SAVE_VAL|USED|EDIT_VAL;
      reference=0;
      desc="current under threshold counter";
      init_from=NULL;
     };
     ProgVar @[9] {
      name="train_timer";
      var_type=T_Object;
      object_type=TimeUsed;
      object_val=.networks[0].train_time$$;
      object_scope=NULL;
      objs_ptr=0;
      flags=NULL_CHECK|SAVE_VAL|USED|EDIT_VAL;
      reference=0;
      desc=;
      init_from=NULL;
     };
    };
    functions {
     name="functions";
     el_typ=Function;
     el_def=0;
     Function @[0] {
      name="GetRandomSeed";
      desc=;
      flags=CAN_REVERT_TO_CODE;
      code_string="GetRandomSeed() returns: int";
      return_type=T_Int;
      object_type=taOBase;
      args {
       name="args";
       el_typ=ProgVar;
       el_def=0;
      };
      fun_code {
       name="fun_code";
       el_typ=ProgCode;
       el_def=0;
       LocalVars @[0] {
	name="LocalVars_LocalVars0vars";
	desc=;
	flags=CAN_REVERT_TO_CODE;
	code_string="LocalVars (0 vars)";
	local_vars {
	 name="local_vars";
	 el_typ=ProgVar;
	 el_def=0;
	};
       };
       Switch @[1] {
	name="Switch_switchrndinit";
	desc=;
	flags=CAN_REVERT_TO_CODE;
	code_string="switch(rnd_init)";
	switch_var=.programs.gp[0][1].vars[3]$$;
	cases {
	 name="cases";
	 el_typ=CaseBlock;
	 el_def=0;
	 CaseBlock @[0] {
	  name="CaseBlock_caseOLDSEED";
	  desc=;
	  flags=CAN_REVERT_TO_CODE;
	  code_string="case: OLD_SEED";
	  prog_code {
	   name="prog_code";
	   el_typ=ProgCode;
	   el_def=0;
	   MethodCall @[0] {
	    name="MethodCall_rndseedOldSeed";
	    desc="restore previous random seed (all runs produce same results) -- click on rnd_seed object to generate a new seed to use for this if you want";
	    flags=CAN_REVERT_TO_CODE;
	    code_string="rnd_seed->OldSeed()";
	    result_var=NULL;
	    obj=.programs.gp[0][1].objs_vars[1]$$;
	    method=RndSeed::OldSeed;
	    meth_args {
	     name="meth_args";
	     el_typ=ProgArg;
	     el_def=0;
	    };
	    meth_sig="void OldSeed()";
	    meth_desc=" restore current seed to random num generator";
	   };
	  };
	  case_val {
	   expr="OLD_SEED";
	  };
	  is_default=0;
	 };
	 CaseBlock @[1] {
	  name="CaseBlock_caseNEWSEED";
	  desc=;
	  flags=CAN_REVERT_TO_CODE;
	  code_string="case: NEW_SEED";
	  prog_code {
	   name="prog_code";
	   el_typ=ProgCode;
	   el_def=0;
	   MethodCall @[0] {
	    name="MethodCall_rndseedNewSeed";
	    desc="new random numbers each time";
	    flags=CAN_REVERT_TO_CODE;
	    code_string="rnd_seed->NewSeed()";
	    result_var=NULL;
	    obj=$.programs.gp[0][1].objs_vars[1]$;
	    method=RndSeed::NewSeed;
	    meth_args {
	     name="meth_args";
	     el_typ=ProgArg;
	     el_def=0;
	    };
	    meth_sig="void NewSeed()";
	    meth_desc=" set the seed to a new random value (based on time and process id)";
	   };
	  };
	  case_val {
	   expr="NEW_SEED";
	  };
	  is_default=0;
	 };
	 CaseBlock @[2] {
	  name="CaseBlock_caseBATCHSEEDS";
	  desc=;
	  flags=CAN_REVERT_TO_CODE;
	  code_string="case: BATCH_SEEDS";
	  prog_code {
	   name="prog_code";
	   el_typ=ProgCode;
	   el_def=0;
	   MethodCall @[0] {
	    name="MethodCall_rndseedsUseSeedn_dseedsseedssize";
	    desc="restore previous random seed (all runs produce same results); change to NewSeed to have new random numbers each time";
	    flags=CAN_REVERT_TO_CODE;
	    code_string="rnd_seeds->UseSeed(network.batch % rnd_seeds.seeds.size)";
	    result_var=NULL;
	    obj=.programs.gp[0][1].objs_vars[0]$$;
	    method=RndSeed_List::UseSeed;
	    meth_args {
	     name="meth_args";
	     el_typ=ProgArg;
	     el_def=0;
	     ProgArg @[0] {
	      arg_type=int;
	      type="int";
	      name="idx";
	      required=1;
	      def_val=;
	      prev_expr=;
	      expr {
	       expr="network.batch % rnd_seeds.seeds.size";
	      };
	     };
	    };
	    meth_sig="void UseSeed(int idx)";
	    meth_desc=" use seed at given index in the list (does OldSeed on it); wraps around (modulus) if idx is > list size (issues warning)";
	   };
	  };
	  case_val {
	   expr="BATCH_SEEDS";
	  };
	  is_default=0;
	 };
	};
       };
      };
     };
    };
    init_code {
     name="init_code";
     el_typ=ProgCode;
     el_def=0;
     AssignExpr @[0] {
      name="AssignExpr_nopromptsfalse";
      desc=;
      flags=CAN_REVERT_TO_CODE;
      code_string="no_prompts = false";
      result_var=.programs.gp[0][1].args[2]$$;
      expr {
       expr="false";
      };
     };
     MethodCall @[1] {
      name="MethodCall_networkCheckConfigfalse";
      desc=;
      flags=CAN_REVERT_TO_CODE;
      code_string="network->CheckConfig(false)";
      result_var=NULL;
      obj=.programs.gp[0][1].args[0]$$;
      method=taBase::CheckConfig;
      meth_args {
       name="meth_args";
       el_typ=ProgArg;
       el_def=0;
       ProgArg @[0] {
	arg_type=bool;
	type="bool";
	name="quiet";
	required=0;
	def_val="false";
	prev_expr=;
	expr {
	 expr="false";
	};
       };
      };
      meth_sig="bool CheckConfig(bool quiet = false)";
      meth_desc=" check the configuration of this object and all its children (defaults to no confirm of success)";
     };
     AssignExpr @[2] {
      name="AssignExpr_traintimernetworktraintime";
      desc=;
      flags=CAN_REVERT_TO_CODE;
      code_string="train_timer = network.train_time";
      result_var=.programs.gp[0][1].vars[9]$$;
      expr {
       expr="network.train_time";
      };
     };
     AssignExpr @[3] {
      name="AssignExpr_nundercnt0";
      desc=;
      flags=CAN_REVERT_TO_CODE;
      code_string="n_under_cnt = 0";
      result_var=.programs.gp[0][1].vars[8]$$;
      expr {
       expr="0";
      };
     };
     FunctionCall @[4] {
      name="FunctionCall_GetRandomSeed";
      desc="initialize random seed";
      flags=CAN_REVERT_TO_CODE;
      code_string="GetRandomSeed()";
      result_var=NULL;
      fun=.programs.gp[0][1].functions[0]$$;
      fun_args {
       name="fun_args";
       el_typ=ProgArg;
       el_def=0;
      };
     };
     WtInitPrompt @[5] {
      name="WtInitPrompt_ifguiDoyouwantto_eNetworkWeights";
      desc="don't initialize weights without checking";
      flags=CAN_REVERT_TO_CODE;
      code_string="if (gui && \"Do you want to Initialize Network Weights\")";
      prompt="Do you want to Initialize Network Weights";
      yes_label="Yes";
      no_label="No";
      yes_code {
       name="yes_code";
       el_typ=ProgCode;
       el_def=0;
       MethodCall @[0] {
	name="MethodCall_networkInitWeights";
	desc="initialize network weights: could also load pre-set weights or something else here";
	flags=CAN_REVERT_TO_CODE;
	code_string="network->Init_Weights()";
	result_var=NULL;
	obj=$.programs.gp[0][1].args[0]$;
	method=Network::Init_Weights;
	meth_args {
	 name="meth_args";
	 el_typ=ProgArg;
	 el_def=0;
	};
	meth_sig="void Init_Weights()";
	meth_desc=" Initialize the weights -- also inits acts, counters and stats -- does unit level threaded and then does Layers after";
       };
       PrintExpr @[1] {
	name="PrintExpr_Printnetworkname_ghtsInitialized";
	desc=;
	flags=CAN_REVERT_TO_CODE;
	code_string="Print network.name << \" Weights Initialized\"";
	expr {
	 expr="network.name << \" Weights Initialized\"";
	};
	debug=0;
       };
      };
     };
     AssignExpr @[6] {
      name="AssignExpr_epochnetworkepoch";
      desc="grab the official network epoch counter: will be initialized if needed by now";
      flags=CAN_REVERT_TO_CODE;
      code_string="epoch = network.epoch";
      result_var=.programs.gp[0][1].vars[1]$$;
      expr {
       expr="network.epoch";
      };
     };
    };
    prog_code {
     name="prog_code";
     el_typ=ProgCode;
     el_def=0;
     AssignExpr @[0] {
      name="AssignExpr_traintimernetworktraintime";
      desc=;
      flags=CAN_REVERT_TO_CODE;
      code_string="train_timer = network.train_time";
      result_var=$.programs.gp[0][1].vars[9]$;
      expr {
       expr="network.train_time";
      };
     };
     MethodCall @[1] {
      name="MethodCall_traintimerStartTimertrue";
      desc=;
      flags=CAN_REVERT_TO_CODE;
      code_string="train_timer->StartTimer(true)";
      result_var=NULL;
      obj=$.programs.gp[0][1].vars[9]$;
      method=TimeUsed::StartTimer;
      meth_args {
       name="meth_args";
       el_typ=ProgArg;
       el_def=0;
       ProgArg @[0] {
	arg_type=bool;
	type="bool";
	name="reset_used";
	required=0;
	def_val="true";
	prev_expr=;
	expr {
	 expr="true";
	};
       };
      };
      meth_sig="void StartTimer(bool reset_used = true)";
      meth_desc=" record the current time as the starting time, and optionally reset the time used information";
     };
     AssignExpr @[2] {
      name="AssignExpr_nundercnt0";
      desc=;
      flags=CAN_REVERT_TO_CODE;
      code_string="n_under_cnt = 0";
      result_var=$.programs.gp[0][1].vars[8]$;
      expr {
       expr="0";
      };
     };
     MemberAssign @[3] {
      name="MemberAssign_networktrainmodetrainmode";
      desc="set network's training mode to our local value";
      flags=CAN_REVERT_TO_CODE;
      code_string="network.train_mode = train_mode";
      obj=$.programs.gp[0][1].args[0]$;
      path="train_mode";
      expr {
       expr="train_mode";
      };
      update_after=0;
     };
     FunctionCall @[4] {
      name="FunctionCall_GetRandomSeed";
      desc="initialize random seed";
      flags=CAN_REVERT_TO_CODE;
      code_string="GetRandomSeed()";
      result_var=NULL;
      fun=$.programs.gp[0][1].functions[0]$;
      fun_args {
       name="fun_args";
       el_typ=ProgArg;
       el_def=0;
      };
     };
     If @[5] {
      name="If_ifnoprompts";
      desc=;
      flags=CAN_REVERT_TO_CODE;
      code_string="if (no_prompts)";
      cond {
       expr="no_prompts";
      };
      true_code {
       name="true_code";
       el_typ=ProgCode;
       el_def=0;
       MethodCall @[0] {
	name="MethodCall_networkInitWeights";
	desc="initialize network weights: could also load pre-set weights or something else here";
	flags=CAN_REVERT_TO_CODE;
	code_string="network->Init_Weights()";
	result_var=NULL;
	obj=$.programs.gp[0][1].args[0]$;
	method=Network::Init_Weights;
	meth_args {
	 name="meth_args";
	 el_typ=ProgArg;
	 el_def=0;
	};
	meth_sig="void Init_Weights()";
	meth_desc=" Initialize the weights -- also inits acts, counters and stats -- does unit level threaded and then does Layers after";
       };
       PrintExpr @[1] {
	name="PrintExpr_Printnetworkname_ghtsInitialized";
	desc=;
	flags=CAN_REVERT_TO_CODE;
	code_string="Print network.name << \" Weights Initialized\"";
	expr {
	 expr="network.name << \" Weights Initialized\"";
	};
	debug=0;
       };
      };
     };
     AssignExpr @[6] {
      name="AssignExpr_epochnetworkepoch";
      desc="grab the official network epoch counter: will be initialized if needed by now";
      flags=CAN_REVERT_TO_CODE;
      code_string="epoch = network.epoch";
      result_var=$.programs.gp[0][1].vars[1]$;
      expr {
       expr="network.epoch";
      };
     };
     WhileLoop @[7] {
      name="WhileLoop_whileepochmaxepoch";
      desc=;
      flags=CAN_REVERT_TO_CODE;
      code_string="while (epoch < max_epoch)";
      loop_code {
       name="loop_code";
       el_typ=ProgCode;
       el_def=0;
       ProgramCall @[0] {
	name="ProgramCall_BpEpochnetworkinputdata";
	desc=;
	flags=CAN_REVERT_TO_CODE;
	code_string="BpEpoch(network, input_data)";
	prog_args {
	 name="prog_args";
	 el_typ=ProgArg;
	 el_def=0;
	 ProgArg @[0] {
	  arg_type=BpNetwork;
	  type="BpNetwork*";
	  name="network";
	  required=1;
	  def_val=;
	  prev_expr=;
	  expr {
	   expr="network";
	  };
	 };
	 ProgArg @[1] {
	  arg_type=DataTable;
	  type="DataTable*";
	  name="input_data";
	  required=1;
	  def_val=;
	  prev_expr=;
	  expr {
	   expr="input_data";
	  };
	 };
	};
	target=.programs.gp[0][2]$$;
	targ_ld_init="*BpEpoch*";
       };
       NetCounterIncr @[1] {
	name="NetCounterIncr_NetCounterIncrepoch";
	desc="increment the epoch counter";
	flags=CAN_REVERT_TO_CODE;
	code_string="Net Counter Incr: epoch";
	network_var=$.programs.gp[0][1].args[0]$;
	local_ctr_var=$.programs.gp[0][1].vars[1]$;
	counter=Network::epoch;
	update_after=0;
       };
       If @[2] {
	name="If_ifnetworkavgsseavgerrstopcrit";
	desc=;
	flags=CAN_REVERT_TO_CODE;
	code_string="if (network.avg_sse.avg <= err_stopcrit)";
	cond {
	 expr="network.avg_sse.avg <= err_stopcrit";
	};
	true_code {
	 name="true_code";
	 el_typ=ProgCode;
	 el_def=0;
	 VarIncr @[0] {
	  name="VarIncr_nundercnt1";
	  desc=;
	  flags=CAN_REVERT_TO_CODE;
	  code_string="n_under_cnt += 1";
	  var=$.programs.gp[0][1].vars[8]$;
	  expr {
	   expr="1";
	  };
	 };
	 IfBreak @[1] {
	  name="IfBreak_ifnundercntnunderthrbreak";
	  desc="stop if errors go below stopping criterion (note: could use sse or avg_sse here too)";
	  flags=CAN_REVERT_TO_CODE;
	  code_string="if(n_under_cnt >=  n_under_thr) break";
	  cond {
	   expr="n_under_cnt >=  n_under_thr";
	  };
	 };
	};
       };
       Else @[3] {
	name="Else_If_ifnetworkavgsseavgerrstopcrit";
	desc=;
	flags=CAN_REVERT_TO_CODE;
	code_string="else";
	cond {
	 expr=;
	};
	true_code {
	 name="true_code";
	 el_typ=ProgCode;
	 el_def=0;
	 AssignExpr @[0] {
	  name="AssignExpr_nundercnt0";
	  desc=;
	  flags=CAN_REVERT_TO_CODE;
	  code_string="n_under_cnt = 0";
	  result_var=$.programs.gp[0][1].vars[8]$;
	  expr {
	   expr="0";
	  };
	 };
	};
       };
       If @[4] {
	name="If_ifsavewtsinterval1";
	desc=;
	flags=CAN_REVERT_TO_CODE;
	code_string="if (save_wts_interval >= 1)";
	cond {
	 expr="save_wts_interval >= 1";
	};
	true_code {
	 name="true_code";
	 el_typ=ProgCode;
	 el_def=0;
	 If @[0] {
	  name="If_ifepochsavewtsinterval0";
	  desc=;
	  flags=CAN_REVERT_TO_CODE;
	  code_string="if (epoch % save_wts_interval == 0)";
	  cond {
	   expr="epoch % save_wts_interval == 0";
	  };
	  true_code {
	   name="true_code";
	   el_typ=ProgCode;
	   el_def=0;
	   ProgramCall @[0] {
	    name="ProgramCall_SaveWeightsnetwork";
	    desc=;
	    flags=CAN_REVERT_TO_CODE;
	    code_string="SaveWeights(network)";
	    prog_args {
	     name="prog_args";
	     el_typ=ProgArg;
	     el_def=0;
	     ProgArg @[0] {
	      arg_type=Network;
	      type="BpNetwork*";
	      name="network";
	      required=1;
	      def_val=;
	      prev_expr=;
	      expr {
	       expr="network";
	      };
	     };
	    };
	    target=$.programs.gp[0][7]$;
	    targ_ld_init="*SaveWeights*";
	   };
	  };
	 };
	};
       };
      };
      test {
       expr="epoch < max_epoch";
      };
     };
     If @[8] {
      name="If_ifsavefinalwts";
      desc=;
      flags=CAN_REVERT_TO_CODE;
      code_string="if (save_final_wts)";
      cond {
       expr="save_final_wts";
      };
      true_code {
       name="true_code";
       el_typ=ProgCode;
       el_def=0;
       ProgramCall @[0] {
	name="ProgramCall_SaveWeightsnetwork";
	desc=;
	flags=CAN_REVERT_TO_CODE;
	code_string="SaveWeights(network)";
	prog_args {
	 name="prog_args";
	 el_typ=ProgArg;
	 el_def=0;
	 ProgArg @[0] {
	  arg_type=Network;
	  type="BpNetwork*";
	  name="network";
	  required=1;
	  def_val=;
	  prev_expr=;
	  expr {
	   expr="network";
	  };
	 };
	};
	target=$.programs.gp[0][7]$;
	targ_ld_init="*SaveWeights*";
       };
      };
     };
     MethodCall @[9] {
      name="MethodCall_traintimerEndTimer";
      desc=;
      flags=CAN_REVERT_TO_CODE;
      code_string="train_timer->EndTimer()";
      result_var=NULL;
      obj=$.programs.gp[0][1].vars[9]$;
      method=TimeUsed::EndTimer;
      meth_args {
       name="meth_args";
       el_typ=ProgArg;
       el_def=0;
      };
      meth_sig="void EndTimer()";
      meth_desc=" record the current time as the ending time, and compute difference as the time used";
     };
    };
    step_prog=NULL;
    step_n=1;
    doc {
     name="doc";
     desc=;
     web_doc=1;
     wiki="emergent";
     url="BpTrain";
     full_url="https://grey.colorado.edu/emergent/index.php/BpTrain";
     text_size=1;
     text=;
     html_text=;
    };
   };
   Program @[2] {
    UserDataItem_List @*(.user_data_) {
     name=;
     el_typ=UserData_DocLink;
     el_def=0;
     UserData_DocLink @[0] {name="DocLink": doc=.programs.gp[0][2].doc$$: };
    };
    name="BpEpoch";
    short_nm="Epoch";
    tags="Bp, Std";
    desc="iterates over all of the items in a data table and calls BpTrial process on them";
    version {
     major=0;
     minor=0;
     step=0;
    };
    author=;
    email=;
    flags=0;
    stop_step_cond {
     expr=;
    };
    objs {
     name="objs";
     el_typ=taNBase;
     el_def=0;
    };
    objs_vars {
     name="objs_vars";
     el_typ=ProgVar;
     el_def=0;
    };
    types {
     name="types";
     el_typ=DynEnumType;
     el_def=0;
    };
    args {
     name="args";
     el_typ=ProgVar;
     el_def=0;
     ProgVar @[0] {
      name="network";
      var_type=T_Object;
      object_type=BpNetwork;
      object_val=$.networks[0]$;
      object_scope=NULL;
      objs_ptr=0;
      flags=CTRL_PANEL|NULL_CHECK|SAVE_VAL|USED|EDIT_VAL|PGRM_ARG;
      reference=0;
      desc="network to operate on";
      init_from=NULL;
     };
     ProgVar @[1] {
      name="input_data";
      var_type=T_Object;
      object_type=DataTable;
      object_val=$.data.gp[0][1]$;
      object_scope=NULL;
      objs_ptr=0;
      flags=CTRL_PANEL|NULL_CHECK|SAVE_VAL|USED|EDIT_VAL|PGRM_ARG;
      reference=0;
      desc="table of patterns to present to the network, one row at a time";
      init_from=NULL;
     };
    };
    vars {
     name="vars";
     el_typ=ProgVar;
     el_def=0;
     ProgVar @[0] {
      name="data_loop_order";
      var_type=T_HardEnum;
      int_val=1;
      object_scope=NULL;
      hard_enum_type=DataLoop::Order;
      flags=CTRL_PANEL|NULL_CHECK|SAVE_VAL|USED|EDIT_VAL;
      reference=0;
      desc="controls the order in which events (rows of the input data datatable) are presented to the network
(SEQUENTIAL, PERMUTED, RANDOM)";
      init_from=NULL;
     };
     ProgVar @[1] {
      name="trial";
      var_type=T_Int;
      int_val=0;
      object_scope=NULL;
      flags=CTRL_PANEL|CTRL_READ_ONLY|NULL_CHECK|SAVE_VAL|USED|EDIT_VAL;
      reference=0;
      desc="current trial (event) within the epoch -- increments automatically";
      init_from=NULL;
     };
     ProgVar @[2] {
      name="trial_mon_data";
      var_type=T_Object;
      object_type=DataTable;
      object_val=$.data.gp[1][0]$;
      object_scope=NULL;
      objs_ptr=0;
      flags=CTRL_PANEL|NULL_CHECK|SAVE_VAL|USED|EDIT_VAL;
      reference=0;
      desc="trial-level output data -- we reset it every epoch by default, so it just contains last epoch of data";
      init_from=NULL;
     };
     ProgVar @[3] {
      name="epoch_timer";
      var_type=T_Object;
      object_type=TimeUsed;
      object_val=.networks[0].epoch_time$$;
      object_scope=NULL;
      objs_ptr=0;
      flags=NULL_CHECK|SAVE_VAL|USED|EDIT_VAL;
      reference=0;
      desc="timer to record time required to perform one epoch of processing (object is on network -- this is a pointer to it)";
      init_from=NULL;
     };
     ProgVar @[4] {
      name="data_loop_index";
      var_type=T_Int;
      int_val=1205;
      object_scope=NULL;
      flags=NULL_CHECK|SAVE_VAL|USED|EDIT_VAL;
      reference=0;
      desc="index counter for the looping over items in the input_data datatable (not always the same as trial counter, depending on distributed memory computation)";
      init_from=NULL;
     };
    };
    functions {
     name="functions";
     el_typ=Function;
     el_def=0;
    };
    init_code {
     name="init_code";
     el_typ=ProgCode;
     el_def=0;
     NetCounterInit @[0] {
      name="NetCounterInit_NetCounterInittrial";
      desc="initialize trial counter (local variable and in the network)";
      flags=CAN_REVERT_TO_CODE;
      code_string="Net Counter Init: trial";
      network_var=.programs.gp[0][2].args[0]$$;
      local_ctr_var=.programs.gp[0][2].vars[1]$$;
      counter=Network::trial;
      update_after=0;
     };
     AssignExpr @[1] {
      name="AssignExpr_epochtimernetworkepochtime";
      desc="get pointer to epoch timer object on network";
      flags=CAN_REVERT_TO_CODE;
      code_string="epoch_timer = network.epoch_time";
      result_var=.programs.gp[0][2].vars[3]$$;
      expr {
       expr="network.epoch_time";
      };
     };
    };
    prog_code {
     name="prog_code";
     el_typ=ProgCode;
     el_def=0;
     NetCounterInit @[0] {
      name="NetCounterInit_NetCounterInittrial";
      desc="initialize trial counter (local variable and in the network)";
      flags=CAN_REVERT_TO_CODE;
      code_string="Net Counter Init: trial";
      network_var=$.programs.gp[0][2].args[0]$;
      local_ctr_var=$.programs.gp[0][2].vars[1]$;
      counter=Network::trial;
      update_after=0;
     };
     AssignExpr @[1] {
      name="AssignExpr_epochtimernetworkepochtime";
      desc="get pointer to epoch timer object on network";
      flags=CAN_REVERT_TO_CODE;
      code_string="epoch_timer = network.epoch_time";
      result_var=$.programs.gp[0][2].vars[3]$;
      expr {
       expr="network.epoch_time";
      };
     };
     MethodCall @[2] {
      name="MethodCall_epochtimerStartTimertrue";
      desc="start the epoch timer to record computation time per epoch";
      flags=CAN_REVERT_TO_CODE;
      code_string="epoch_timer->StartTimer(true)";
      result_var=NULL;
      obj=$.programs.gp[0][2].vars[3]$;
      method=TimeUsed::StartTimer;
      meth_args {
       name="meth_args";
       el_typ=ProgArg;
       el_def=0;
       ProgArg @[0] {
	arg_type=bool;
	type="bool";
	name="reset_used";
	required=0;
	def_val="true";
	prev_expr=;
	expr {
	 expr="true";
	};
       };
      };
      meth_sig="void StartTimer(bool reset_used = true)";
      meth_desc=" record the current time as the starting time, and optionally reset the time used information";
     };
     MethodCall @[3] {
      name="MethodCall_trialmondataResetData";
      desc="reset trial-level monitor data every epoch, so it reflects only the most recent epoch's worth of data (turn flags OFF to accumulate trial data across entire training run)";
      flags=CAN_REVERT_TO_CODE;
      code_string="trial_mon_data->ResetData()";
      result_var=NULL;
      obj=.programs.gp[0][2].vars[2]$$;
      method=DataTable::ResetData;
      meth_args {
       name="meth_args";
       el_typ=ProgArg;
       el_def=0;
      };
      meth_sig="void ResetData()";
      meth_desc=" deletes all the data (rows), but keeps the column structure -- this cannot be undone!";
     };
     NetDataLoop @[4] {
      name="NetDataLoop_NetDataLoopPERMU_ardatalooporder";
      desc="iterates over the events/rows of input_data, according to data_loop_order variable";
      flags=CAN_REVERT_TO_CODE;
      code_string="Net Data Loop (PERMUTED):  table=input_data  index=data_loop_index  order_var=data_loop_order ";
      loop_code {
       name="loop_code";
       el_typ=ProgCode;
       el_def=0;
       ProgramCall @[0] {
	name="ProgramCall_BpTrialnetworkinputdata";
	desc="run the trial program, passing network and input_data";
	flags=CAN_REVERT_TO_CODE;
	code_string="BpTrial(network, input_data)";
	prog_args {
	 name="prog_args";
	 el_typ=ProgArg;
	 el_def=0;
	 ProgArg @[0] {
	  arg_type=BpNetwork;
	  type="BpNetwork*";
	  name="network";
	  required=1;
	  def_val=;
	  prev_expr=;
	  expr {
	   expr="network";
	  };
	 };
	 ProgArg @[1] {
	  arg_type=DataTable;
	  type="DataTable*";
	  name="input_data";
	  required=1;
	  def_val=;
	  prev_expr=;
	  expr {
	   expr="input_data";
	  };
	 };
	};
	target=$.programs.gp[0][3]$;
	targ_ld_init="*BpTrial*";
       };
       If @[1] {
	name="If_ifnetworkCompute_ightsTesttrial1";
	desc="test if it is time to update the weight values from delta weights (dWt) computed over trials";
	flags=CAN_REVERT_TO_CODE;
	code_string="if (network.Compute_Weights_Test(trial+1))";
	cond {
	 expr="network.Compute_Weights_Test(trial+1)";
	};
	true_code {
	 name="true_code";
	 el_typ=ProgCode;
	 el_def=0;
	 MethodCall @[0] {
	  name="MethodCall_networkComputeWeights";
	  desc="update the weight values based on changes computed by trial program";
	  flags=CAN_REVERT_TO_CODE;
	  code_string="network->Compute_Weights()";
	  result_var=NULL;
	  obj=$.programs.gp[0][2].args[0]$;
	  method=Network::Compute_Weights;
	  meth_args {
	   name="meth_args";
	   el_typ=ProgArg;
	   el_def=0;
	  };
	  meth_sig="void Compute_Weights()";
	  meth_desc=" update weights for whole net: calls DMem_SumDWts before doing update if in dmem mode";
	 };
	};
       };
      };
      data_var=.programs.gp[0][2].args[1]$$;
      index_var=.programs.gp[0][2].vars[4]$$;
      order_var=.programs.gp[0][2].vars[0]$$;
      order=PERMUTED;
      update_after=0;
      dmem_nprocs=1;
      dmem_this_proc=0;
      grouped=0;
      group_col 9 0="Group";
      group_index_var=NULL;
      group_order_var=NULL;
      group_order=PERMUTED;
      group_idx_list{       };
     };
     If @[5] {
      name="If_ifnetworkwtupdateNetworkBATCH";
      desc="if full batch mode, update only at end of epoch";
      flags=CAN_REVERT_TO_CODE;
      code_string="if (network.wt_update == Network::BATCH)";
      cond {
       expr="network.wt_update == Network::BATCH";
      };
      true_code {
       name="true_code";
       el_typ=ProgCode;
       el_def=0;
       MethodCall @[0] {
	name="MethodCall_networkComputeWeights";
	desc="final update of weights based on accumulated changes";
	flags=CAN_REVERT_TO_CODE;
	code_string="network->Compute_Weights()";
	result_var=NULL;
	obj=$.programs.gp[0][2].args[0]$;
	method=Network::Compute_Weights;
	meth_args {
	 name="meth_args";
	 el_typ=ProgArg;
	 el_def=0;
	};
	meth_sig="void Compute_Weights()";
	meth_desc=" update weights for whole net: calls DMem_SumDWts before doing update if in dmem mode";
       };
      };
     };
     MethodCall @[6] {
      name="MethodCall_networkComputeEpochStats";
      desc="network accumulates some core statistics over the epoch -- this finalizes that process and computes summary stats";
      flags=CAN_REVERT_TO_CODE;
      code_string="network->Compute_EpochStats()";
      result_var=NULL;
      obj=$.programs.gp[0][2].args[0]$;
      method=LeabraNetwork::Compute_EpochStats;
      meth_args {
       name="meth_args";
       el_typ=ProgArg;
       el_def=0;
      };
      meth_sig="void Compute_EpochStats()";
      meth_desc=" compute epoch-level statistics; calls DMem_ComputeAggs (if dmem) and EpochSSE -- specific algos may add more compute epoch-level statistics, including SSE, AvgExtRew and AvgCycles";
     };
     MethodCall @[7] {
      name="MethodCall_epochtimerEndTimer";
      desc="done with the computation in the epoch -- record time it took";
      flags=CAN_REVERT_TO_CODE;
      code_string="epoch_timer->EndTimer()";
      result_var=NULL;
      obj=$.programs.gp[0][2].vars[3]$;
      method=TimeUsed::EndTimer;
      meth_args {
       name="meth_args";
       el_typ=ProgArg;
       el_def=0;
      };
      meth_sig="void EndTimer()";
      meth_desc=" record the current time as the ending time, and compute difference as the time used";
     };
     ProgramCall @[8] {
      name="ProgramCall_BpEpochMonitornetwork";
      desc="run program that records data from network and possibly other sources about the epoch";
      flags=CAN_REVERT_TO_CODE;
      code_string="BpEpochMonitor(network)";
      prog_args {
       name="prog_args";
       el_typ=ProgArg;
       el_def=0;
       ProgArg @[0] {
	arg_type=Network;
	type="BpNetwork*";
	name="network";
	required=1;
	def_val=;
	prev_expr=;
	expr {
	 expr="network";
	};
       };
      };
      target=.programs.gp[0][6]$$;
      targ_ld_init="*BpEpochMonitor*";
     };
    };
    step_prog=NULL;
    step_n=1;
    doc {
     name="doc";
     desc=;
     web_doc=0;
     wiki=;
     url="local";
     full_url="local";
     text_size=1;
     text=;
     html_text=;
    };
   };
   Program @[3] {
    UserDataItem_List @*(.user_data_) {
     name=;
     el_typ=UserData_DocLink;
     el_def=0;
     UserData_DocLink @[0] {name="DocLink": doc=.programs.gp[0][3].doc$$: };
    };
    name="BpTrial";
    short_nm="Trial";
    tags="Bp, Std";
    desc="Backpropagation processing of a single input/output event or external information";
    version {
     major=0;
     minor=0;
     step=0;
    };
    author=;
    email=;
    flags=0;
    stop_step_cond {
     expr=;
    };
    objs {
     name="objs";
     el_typ=taNBase;
     el_def=0;
    };
    objs_vars {
     name="objs_vars";
     el_typ=ProgVar;
     el_def=0;
    };
    types {
     name="types";
     el_typ=DynEnumType;
     el_def=0;
    };
    args {
     name="args";
     el_typ=ProgVar;
     el_def=0;
     ProgVar @[0] {
      name="network";
      var_type=T_Object;
      object_type=BpNetwork;
      object_val=$.networks[0]$;
      object_scope=NULL;
      objs_ptr=0;
      flags=NULL_CHECK|SAVE_VAL|USED|EDIT_VAL|PGRM_ARG;
      reference=0;
      desc="network to operate on -- typically set by higher-level calling programs";
      init_from=NULL;
     };
     ProgVar @[1] {
      name="input_data";
      var_type=T_Object;
      object_type=DataTable;
      object_val=$.data.gp[0][1]$;
      object_scope=NULL;
      objs_ptr=0;
      flags=NULL_CHECK|SAVE_VAL|USED|EDIT_VAL|PGRM_ARG;
      reference=0;
      desc="datatable containing training input/output patterns";
      init_from=NULL;
     };
    };
    vars {
     name="vars";
     el_typ=ProgVar;
     el_def=0;
     ProgVar @[0] {
      name="update_net_view";
      var_type=T_Bool;
      bool_val=1;
      object_scope=NULL;
      flags=CTRL_PANEL|NULL_CHECK|SAVE_VAL|USED|EDIT_VAL;
      reference=0;
      desc="determines whether to update any network view displays after trial is completed";
      init_from=NULL;
     };
    };
    functions {
     name="functions";
     el_typ=Function;
     el_def=0;
    };
    init_code {
     name="init_code";
     el_typ=ProgCode;
     el_def=0;
    };
    prog_code {
     name="prog_code";
     el_typ=ProgCode;
     el_def=0;
     MethodCall @[0] {
      name="MethodCall_networkInitInputData";
      desc="resets input data, before getting new external inputs data from apply inputs call";
      flags=CAN_REVERT_TO_CODE;
      code_string="network->Init_InputData()";
      result_var=NULL;
      obj=.programs.gp[0][3].args[0]$$;
      method=Network::Init_InputData;
      meth_args {
       name="meth_args";
       el_typ=ProgArg;
       el_def=0;
      };
      meth_sig="void Init_InputData()";
      meth_desc=" Initializes external and target inputs";
     };
     ProgramCall @[1] {
      name="ProgramCall_ApplyInputsnetworkinputdata";
      desc="apply external input activations from the input_data table to the network
this program can be extended to do arbitrary things to generate data and apply it to network layers";
      flags=CAN_REVERT_TO_CODE;
      code_string="ApplyInputs(network, input_data)";
      prog_args {
       name="prog_args";
       el_typ=ProgArg;
       el_def=0;
       ProgArg @[0] {
	arg_type=LeabraNetwork;
	type="BpNetwork*";
	name="network";
	required=1;
	def_val=;
	prev_expr=;
	expr {
	 expr="network";
	};
       };
       ProgArg @[1] {
	arg_type=DataTable;
	type="DataTable*";
	name="input_data";
	required=1;
	def_val=;
	prev_expr=;
	expr {
	 expr="input_data";
	};
       };
      };
      target=.programs.gp[0][4]$$;
      targ_ld_init="*ApplyInputs*";
     };
     MethodCall @[2] {
      name="MethodCall_networkTrialRun";
      desc="initializes various counters at start of trial";
      flags=CAN_REVERT_TO_CODE;
      code_string="network->Trial_Run()";
      result_var=NULL;
      obj=$.programs.gp[0][3].args[0]$;
      method=BpNetwork::Trial_Run;
      meth_args {
       name="meth_args";
       el_typ=ProgArg;
       el_def=0;
      };
      meth_sig="void Trial_Run()";
      meth_desc=" run one trial of Bp: calls SetCurLrate, Compute_NetinAct, Compute_dEdA_dEdNet, and, if train_mode == TRAIN, Compute_dWt. If you want to save some speed just for testing, you can just call Compute_NetinAct and skip the other two (esp Compute_dEdA_dEdNet, which does a full backprop and is expensive, but often useful for visualization & testing)";
     };
     MethodCall @[3] {
      name="MethodCall_networkComputeTrialStats";
      desc=;
      flags=CAN_REVERT_TO_CODE;
      code_string="network->Compute_TrialStats()";
      result_var=NULL;
      obj=$.programs.gp[0][3].args[0]$;
      method=LeabraNetwork::Compute_TrialStats;
      meth_args {
       name="meth_args";
       el_typ=ProgArg;
       el_def=0;
      };
      meth_sig="void Compute_TrialStats()";
      meth_desc=" compute trial-level statistics (SSE and others defined by specific algorithms) do not call this function anymore -- it is obsolete -- please use Compute_PhaseStats or Compute_MinusStats / Compute_PlusStats for more appropriate stats computation at the right time";
     };
     ProgramCall @[4] {
      name="ProgramCall_BpTrialMonitornetwork";
      desc="records data about the trial-level processing to a datatable for graphing/processing";
      flags=CAN_REVERT_TO_CODE;
      code_string="BpTrialMonitor(network)";
      prog_args {
       name="prog_args";
       el_typ=ProgArg;
       el_def=0;
       ProgArg @[0] {
	arg_type=Network;
	type="BpNetwork*";
	name="network";
	required=1;
	def_val=;
	prev_expr=;
	expr {
	 expr="network";
	};
       };
      };
      target=.programs.gp[0][5]$$;
      targ_ld_init="*BpTrialMonitor*";
     };
     NetUpdateView @[5] {
      name="NetUpdateView_NetUpdateView";
      desc="update the network view(s) (only if update_net_view is true)";
      flags=CAN_REVERT_TO_CODE;
      code_string="Net Update View";
      network_var=$.programs.gp[0][3].args[0]$;
      update_var=.programs.gp[0][3].vars[0]$$;
     };
    };
    step_prog=NULL;
    step_n=1;
    doc {
     name="doc";
     desc=;
     web_doc=0;
     wiki=;
     url="local";
     full_url="local";
     text_size=1;
     text=;
     html_text=;
    };
   };
   Program @[4] {
    UserDataItem_List @*(.user_data_) {
     name=;
     el_typ=UserData_DocLink;
     el_def=0;
     UserData_DocLink @[0] {name="DocLink": doc=.programs.gp[0][4].doc$$: };
    };
    name="ApplyInputs";
    short_nm="AplyIn";
    tags="Network, InputData, Apply";
    desc="apply the current input data to the network as external input and target values";
    version {
     major=0;
     minor=0;
     step=0;
    };
    author=;
    email=;
    flags=NO_STOP_STEP;
    stop_step_cond {
     expr=;
    };
    objs {
     name="objs";
     el_typ=LayerWriter;
     el_def=0;
     LayerWriter @[0] {
      name="LayerWriter_0";
      data=$.data.gp[0][1]$;
      network=$.networks[0]$;
      layer_data {
       name="layer_data";
       el_typ=LayerWriterEl;
       el_def=0;
       LayerWriterEl @[0] {
	col_name="Input";
	net_target=LAYER;
	layer_name="Input";
	offset {x=0: y=0: };
	use_layer_type=1;
	quiet=0;
	na_by_range=0;
	ext_flags=EXT;
	noise {name="noise": type=NONE: mean=0: var=0.5: par=1: };
       };
       LayerWriterEl @[1] {
	col_name="Output";
	net_target=LAYER;
	layer_name="Output";
	offset {x=0: y=0: };
	use_layer_type=1;
	quiet=0;
	na_by_range=0;
	ext_flags=TARG;
	noise {name="noise": type=NONE: mean=0: var=0.5: par=1: };
       };
       LayerWriterEl @[2] {
	col_name="Name";
	net_target=TRIAL_NAME;
	layer_name="Name";
	offset {x=0: y=0: };
	use_layer_type=1;
	quiet=0;
	na_by_range=0;
	ext_flags=0;
	noise {name="noise": type=NONE: mean=0: var=0.5: par=1: };
       };
      };
     };
    };
    objs_vars {
     name="objs_vars";
     el_typ=ProgVar;
     el_def=0;
     ProgVar @[0] {
      name="layer_writer_0";
      var_type=T_Object;
      object_type=LayerWriter;
      object_val=.programs.gp[0][4].objs[0]$$;
      object_scope=NULL;
      objs_ptr=1;
      flags=NULL_CHECK|SAVE_VAL|USED|EDIT_VAL;
      reference=0;
      desc="this is a pointer to the LayerWriter object in objs -- edit that object to determine how information is presented to the network";
      init_from=NULL;
     };
    };
    types {
     name="types";
     el_typ=DynEnumType;
     el_def=0;
    };
    args {
     name="args";
     el_typ=ProgVar;
     el_def=0;
     ProgVar @[0] {
      name="network";
      var_type=T_Object;
      object_type=LeabraNetwork;
      object_val=$.networks[0]$;
      object_scope=NULL;
      objs_ptr=0;
      flags=NULL_CHECK|SAVE_VAL|USED|EDIT_VAL|PGRM_ARG;
      reference=0;
      desc="network to apply inputs to -- typically set by calling program";
      init_from=NULL;
     };
     ProgVar @[1] {
      name="input_data";
      var_type=T_Object;
      object_type=DataTable;
      object_val=$.data.gp[0][1]$;
      object_scope=NULL;
      objs_ptr=0;
      flags=NULL_CHECK|SAVE_VAL|USED|EDIT_VAL|PGRM_ARG;
      reference=0;
      desc="input datatable containing input/output patterns";
      init_from=NULL;
     };
    };
    vars {
     name="vars";
     el_typ=ProgVar;
     el_def=0;
    };
    functions {
     name="functions";
     el_typ=Function;
     el_def=0;
    };
    init_code {
     name="init_code";
     el_typ=ProgCode;
     el_def=0;
     MethodCall @[0] {
      name="MethodCall_layerwriter0SetD_nputdatanetwork";
      desc="sets the datatable and network for the layer writer, so it knows what to write to";
      flags=CAN_REVERT_TO_CODE;
      code_string="layer_writer_0->SetDataNetwork(input_data, network)";
      result_var=NULL;
      obj=.programs.gp[0][4].objs_vars[0]$$;
      method=LayerWriter::SetDataNetwork;
      meth_args {
       name="meth_args";
       el_typ=ProgArg;
       el_def=0;
       ProgArg @[0] {
	arg_type=DataTable_ptr;
	type="DataTable*";
	name="db";
	required=1;
	def_val=;
	prev_expr=;
	expr {
	 expr="input_data";
	};
       };
       ProgArg @[1] {
	arg_type=Network_ptr;
	type="Network*";
	name="net";
	required=1;
	def_val=;
	prev_expr=;
	expr {
	 expr="network";
	};
       };
      };
      meth_sig="void SetDataNetwork(DataTable* db, Network* net)";
      meth_desc=" set the data table and network pointers -- convenience function for programs ";
     };
     MethodCall @[1] {
      name="MethodCall_layerwriter0CheckConfigfalse";
      desc="check the configuration of the layer writer -- will emit warnings and errors for missing or misconfigured items";
      flags=CAN_REVERT_TO_CODE;
      code_string="layer_writer_0->CheckConfig(false)";
      result_var=NULL;
      obj=$.programs.gp[0][4].objs_vars[0]$;
      method=taList_impl::CheckConfig;
      meth_args {
       name="meth_args";
       el_typ=ProgArg;
       el_def=0;
       ProgArg @[0] {
	arg_type=bool;
	type="bool";
	name="quiet";
	required=0;
	def_val="false";
	prev_expr=;
	expr {
	 expr="false";
	};
       };
      };
      meth_sig="bool CheckConfig(bool quiet = false)";
      meth_desc=" check the configuration of this object and all its children (defaults to no confirm of success)";
     };
    };
    prog_code {
     name="prog_code";
     el_typ=ProgCode;
     el_def=0;
     MethodCall @[0] {
      name="MethodCall_layerwriter0ApplyInputData";
      desc="apply inputs to the network!  layer writer has all the key specs";
      flags=CAN_REVERT_TO_CODE;
      code_string="layer_writer_0->ApplyInputData()";
      result_var=NULL;
      obj=$.programs.gp[0][4].objs_vars[0]$;
      method=LayerWriter::ApplyInputData;
      meth_args {
       name="meth_args";
       el_typ=ProgArg;
       el_def=0;
      };
      meth_sig="bool ApplyInputData()";
      meth_desc=" apply data to the layers, using the network's current context settings (TEST,TRAIN,etc) -- returns success";
     };
    };
    step_prog=NULL;
    step_n=1;
    doc {
     name="doc";
     desc=;
     web_doc=0;
     wiki=;
     url="local";
     full_url="local";
     text_size=1;
     text=;
     html_text=;
    };
   };
   Program @[5] {
    UserDataItem_List @*(.user_data_) {
     name=;
     el_typ=UserData_DocLink;
     el_def=0;
     UserData_DocLink @[0] {name="DocLink": doc=.programs.gp[0][5].doc$$: };
    };
    name="BpTrialMonitor";
    short_nm="TrlMon";
    tags="Bp, Std, Monitor";
    desc="monitor trial-level data from the network (and potentially other sources) -- stores results in datatable (TrialOutputData typically) that can be used for graph/grid views and further analysis ";
    version {
     major=0;
     minor=0;
     step=0;
    };
    author=;
    email=;
    flags=NO_STOP_STEP;
    stop_step_cond {
     expr=;
    };
    objs {
     name="objs";
     el_typ=NetMonitor;
     el_def=0;
     NetMonitor @[0] {
      name="trial_netmon";
      items {
       name="items";
       el_typ=NetMonItem;
       el_def=0;
       NetMonItem @[0] {
	name="batch";
	computed=0;
	object_type=LeabraNetwork;
	object=$.networks[0]$;
	variable="batch";
	var_label=;
	name_style=AUTO_NAME;
	max_name_len=6;
	options=HIDDEN_LAYERS|OUTPUT_LAYERS|TARGET_LAYERS;
	val_type=VT_FLOAT;
	matrix=0;
	matrix_geom{ 	};
	data_agg=0;
	data_src=NULL;
	agg_col {
	 col_name=;
	};
	agg {name="agg": op=NONE: rel={name="rel": rel=LESSTHANOREQUAL: val=0: val_string="": use_var=0: var=NULL: }: };
	select_rows=0;
	select_spec {
	 col_name=;
	 name="_EQUAL_";
	 on=1;
	 rel=EQUAL;
	 use_var=0;
	 cmp 0 1;
	 var=NULL;
	 enable_var=NULL;
	};
	pre_proc_1 {name="pre_proc_1": opr=NONE: arg=0: lw=-1: hi=1: };
	pre_proc_2 {name="pre_proc_2": opr=NONE: arg=0: lw=-1: hi=1: };
	pre_proc_3 {name="pre_proc_3": opr=NONE: arg=0: lw=-1: hi=1: };
       };
       NetMonItem @[1] {
	name="epoch";
	computed=0;
	object_type=LeabraNetwork;
	object=$.networks[0]$;
	variable="epoch";
	var_label=;
	name_style=AUTO_NAME;
	max_name_len=6;
	options=HIDDEN_LAYERS|OUTPUT_LAYERS|TARGET_LAYERS;
	val_type=VT_FLOAT;
	matrix=0;
	matrix_geom{ 	};
	data_agg=0;
	data_src=NULL;
	agg_col {
	 col_name=;
	};
	agg {name="agg": op=NONE: rel={name="rel": rel=LESSTHANOREQUAL: val=0: val_string="": use_var=0: var=NULL: }: };
	select_rows=0;
	select_spec {
	 col_name=;
	 name="_EQUAL_";
	 on=1;
	 rel=EQUAL;
	 use_var=0;
	 cmp 0 1;
	 var=NULL;
	 enable_var=NULL;
	};
	pre_proc_1 {name="pre_proc_1": opr=NONE: arg=0: lw=-1: hi=1: };
	pre_proc_2 {name="pre_proc_2": opr=NONE: arg=0: lw=-1: hi=1: };
	pre_proc_3 {name="pre_proc_3": opr=NONE: arg=0: lw=-1: hi=1: };
       };
       NetMonItem @[2] {
	name="trial";
	computed=0;
	object_type=LeabraNetwork;
	object=$.networks[0]$;
	variable="trial";
	var_label=;
	name_style=AUTO_NAME;
	max_name_len=6;
	options=HIDDEN_LAYERS|OUTPUT_LAYERS|TARGET_LAYERS;
	val_type=VT_FLOAT;
	matrix=0;
	matrix_geom{ 	};
	data_agg=0;
	data_src=NULL;
	agg_col {
	 col_name=;
	};
	agg {name="agg": op=NONE: rel={name="rel": rel=LESSTHANOREQUAL: val=0: val_string="": use_var=0: var=NULL: }: };
	select_rows=0;
	select_spec {
	 col_name=;
	 name="_EQUAL_";
	 on=1;
	 rel=EQUAL;
	 use_var=0;
	 cmp 0 1;
	 var=NULL;
	 enable_var=NULL;
	};
	pre_proc_1 {name="pre_proc_1": opr=NONE: arg=0: lw=-1: hi=1: };
	pre_proc_2 {name="pre_proc_2": opr=NONE: arg=0: lw=-1: hi=1: };
	pre_proc_3 {name="pre_proc_3": opr=NONE: arg=0: lw=-1: hi=1: };
       };
       NetMonItem @[3] {
	name="trial_name";
	computed=0;
	object_type=LeabraNetwork;
	object=$.networks[0]$;
	variable="trial_name";
	var_label=;
	name_style=AUTO_NAME;
	max_name_len=6;
	options=HIDDEN_LAYERS|OUTPUT_LAYERS|TARGET_LAYERS;
	val_type=VT_FLOAT;
	matrix=0;
	matrix_geom{ 	};
	data_agg=0;
	data_src=NULL;
	agg_col {
	 col_name=;
	};
	agg {name="agg": op=NONE: rel={name="rel": rel=LESSTHANOREQUAL: val=0: val_string="": use_var=0: var=NULL: }: };
	select_rows=0;
	select_spec {
	 col_name=;
	 name="_EQUAL_";
	 on=1;
	 rel=EQUAL;
	 use_var=0;
	 cmp 0 1;
	 var=NULL;
	 enable_var=NULL;
	};
	pre_proc_1 {name="pre_proc_1": opr=NONE: arg=0: lw=-1: hi=1: };
	pre_proc_2 {name="pre_proc_2": opr=NONE: arg=0: lw=-1: hi=1: };
	pre_proc_3 {name="pre_proc_3": opr=NONE: arg=0: lw=-1: hi=1: };
       };
       NetMonItem @[4] {
	name="group_name";
	computed=0;
	object_type=LeabraNetwork;
	object=$.networks[0]$;
	variable="group_name";
	var_label=;
	name_style=AUTO_NAME;
	max_name_len=6;
	options=HIDDEN_LAYERS|OUTPUT_LAYERS|TARGET_LAYERS;
	val_type=VT_FLOAT;
	matrix=0;
	matrix_geom{ 	};
	data_agg=0;
	data_src=NULL;
	agg_col {
	 col_name=;
	};
	agg {name="agg": op=NONE: rel={name="rel": rel=LESSTHANOREQUAL: val=0: val_string="": use_var=0: var=NULL: }: };
	select_rows=0;
	select_spec {
	 col_name=;
	 name="_EQUAL_";
	 on=1;
	 rel=EQUAL;
	 use_var=0;
	 cmp 0 1;
	 var=NULL;
	 enable_var=NULL;
	};
	pre_proc_1 {name="pre_proc_1": opr=NONE: arg=0: lw=-1: hi=1: };
	pre_proc_2 {name="pre_proc_2": opr=NONE: arg=0: lw=-1: hi=1: };
	pre_proc_3 {name="pre_proc_3": opr=NONE: arg=0: lw=-1: hi=1: };
       };
       NetMonItem @[5] {
	name="sse";
	computed=0;
	object_type=LeabraNetwork;
	object=$.networks[0]$;
	variable="sse";
	var_label=;
	name_style=AUTO_NAME;
	max_name_len=6;
	options=HIDDEN_LAYERS|OUTPUT_LAYERS|TARGET_LAYERS;
	val_type=VT_FLOAT;
	matrix=0;
	matrix_geom{ 	};
	data_agg=0;
	data_src=NULL;
	agg_col {
	 col_name=;
	};
	agg {name="agg": op=NONE: rel={name="rel": rel=LESSTHANOREQUAL: val=0: val_string="": use_var=0: var=NULL: }: };
	select_rows=0;
	select_spec {
	 col_name=;
	 name="_EQUAL_";
	 on=1;
	 rel=EQUAL;
	 use_var=0;
	 cmp 0 1;
	 var=NULL;
	 enable_var=NULL;
	};
	pre_proc_1 {name="pre_proc_1": opr=NONE: arg=0: lw=-1: hi=1: };
	pre_proc_2 {name="pre_proc_2": opr=NONE: arg=0: lw=-1: hi=1: };
	pre_proc_3 {name="pre_proc_3": opr=NONE: arg=0: lw=-1: hi=1: };
       };
      };
      network=$.networks[0]$;
      data=$.data.gp[1][0]$;
      rmv_orphan_cols=1;
     };
    };
    objs_vars {
     name="objs_vars";
     el_typ=ProgVar;
     el_def=0;
     ProgVar @[0] {
      name="trial_netmon";
      var_type=T_Object;
      object_type=NetMonitor;
      object_val=.programs.gp[0][5].objs[0]$$;
      object_scope=NULL;
      objs_ptr=1;
      flags=NULL_CHECK|SAVE_VAL|USED|EDIT_VAL;
      reference=0;
      desc="pointer to the NetMonitor object in objs secton of this program that contains configuration for what to record and where to get it";
      init_from=NULL;
     };
    };
    types {
     name="types";
     el_typ=DynEnumType;
     el_def=0;
    };
    args {
     name="args";
     el_typ=ProgVar;
     el_def=0;
     ProgVar @[0] {
      name="network";
      var_type=T_Object;
      object_type=Network;
      object_val=$.networks[0]$;
      object_scope=NULL;
      objs_ptr=0;
      flags=CTRL_PANEL|NULL_CHECK|SAVE_VAL|USED|EDIT_VAL|PGRM_ARG;
      reference=0;
      desc="network to record data from";
      init_from=NULL;
     };
    };
    vars {
     name="vars";
     el_typ=ProgVar;
     el_def=0;
     ProgVar @[0] {
      name="trial_mon_data";
      var_type=T_Object;
      object_type=DataTable;
      object_val=$.data.gp[1][0]$;
      object_scope=NULL;
      objs_ptr=0;
      flags=CTRL_PANEL|NULL_CHECK|SAVE_VAL|USED|EDIT_VAL;
      reference=0;
      desc="data table to record trial-level data to (this program writes new data to this table!)";
      init_from=NULL;
     };
    };
    functions {
     name="functions";
     el_typ=Function;
     el_def=0;
    };
    init_code {
     name="init_code";
     el_typ=ProgCode;
     el_def=0;
     MethodCall @[0] {
      name="MethodCall_trialnetmonSetDa_lmondatanetwork";
      desc="set the network and datatable for the NetMonitor";
      flags=CAN_REVERT_TO_CODE;
      code_string="trial_netmon->SetDataNetwork(trial_mon_data, network)";
      result_var=NULL;
      obj=.programs.gp[0][5].objs_vars[0]$$;
      method=NetMonitor::SetDataNetwork;
      meth_args {
       name="meth_args";
       el_typ=ProgArg;
       el_def=0;
       ProgArg @[0] {
	arg_type=DataTable_ptr;
	type="DataTable*";
	name="dt";
	required=1;
	def_val=;
	prev_expr=;
	expr {
	 expr="trial_mon_data";
	};
       };
       ProgArg @[1] {
	arg_type=Network_ptr;
	type="Network*";
	name="net";
	required=1;
	def_val=;
	prev_expr=;
	expr {
	 expr="network";
	};
       };
      };
      meth_sig="void SetDataNetwork(DataTable* dt, Network* net)";
      meth_desc=" set both the data table and network -- convenient for programs -- calls ResetDataTableCols too -- don't call if columns are manually added or this is adding additional rows to a table";
     };
     MethodCall @[1] {
      name="MethodCall_trialnetmonCheckConfigfalse";
      desc="check the configuration of the network monitor -- will emit warnings and errors for misconfigurations";
      flags=CAN_REVERT_TO_CODE;
      code_string="trial_netmon->CheckConfig(false)";
      result_var=NULL;
      obj=$.programs.gp[0][5].objs_vars[0]$;
      method=taBase::CheckConfig;
      meth_args {
       name="meth_args";
       el_typ=ProgArg;
       el_def=0;
       ProgArg @[0] {
	arg_type=bool;
	type="bool";
	name="quiet";
	required=0;
	def_val="false";
	prev_expr=;
	expr {
	 expr="false";
	};
       };
      };
      meth_sig="bool CheckConfig(bool quiet = false)";
      meth_desc=" check the configuration of this object and all its children (defaults to no confirm of success)";
     };
     MethodCall @[2] {
      name="MethodCall_trialnetmonUpdateMonitorstrue";
      desc="update the monitor items and data schema based on current settings of the NetMonitor object";
      flags=CAN_REVERT_TO_CODE;
      code_string="trial_netmon->UpdateMonitors(true)";
      result_var=NULL;
      obj=$.programs.gp[0][5].objs_vars[0]$;
      method=NetMonitor::UpdateMonitors;
      meth_args {
       name="meth_args";
       el_typ=ProgArg;
       el_def=0;
       ProgArg @[0] {
	arg_type=bool;
	type="bool";
	name="reset_first";
	required=0;
	def_val="false";
	prev_expr=;
	expr {
	 expr="true";
	};
       };
      };
      meth_sig="void UpdateMonitors(bool reset_first = false)";
      meth_desc=" old name for UpdateDataTable";
     };
    };
    prog_code {
     name="prog_code";
     el_typ=ProgCode;
     el_def=0;
     MethodCall @[0] {
      name="MethodCall_trialmondataAddBlankRow";
      desc="add a new blank row to the data";
      flags=CAN_REVERT_TO_CODE;
      code_string="trial_mon_data->AddBlankRow()";
      result_var=NULL;
      obj=.programs.gp[0][5].vars[0]$$;
      method=DataTable::AddBlankRow;
      meth_args {
       name="meth_args";
       el_typ=ProgArg;
       el_def=0;
      };
      meth_sig="int AddBlankRow()";
      meth_desc=" add a new row to the data table, sets read (source) and write (sink) index to this last row (as in ReadItem or WriteItem), so that subsequent data routines refer to this new row, and returns row ";
     };
     MethodCall @[1] {
      name="MethodCall_trialnetmonGetMonVals";
      desc="get the new monitor data from the network and other sources -- this does the main work";
      flags=CAN_REVERT_TO_CODE;
      code_string="trial_netmon->GetMonVals()";
      result_var=NULL;
      obj=$.programs.gp[0][5].objs_vars[0]$;
      method=NetMonitor::GetMonVals;
      meth_args {
       name="meth_args";
       el_typ=ProgArg;
       el_def=0;
      };
      meth_sig="void GetMonVals()";
      meth_desc=" get all the values and store in current row of data table -- call in program to get new data";
     };
     MethodCall @[2] {
      name="MethodCall_trialmondataWriteClose";
      desc="update views and other things after writing new data to monitor data table";
      flags=CAN_REVERT_TO_CODE;
      code_string="trial_mon_data->WriteClose()";
      result_var=NULL;
      obj=$.programs.gp[0][5].vars[0]$;
      method=DataTable::WriteClose;
      meth_args {
       name="meth_args";
       el_typ=ProgArg;
       el_def=0;
      };
      meth_sig="void WriteClose()";
      meth_desc=" closes up a write operation -- call when done writing data -- performs any post-writing cleanup/closing of files, etc";
     };
     MethodCall @[3] {
      name="MethodCall_networkDMemShare_tatrialmondata1";
      desc="only functional for dmem projects: synchronizes trial data across processes so that all distributed memory processors have the same trial-level data, despite having run only a subset of them each";
      flags=CAN_REVERT_TO_CODE;
      code_string="network->DMem_ShareTrialData(trial_mon_data, 1)";
      result_var=NULL;
      obj=.programs.gp[0][5].args[0]$$;
      method=Network::DMem_ShareTrialData;
      meth_args {
       name="meth_args";
       el_typ=ProgArg;
       el_def=0;
       ProgArg @[0] {
	arg_type=DataTable_ptr;
	type="DataTable*";
	name="dt";
	required=1;
	def_val=;
	prev_expr=;
	expr {
	 expr="trial_mon_data";
	};
       };
       ProgArg @[1] {
	arg_type=int;
	type="int";
	name="n_rows";
	required=0;
	def_val="1";
	prev_expr=;
	expr {
	 expr="1";
	};
       };
      };
      meth_sig="void DMem_ShareTrialData(DataTable* dt, int n_rows = 1)";
      meth_desc=" share trial data from given datatable across the trial-level dmem communicator (outer loop) -- each processor gets data from all other processors; if called every trial with n_rows = 1, data will be identical to non-dmem; if called at end of epoch with n_rows = -1 data will be grouped by processor but this is more efficient";
     };
    };
    step_prog=NULL;
    step_n=1;
    doc {
     name="doc";
     desc=;
     web_doc=0;
     wiki=;
     url="local";
     full_url="local";
     text_size=1;
     text=;
     html_text=;
    };
   };
   Program @[6] {
    UserDataItem_List @*(.user_data_) {
     name=;
     el_typ=UserData_DocLink;
     el_def=0;
     UserData_DocLink @[0] {name="DocLink": doc=.programs.gp[0][6].doc$$: };
    };
    name="BpEpochMonitor";
    short_nm="EpcMon";
    tags="Bp, Std, Monitor";
    desc="monitor epoch-level data from the network to a datatable (EpochOutputData typically) for use in graphing and viewing and further analysis";
    version {
     major=0;
     minor=0;
     step=0;
    };
    author=;
    email=;
    flags=NO_STOP_STEP;
    stop_step_cond {
     expr=;
    };
    objs {
     name="objs";
     el_typ=NetMonitor;
     el_def=0;
     NetMonitor @[0] {
      name="epoch_netmon";
      items {
       name="items";
       el_typ=NetMonItem;
       el_def=0;
       NetMonItem @[0] {
	name="batch";
	computed=0;
	object_type=LeabraNetwork;
	object=$.networks[0]$;
	variable="batch";
	var_label=;
	name_style=AUTO_NAME;
	max_name_len=6;
	options=HIDDEN_LAYERS|OUTPUT_LAYERS|TARGET_LAYERS;
	val_type=VT_FLOAT;
	matrix=0;
	matrix_geom{ 	};
	data_agg=0;
	data_src=NULL;
	agg_col {
	 col_name=;
	};
	agg {name="agg": op=NONE: rel={name="rel": rel=LESSTHANOREQUAL: val=0: val_string="": use_var=0: var=NULL: }: };
	select_rows=0;
	select_spec {
	 col_name=;
	 name="_EQUAL_";
	 on=1;
	 rel=EQUAL;
	 use_var=0;
	 cmp 0 1;
	 var=NULL;
	 enable_var=NULL;
	};
	pre_proc_1 {name="pre_proc_1": opr=NONE: arg=0: lw=-1: hi=1: };
	pre_proc_2 {name="pre_proc_2": opr=NONE: arg=0: lw=-1: hi=1: };
	pre_proc_3 {name="pre_proc_3": opr=NONE: arg=0: lw=-1: hi=1: };
       };
       NetMonItem @[1] {
	name="epoch";
	computed=0;
	object_type=LeabraNetwork;
	object=$.networks[0]$;
	variable="epoch";
	var_label=;
	name_style=AUTO_NAME;
	max_name_len=6;
	options=HIDDEN_LAYERS|OUTPUT_LAYERS|TARGET_LAYERS;
	val_type=VT_FLOAT;
	matrix=0;
	matrix_geom{ 	};
	data_agg=0;
	data_src=NULL;
	agg_col {
	 col_name=;
	};
	agg {name="agg": op=NONE: rel={name="rel": rel=LESSTHANOREQUAL: val=0: val_string="": use_var=0: var=NULL: }: };
	select_rows=0;
	select_spec {
	 col_name=;
	 name="_EQUAL_";
	 on=1;
	 rel=EQUAL;
	 use_var=0;
	 cmp 0 1;
	 var=NULL;
	 enable_var=NULL;
	};
	pre_proc_1 {name="pre_proc_1": opr=NONE: arg=0: lw=-1: hi=1: };
	pre_proc_2 {name="pre_proc_2": opr=NONE: arg=0: lw=-1: hi=1: };
	pre_proc_3 {name="pre_proc_3": opr=NONE: arg=0: lw=-1: hi=1: };
       };
       NetMonItem @[2] {
	name="avg_sse";
	computed=0;
	object_type=LeabraNetwork;
	object=$.networks[0]$;
	variable="avg_sse";
	var_label=;
	name_style=AUTO_NAME;
	max_name_len=6;
	options=HIDDEN_LAYERS|OUTPUT_LAYERS|TARGET_LAYERS;
	val_type=VT_FLOAT;
	matrix=0;
	matrix_geom{ 	};
	data_agg=0;
	data_src=NULL;
	agg_col {
	 col_name=;
	};
	agg {name="agg": op=NONE: rel={name="rel": rel=LESSTHANOREQUAL: val=0: val_string="": use_var=0: var=NULL: }: };
	select_rows=0;
	select_spec {
	 col_name=;
	 name="_EQUAL_";
	 on=1;
	 rel=EQUAL;
	 use_var=0;
	 cmp 0 1;
	 var=NULL;
	 enable_var=NULL;
	};
	pre_proc_1 {name="pre_proc_1": opr=NONE: arg=0: lw=-1: hi=1: };
	pre_proc_2 {name="pre_proc_2": opr=NONE: arg=0: lw=-1: hi=1: };
	pre_proc_3 {name="pre_proc_3": opr=NONE: arg=0: lw=-1: hi=1: };
       };
       NetMonItem @[3] {
	name="cnt_err";
	computed=0;
	object_type=LeabraNetwork;
	object=$.networks[0]$;
	variable="cnt_err";
	var_label=;
	name_style=AUTO_NAME;
	max_name_len=6;
	options=HIDDEN_LAYERS|OUTPUT_LAYERS|TARGET_LAYERS;
	val_type=VT_FLOAT;
	matrix=0;
	matrix_geom{ 	};
	data_agg=0;
	data_src=NULL;
	agg_col {
	 col_name=;
	};
	agg {name="agg": op=NONE: rel={name="rel": rel=LESSTHANOREQUAL: val=0: val_string="": use_var=0: var=NULL: }: };
	select_rows=0;
	select_spec {
	 col_name=;
	 name="_EQUAL_";
	 on=1;
	 rel=EQUAL;
	 use_var=0;
	 cmp 0 1;
	 var=NULL;
	 enable_var=NULL;
	};
	pre_proc_1 {name="pre_proc_1": opr=NONE: arg=0: lw=-1: hi=1: };
	pre_proc_2 {name="pre_proc_2": opr=NONE: arg=0: lw=-1: hi=1: };
	pre_proc_3 {name="pre_proc_3": opr=NONE: arg=0: lw=-1: hi=1: };
       };
       NetMonItem @[4] {
	name="epoch_time_tot";
	computed=1;
	object_type=NULL;
	object=NULL;
	variable="act";
	var_label=;
	name_style=MY_NAME;
	max_name_len=6;
	options=HIDDEN_LAYERS|OUTPUT_LAYERS|TARGET_LAYERS;
	val_type=VT_FLOAT;
	matrix=0;
	matrix_geom{ 	};
	data_agg=0;
	data_src=NULL;
	agg_col {
	 col_name=;
	};
	agg {name="agg": op=NONE: rel={name="rel": rel=LESSTHANOREQUAL: val=0: val_string="": use_var=0: var=NULL: }: };
	select_rows=0;
	select_spec {
	 col_name=;
	 name="_EQUAL_";
	 on=1;
	 rel=EQUAL;
	 use_var=0;
	 cmp 0 1;
	 var=NULL;
	 enable_var=NULL;
	};
	pre_proc_1 {name="pre_proc_1": opr=NONE: arg=0: lw=-1: hi=1: };
	pre_proc_2 {name="pre_proc_2": opr=NONE: arg=0: lw=-1: hi=1: };
	pre_proc_3 {name="pre_proc_3": opr=NONE: arg=0: lw=-1: hi=1: };
       };
       NetMonItem @[5] {
	name="epoch_time_usr";
	computed=1;
	object_type=NULL;
	object=NULL;
	variable="act";
	var_label=;
	name_style=MY_NAME;
	max_name_len=6;
	options=HIDDEN_LAYERS|OUTPUT_LAYERS|TARGET_LAYERS;
	val_type=VT_FLOAT;
	matrix=0;
	matrix_geom{ 	};
	data_agg=0;
	data_src=NULL;
	agg_col {
	 col_name=;
	};
	agg {name="agg": op=NONE: rel={name="rel": rel=LESSTHANOREQUAL: val=0: val_string="": use_var=0: var=NULL: }: };
	select_rows=0;
	select_spec {
	 col_name=;
	 name="_EQUAL_";
	 on=1;
	 rel=EQUAL;
	 use_var=0;
	 cmp 0 1;
	 var=NULL;
	 enable_var=NULL;
	};
	pre_proc_1 {name="pre_proc_1": opr=NONE: arg=0: lw=-1: hi=1: };
	pre_proc_2 {name="pre_proc_2": opr=NONE: arg=0: lw=-1: hi=1: };
	pre_proc_3 {name="pre_proc_3": opr=NONE: arg=0: lw=-1: hi=1: };
       };
      };
      network=$.networks[0]$;
      data=$.data.gp[1][1]$;
      rmv_orphan_cols=1;
     };
    };
    objs_vars {
     name="objs_vars";
     el_typ=ProgVar;
     el_def=0;
     ProgVar @[0] {
      name="epoch_netmon";
      var_type=T_Object;
      object_type=NetMonitor;
      object_val=.programs.gp[0][6].objs[0]$$;
      object_scope=NULL;
      objs_ptr=1;
      flags=NULL_CHECK|SAVE_VAL|USED|EDIT_VAL;
      reference=0;
      desc="network monitor object that contains full specs for what to record and where to get it";
      init_from=NULL;
     };
    };
    types {
     name="types";
     el_typ=DynEnumType;
     el_def=0;
    };
    args {
     name="args";
     el_typ=ProgVar;
     el_def=0;
     ProgVar @[0] {
      name="network";
      var_type=T_Object;
      object_type=Network;
      object_val=$.networks[0]$;
      object_scope=NULL;
      objs_ptr=0;
      flags=CTRL_PANEL|NULL_CHECK|SAVE_VAL|USED|EDIT_VAL|PGRM_ARG;
      reference=0;
      desc="network to get data from";
      init_from=NULL;
     };
    };
    vars {
     name="vars";
     el_typ=ProgVar;
     el_def=0;
     ProgVar @[0] {
      name="epoch_mon_data";
      var_type=T_Object;
      object_type=DataTable;
      object_val=$.data.gp[1][1]$;
      object_scope=NULL;
      objs_ptr=0;
      flags=CTRL_PANEL|NULL_CHECK|SAVE_VAL|USED|EDIT_VAL;
      reference=0;
      desc="data table to write the epoch data to";
      init_from=NULL;
     };
     ProgVar @[1] {
      name="epoch_timer";
      var_type=T_Object;
      object_type=TimeUsed;
      object_val=$.networks[0].epoch_time$;
      object_scope=NULL;
      objs_ptr=0;
      flags=NULL_CHECK|SAVE_VAL|USED|EDIT_VAL;
      reference=0;
      desc="pointer to the network's epoch-level timer, to record how long it took to process an epoch";
      init_from=NULL;
     };
    };
    functions {
     name="functions";
     el_typ=Function;
     el_def=0;
    };
    init_code {
     name="init_code";
     el_typ=ProgCode;
     el_def=0;
     AssignExpr @[0] {
      name="AssignExpr_epochtimernetworkepochtime";
      desc="get the epoch timer from current network";
      flags=CAN_REVERT_TO_CODE;
      code_string="epoch_timer = network.epoch_time";
      result_var=.programs.gp[0][6].vars[1]$$;
      expr {
       expr="network.epoch_time";
      };
     };
     MethodCall @[1] {
      name="MethodCall_epochnetmonSetDa_hmondatanetwork";
      desc="set data and network on NetMonitor object";
      flags=CAN_REVERT_TO_CODE;
      code_string="epoch_netmon->SetDataNetwork(epoch_mon_data, network)";
      result_var=NULL;
      obj=.programs.gp[0][6].objs_vars[0]$$;
      method=NetMonitor::SetDataNetwork;
      meth_args {
       name="meth_args";
       el_typ=ProgArg;
       el_def=0;
       ProgArg @[0] {
	arg_type=DataTable_ptr;
	type="DataTable*";
	name="dt";
	required=1;
	def_val=;
	prev_expr=;
	expr {
	 expr="epoch_mon_data";
	};
       };
       ProgArg @[1] {
	arg_type=Network_ptr;
	type="Network*";
	name="net";
	required=1;
	def_val=;
	prev_expr=;
	expr {
	 expr="network";
	};
       };
      };
      meth_sig="void SetDataNetwork(DataTable* dt, Network* net)";
      meth_desc=" set both the data table and network -- convenient for programs -- calls ResetDataTableCols too -- don't call if columns are manually added or this is adding additional rows to a table";
     };
     MethodCall @[2] {
      name="MethodCall_epochnetmonCheckConfigfalse";
      desc="check configuration and emit errors/warnings for problems";
      flags=CAN_REVERT_TO_CODE;
      code_string="epoch_netmon->CheckConfig(false)";
      result_var=NULL;
      obj=$.programs.gp[0][6].objs_vars[0]$;
      method=taBase::CheckConfig;
      meth_args {
       name="meth_args";
       el_typ=ProgArg;
       el_def=0;
       ProgArg @[0] {
	arg_type=bool;
	type="bool";
	name="quiet";
	required=0;
	def_val="false";
	prev_expr=;
	expr {
	 expr="false";
	};
       };
      };
      meth_sig="bool CheckConfig(bool quiet = false)";
      meth_desc=" check the configuration of this object and all its children (defaults to no confirm of success)";
     };
     MethodCall @[3] {
      name="MethodCall_epochnetmonUpdateMonitorstrue";
      desc="update the monitor items and data schema based on current settings of NetMonitor";
      flags=CAN_REVERT_TO_CODE;
      code_string="epoch_netmon->UpdateMonitors(true)";
      result_var=NULL;
      obj=$.programs.gp[0][6].objs_vars[0]$;
      method=NetMonitor::UpdateMonitors;
      meth_args {
       name="meth_args";
       el_typ=ProgArg;
       el_def=0;
       ProgArg @[0] {
	arg_type=bool;
	type="bool";
	name="reset_first";
	required=0;
	def_val="false";
	prev_expr=;
	expr {
	 expr="true";
	};
       };
      };
      meth_sig="void UpdateMonitors(bool reset_first = false)";
      meth_desc=" old name for UpdateDataTable";
     };
    };
    prog_code {
     name="prog_code";
     el_typ=ProgCode;
     el_def=0;
     MethodCall @[0] {
      name="MethodCall_epochmondataAddBlankRow";
      desc="add a new blank row to the data";
      flags=CAN_REVERT_TO_CODE;
      code_string="epoch_mon_data->AddBlankRow()";
      result_var=NULL;
      obj=.programs.gp[0][6].vars[0]$$;
      method=DataTable::AddBlankRow;
      meth_args {
       name="meth_args";
       el_typ=ProgArg;
       el_def=0;
      };
      meth_sig="int AddBlankRow()";
      meth_desc=" add a new row to the data table, sets read (source) and write (sink) index to this last row (as in ReadItem or WriteItem), so that subsequent data routines refer to this new row, and returns row ";
     };
     MethodCall @[1] {
      name="MethodCall_epochnetmonGetMonVals";
      desc="get the new monitor data and stor it into the data table -- this does the main job here";
      flags=CAN_REVERT_TO_CODE;
      code_string="epoch_netmon->GetMonVals()";
      result_var=NULL;
      obj=$.programs.gp[0][6].objs_vars[0]$;
      method=NetMonitor::GetMonVals;
      meth_args {
       name="meth_args";
       el_typ=ProgArg;
       el_def=0;
      };
      meth_sig="void GetMonVals()";
      meth_desc=" get all the values and store in current row of data table -- call in program to get new data";
     };
     AssignExpr @[2] {
      name="AssignExpr_epochtimernetworkepochtime";
      desc="get the epoch timer from current network";
      flags=CAN_REVERT_TO_CODE;
      code_string="epoch_timer = network.epoch_time";
      result_var=$.programs.gp[0][6].vars[1]$;
      expr {
       expr="network.epoch_time";
      };
     };
     MethodCall @[3] {
      name="MethodCall_epochmondataSetV_csepochtimetot1";
      desc="set the total time to compute the epoch (epoch_time_tot -- wall clock time) to time used data from network timer";
      flags=CAN_REVERT_TO_CODE;
      code_string="epoch_mon_data->SetValColName(epoch_timer.used.GetTotSecs(), \"epoch_time_tot\", -1, )";
      result_var=NULL;
      obj=$.programs.gp[0][6].vars[0]$;
      method=DataTable::SetValColName;
      meth_args {
       name="meth_args";
       el_typ=ProgArg;
       el_def=0;
       ProgArg @[0] {
	arg_type=const_Variant_ref;
	type="Variant&";
	name="val";
	required=1;
	def_val=;
	prev_expr=;
	expr {
	 expr="epoch_timer.used.GetTotSecs()";
	};
       };
       ProgArg @[1] {
	arg_type=const_taString_ref;
	type="taString&";
	name="col_name";
	required=1;
	def_val="\"\"";
	prev_expr=;
	expr {
	 expr="\"epoch_time_tot\"";
	};
       };
       ProgArg @[2] {
	arg_type=int;
	type="int";
	name="row";
	required=1;
	def_val=;
	prev_expr=;
	expr {
	 expr="-1";
	};
       };
       ProgArg @[3] {
	arg_type=bool;
	type="bool";
	name="quiet";
	required=0;
	def_val="false";
	prev_expr=;
	expr {
	 expr=;
	};
       };
      };
      meth_sig="bool SetValColName(Variant& val, taString& col_name, int row, bool quiet = false)";
      meth_desc=" set data of scalar type, in Variant form (any data type, use for Programs), for given column name, row; returns 'true' if valid access and set is successful -- quiet = fail quietly";
     };
     MethodCall @[4] {
      name="MethodCall_epochmondataSetV_csepochtimeusr1";
      desc="set the user process time (cpu time for this process, epoch_time_usr) to time used data from network timer";
      flags=CAN_REVERT_TO_CODE;
      code_string="epoch_mon_data->SetValColName(epoch_timer.used.GetUsrSecs(), \"epoch_time_usr\", -1, )";
      result_var=NULL;
      obj=$.programs.gp[0][6].vars[0]$;
      method=DataTable::SetValColName;
      meth_args {
       name="meth_args";
       el_typ=ProgArg;
       el_def=0;
       ProgArg @[0] {
	arg_type=const_Variant_ref;
	type="Variant&";
	name="val";
	required=1;
	def_val=;
	prev_expr=;
	expr {
	 expr="epoch_timer.used.GetUsrSecs()";
	};
       };
       ProgArg @[1] {
	arg_type=const_taString_ref;
	type="taString&";
	name="col_name";
	required=1;
	def_val="\"\"";
	prev_expr=;
	expr {
	 expr="\"epoch_time_usr\"";
	};
       };
       ProgArg @[2] {
	arg_type=int;
	type="int";
	name="row";
	required=1;
	def_val=;
	prev_expr=;
	expr {
	 expr="-1";
	};
       };
       ProgArg @[3] {
	arg_type=bool;
	type="bool";
	name="quiet";
	required=0;
	def_val="false";
	prev_expr=;
	expr {
	 expr=;
	};
       };
      };
      meth_sig="bool SetValColName(Variant& val, taString& col_name, int row, bool quiet = false)";
      meth_desc=" set data of scalar type, in Variant form (any data type, use for Programs), for given column name, row; returns 'true' if valid access and set is successful -- quiet = fail quietly";
     };
     MethodCall @[5] {
      name="MethodCall_epochmondataWriteClose";
      desc="update after writing new data to monitor data table";
      flags=CAN_REVERT_TO_CODE;
      code_string="epoch_mon_data->WriteClose()";
      result_var=NULL;
      obj=$.programs.gp[0][6].vars[0]$;
      method=DataTable::WriteClose;
      meth_args {
       name="meth_args";
       el_typ=ProgArg;
       el_def=0;
      };
      meth_sig="void WriteClose()";
      meth_desc=" closes up a write operation -- call when done writing data -- performs any post-writing cleanup/closing of files, etc";
     };
    };
    step_prog=NULL;
    step_n=1;
    doc {
     name="doc";
     desc=;
     web_doc=0;
     wiki=;
     url="local";
     full_url="local";
     text_size=1;
     text=;
     html_text=;
    };
   };
   Program @[7] {
    UserDataItem_List @*(.user_data_) {
     name=;
     el_typ=UserData_DocLink;
     el_def=0;
     UserData_DocLink @[0] {name="DocLink": doc=.programs.gp[0][7].doc$$: };
    };
    name="SaveWeights";
    short_nm="SvWts";
    tags="Network, Weights";
    desc="save network's current weight values to file using WriteWeights function, with file name based on project name + batch + epoch values";
    version {
     major=0;
     minor=0;
     step=0;
    };
    author=;
    email=;
    flags=NO_STOP_STEP;
    stop_step_cond {
     expr=;
    };
    objs {
     name="objs";
     el_typ=taNBase;
     el_def=0;
    };
    objs_vars {
     name="objs_vars";
     el_typ=ProgVar;
     el_def=0;
    };
    types {
     name="types";
     el_typ=DynEnumType;
     el_def=0;
    };
    args {
     name="args";
     el_typ=ProgVar;
     el_def=0;
     ProgVar @[0] {
      name="network";
      var_type=T_Object;
      object_type=Network;
      object_val=$.networks[0]$;
      object_scope=NULL;
      objs_ptr=0;
      flags=CTRL_PANEL|NULL_CHECK|SAVE_VAL|USED|EDIT_VAL|PGRM_ARG;
      reference=0;
      desc=;
      init_from=NULL;
     };
    };
    vars {
     name="vars";
     el_typ=ProgVar;
     el_def=0;
     ProgVar @[0] {
      name="output_weights_file";
      var_type=T_String;
      string_val=;
      object_scope=NULL;
      flags=CTRL_PANEL|CTRL_READ_ONLY|NULL_CHECK|SAVE_VAL|USED;
      reference=0;
      desc="weights file for loading";
      init_from=$.programs[0]$;
     };
     ProgVar @[1] {
      name="tag";
      var_type=T_String;
      string_val="_gui";
      object_scope=NULL;
      flags=CTRL_PANEL|NULL_CHECK|SAVE_VAL|USED|EDIT_VAL;
      reference=0;
      desc="user-provided tag (startup script will set this!)";
      init_from=NULL;
     };
     ProgVar @[2] {
      name="wts_subdir";
      var_type=T_String;
      string_val="weights";
      object_scope=NULL;
      flags=CTRL_PANEL|NULL_CHECK|SAVE_VAL|EDIT_VAL;
      reference=0;
      desc="user-provided subdirectory to save weights in";
      init_from=NULL;
     };
     ProgVar @[3] {
      name="fname";
      var_type=T_String;
      string_val=;
      object_scope=NULL;
      flags=CTRL_PANEL|CTRL_READ_ONLY|NULL_CHECK|SAVE_VAL|USED|EDIT_VAL;
      reference=0;
      desc="final generated file name -- do not edit!";
      init_from=NULL;
     };
     ProgVar @[4] {
      name="epoch_str";
      var_type=T_String;
      string_val="0000";
      object_scope=NULL;
      flags=NULL_CHECK|SAVE_VAL|USED|EDIT_VAL;
      reference=0;
      desc="string rep of epoch with leading zeros";
      init_from=NULL;
     };
     ProgVar @[5] {
      name="batch_str";
      var_type=T_String;
      string_val="00";
      object_scope=NULL;
      flags=NULL_CHECK|SAVE_VAL|USED|EDIT_VAL;
      reference=0;
      desc="string rep of batch with leading zeros";
      init_from=NULL;
     };
     ProgVar @[6] {
      name="final_tag";
      var_type=T_String;
      string_val="_gui.00_0000";
      object_scope=NULL;
      flags=NULL_CHECK|SAVE_VAL|USED|EDIT_VAL;
      reference=0;
      desc="batch + epoch";
      init_from=NULL;
     };
    };
    functions {
     name="functions";
     el_typ=Function;
     el_def=0;
    };
    init_code {
     name="init_code";
     el_typ=ProgCode;
     el_def=0;
    };
    prog_code {
     name="prog_code";
     el_typ=ProgCode;
     el_def=0;
     If @[0] {
      name="If_iftaMiscdmemproc0";
      desc=;
      flags=CAN_REVERT_TO_CODE;
      code_string="if (taMisc::dmem_proc > 0)";
      cond {
       expr="taMisc::dmem_proc > 0";
      };
      true_code {
       name="true_code";
       el_typ=ProgCode;
       el_def=0;
       ReturnExpr @[0] {
	name="ReturnExpr_return";
	desc=;
	flags=CAN_REVERT_TO_CODE;
	code_string="return ";
	expr {
	 expr=;
	};
       };
      };
     };
     MiscCall @[1] {
      name="MiscCall_batchstrtaMiscLe_osnetworkbatch2";
      desc="get current batch counter for file name, with leading zeros to length 3";
      flags=CAN_REVERT_TO_CODE;
      code_string="batch_str = taMisc::LeadingZeros(network.batch, 2)";
      result_var=.programs.gp[0][7].vars[5]$$;
      object_type=taMisc;
      method=taMisc::LeadingZeros;
      meth_args {
       name="meth_args";
       el_typ=ProgArg;
       el_def=0;
       ProgArg @[0] {
	arg_type=int;
	type="int";
	name="num";
	required=1;
	def_val=;
	prev_expr=;
	expr {
	 expr="network.batch";
	};
       };
       ProgArg @[1] {
	arg_type=int;
	type="int";
	name="len";
	required=1;
	def_val=;
	prev_expr=;
	expr {
	 expr="2";
	};
       };
      };
     };
     MiscCall @[2] {
      name="MiscCall_epochstrtaMiscLe_osnetworkepoch4";
      desc="get current epoch counter with leading zeros to length 4";
      flags=CAN_REVERT_TO_CODE;
      code_string="epoch_str = taMisc::LeadingZeros(network.epoch, 4)";
      result_var=.programs.gp[0][7].vars[4]$$;
      object_type=taMisc;
      method=taMisc::LeadingZeros;
      meth_args {
       name="meth_args";
       el_typ=ProgArg;
       el_def=0;
       ProgArg @[0] {
	arg_type=int;
	type="int";
	name="num";
	required=1;
	def_val=;
	prev_expr=;
	expr {
	 expr="network.epoch";
	};
       };
       ProgArg @[1] {
	arg_type=int;
	type="int";
	name="len";
	required=1;
	def_val=;
	prev_expr=;
	expr {
	 expr="4";
	};
       };
      };
     };
     AssignExpr @[3] {
      name="AssignExpr_finaltagtagbatchstrepochstr";
      desc="string 'tag' to identify the batch, epoch, and other user id info for the weights";
      flags=CAN_REVERT_TO_CODE;
      code_string="final_tag = tag + \".\" + batch_str + \"_\" + epoch_str";
      result_var=.programs.gp[0][7].vars[6]$$;
      expr {
       expr="tag + \".\" + batch_str + \"_\" + epoch_str";
      };
     };
     AssignExpr @[4] {
      name="AssignExpr_fnameoutputweightsfile";
      desc="get a file name based on the project's current file name, for saving the weights";
      flags=CAN_REVERT_TO_CODE;
      code_string="fname = output_weights_file";
      result_var=.programs.gp[0][7].vars[3]$$;
      expr {
       expr="output_weights_file";
      };
     };
     MethodCall @[5] {
      name="MethodCall_networkSaveWeigh_meNetworkNETFMT";
      desc="save the weights to that file name";
      flags=CAN_REVERT_TO_CODE;
      code_string="network->SaveWeights(fname, Network::NET_FMT)";
      result_var=NULL;
      obj=.programs.gp[0][7].args[0]$$;
      method=Network::SaveWeights;
      meth_args {
       name="meth_args";
       el_typ=ProgArg;
       el_def=0;
       ProgArg @[0] {
	arg_type=const_taString_ref;
	type="taString&";
	name="fname";
	required=0;
	def_val="\"\"";
	prev_expr=;
	expr {
	 expr="fname";
	};
       };
       ProgArg @[1] {
	arg_type=Network::WtSaveFormat;
	type="Network::WtSaveFormat";
	name="fmt";
	required=0;
	def_val="Network::NET_FMT";
	prev_expr=;
	expr {
	 expr="Network::NET_FMT";
	};
       };
      };
      meth_sig="void SaveWeights(taString& fname, Network::WtSaveFormat fmt = NET_FMT)";
      meth_desc=" write weight values out in a simple ordered list of weights (optionally in binary fmt) (leave fname empty to pull up file chooser)";
     };
    };
    step_prog=NULL;
    step_n=1;
    doc {
     name="doc";
     desc=;
     web_doc=0;
     wiki=;
     url="local";
     full_url="local";
     text_size=1;
     text=;
     html_text=;
    };
   };
   Program @[8] {
    UserDataItem_List @*(.user_data_) {
     name=;
     el_typ=UserData_DocLink;
     el_def=0;
     UserData_DocLink @[0] {name="DocLink": doc=.programs.gp[0][8].doc$$: };
    };
    name="ExportData";
    short_nm="ExData";
    tags=;
    desc="exports data to a CSV file";
    version {
     major=0;
     minor=0;
     step=0;
    };
    author=;
    email=;
    flags=0;
    stop_step_cond {
     expr=;
    };
    objs {
     name="objs";
     el_typ=taNBase;
     el_def=0;
    };
    objs_vars {
     name="objs_vars";
     el_typ=ProgVar;
     el_def=0;
    };
    types {
     name="types";
     el_typ=DynEnumType;
     el_def=0;
    };
    args {
     name="args";
     el_typ=ProgVar;
     el_def=0;
     ProgVar @[0] {
      name="FinalData";
      var_type=T_Object;
      object_type=DataTable;
      object_val=$.data.gp[1][0]$;
      object_scope=NULL;
      objs_ptr=0;
      flags=CTRL_PANEL|NULL_CHECK|SAVE_VAL|USED|EDIT_VAL|PGRM_ARG;
      reference=0;
      desc=;
      init_from=NULL;
     };
     ProgVar @[1] {
      name="output_file";
      var_type=T_String;
      string_val=;
      object_scope=NULL;
      flags=CTRL_PANEL|NULL_CHECK|SAVE_VAL|USED|EDIT_VAL|PGRM_ARG;
      reference=0;
      desc=;
      init_from=NULL;
     };
    };
    vars {
     name="vars";
     el_typ=ProgVar;
     el_def=0;
     ProgVar @[0] {
      name="output_file2";
      var_type=T_String;
      string_val=;
      object_scope=NULL;
      flags=CTRL_PANEL|CTRL_READ_ONLY|NULL_CHECK|SAVE_VAL;
      reference=0;
      desc="output file of export data";
      init_from=$.programs[0]$;
     };
    };
    functions {
     name="functions";
     el_typ=Function;
     el_def=0;
    };
    init_code {
     name="init_code";
     el_typ=ProgCode;
     el_def=0;
    };
    prog_code {
     name="prog_code";
     el_typ=ProgCode;
     el_def=0;
     RegisterArgs @[0] {
      name="RegisterArgs_RegisterArgs";
      desc="This is KEY!!! actually processes all args, including those from ProgVarFmArg guys below";
      flags=CAN_REVERT_TO_CODE;
      code_string="Register Args";
     };
     ProgVarFmArg @[1] {
      name="ProgVarFmArg_SetVaroutputfile_omArgoutputfile";
      desc=;
      flags=VERBOSE|CAN_REVERT_TO_CODE;
      code_string="Set Var:output_file in Program:ExportData from Arg:output_file";
      prog=$.programs.gp[0][8]$;
      var_name="output_file";
      arg_name="output_file";
     };
     PrintExpr @[2] {
      name="PrintExpr_PrintfromExportD_tfileoutputfile";
      desc=;
      flags=CAN_REVERT_TO_CODE;
      code_string="Print \"from ExportData output_file: \" << output_file";
      expr {
       expr="\"from ExportData output_file: \" << output_file";
      };
      debug=0;
     };
     MethodCall @[3] {
      name="MethodCall_FinalDataExportD_utfileFinalData";
      desc=;
      flags=VERBOSE|CAN_REVERT_TO_CODE;
      code_string="FinalData->ExportData(output_file, FinalData, , )";
      result_var=NULL;
      obj=.programs.gp[0][8].args[0]$$;
      method=DataTable::ExportData;
      meth_args {
       name="meth_args";
       el_typ=ProgArg;
       el_def=0;
       ProgArg @[0] {
	arg_type=const_taString_ref;
	type="taString&";
	name="fname";
	required=0;
	def_val="\"\"";
	prev_expr=;
	expr {
	 expr="output_file";
	};
       };
       ProgArg @[1] {
	arg_type=DataTable::Delimiters;
	type="DataTable::Delimiters";
	name="delim";
	required=0;
	def_val="DataTable::COMMA";
	prev_expr=;
	expr {
	 expr="FinalData";
	};
       };
       ProgArg @[2] {
	arg_type=bool;
	type="bool";
	name="quote_str";
	required=0;
	def_val="true";
	prev_expr=;
	expr {
	 expr=;
	};
       };
       ProgArg @[3] {
	arg_type=bool;
	type="bool";
	name="headers";
	required=0;
	def_val="true";
	prev_expr=;
	expr {
	 expr=;
	};
       };
      };
      meth_sig="void ExportData(taString& fname, DataTable::Delimiters delim = COMMA, bool quote_str = true, bool headers = true)";
      meth_desc=" exports data with given delimiter and string quoting format options in a format suitable for importing into other applications (spreadsheets, etc) -- does NOT include the emergent native header/data row markers and extended header info, so is not good for loading back into emergent (use SaveData for that)";
     };
    };
    step_prog=NULL;
    step_n=1;
    doc {
     name="doc";
     desc=;
     web_doc=0;
     wiki=;
     url="local";
     full_url="local";
     text_size=1;
     text=;
     html_text=;
    };
   };
   Program @[9] {
    UserDataItem_List @*(.user_data_) {
     name=;
     el_typ=UserData_DocLink;
     el_def=0;
     UserData_DocLink @[0] {name="DocLink": doc=.programs.gp[0][9].doc$$: };
    };
    name="ImportData";
    short_nm="impData";
    tags=;
    desc="imports data from a DAT file";
    version {
     major=0;
     minor=0;
     step=0;
    };
    author=;
    email=;
    flags=0;
    stop_step_cond {
     expr=;
    };
    objs {
     name="objs";
     el_typ=taNBase;
     el_def=0;
    };
    objs_vars {
     name="objs_vars";
     el_typ=ProgVar;
     el_def=0;
    };
    types {
     name="types";
     el_typ=DynEnumType;
     el_def=0;
    };
    args {
     name="args";
     el_typ=ProgVar;
     el_def=0;
     ProgVar @[0] {
      name="NewData";
      var_type=T_Object;
      object_type=DataTable;
      object_val=$.data.gp[0][1]$;
      object_scope=NULL;
      objs_ptr=0;
      flags=CTRL_PANEL|NULL_CHECK|SAVE_VAL|USED|EDIT_VAL|PGRM_ARG;
      reference=0;
      desc=;
      init_from=NULL;
     };
     ProgVar @[1] {
      name="inputFile";
      var_type=T_String;
      string_val=;
      object_scope=NULL;
      flags=CTRL_PANEL|NULL_CHECK|SAVE_VAL|USED|EDIT_VAL|PGRM_ARG;
      reference=0;
      desc=;
      init_from=NULL;
     };
    };
    vars {
     name="vars";
     el_typ=ProgVar;
     el_def=0;
    };
    functions {
     name="functions";
     el_typ=Function;
     el_def=0;
    };
    init_code {
     name="init_code";
     el_typ=ProgCode;
     el_def=0;
    };
    prog_code {
     name="prog_code";
     el_typ=ProgCode;
     el_def=0;
     MethodCall @[0] {
      name="MethodCall_NewDataImportDatainputFile";
      desc=;
      flags=CAN_REVERT_TO_CODE;
      code_string="NewData->ImportData(inputFile, , , )";
      result_var=NULL;
      obj=.programs.gp[0][9].args[0]$$;
      method=DataTable::ImportData;
      meth_args {
       name="meth_args";
       el_typ=ProgArg;
       el_def=0;
       ProgArg @[0] {
	arg_type=const_taString_ref;
	type="taString&";
	name="fname";
	required=0;
	def_val="\"\"";
	prev_expr=;
	expr {
	 expr="inputFile";
	};
       };
       ProgArg @[1] {
	arg_type=bool;
	type="bool";
	name="headers";
	required=0;
	def_val="true";
	prev_expr=;
	expr {
	 expr=;
	};
       };
       ProgArg @[2] {
	arg_type=DataTable::LoadDelimiters;
	type="DataTable::LoadDelimiters";
	name="delim";
	required=0;
	def_val="DataTable::LD_AUTO";
	prev_expr=;
	expr {
	 expr=;
	};
       };
       ProgArg @[3] {
	arg_type=DataTable::LoadQuotes;
	type="DataTable::LoadQuotes";
	name="quote_str";
	required=0;
	def_val="DataTable::LQ_AUTO";
	prev_expr=;
	expr {
	 expr=;
	};
       };
      };
      meth_sig="void ImportData(taString& fname, bool headers = true, DataTable::LoadDelimiters delim = LD_AUTO, DataTable::LoadQuotes quote_str = LQ_AUTO)";
      meth_desc=" imports externally-generated data in delimited text file format -- if headers is selected, then first row is treated as column headers -- auto defaults are typically fine (see also Load Any Data or Load Any Data Append -- same functionality with all AUTO defaults)";
     };
    };
    step_prog=NULL;
    step_n=1;
    doc {
     name="doc";
     desc=;
     web_doc=0;
     wiki=;
     url="local";
     full_url="local";
     text_size=1;
     text=;
     html_text=;
    };
   };
   Program @[10] {
    UserDataItem_List @*(.user_data_) {
     name=;
     el_typ=UserData_DocLink;
     el_def=0;
     UserData_DocLink @[0] {name="DocLink": doc=.programs.gp[0][10].doc$$: };
    };
    name="LoadWeights";
    short_nm="LWghts";
    tags=;
    desc=;
    version {
     major=0;
     minor=0;
     step=0;
    };
    author=;
    email=;
    flags=0;
    stop_step_cond {
     expr=;
    };
    objs {
     name="objs";
     el_typ=taNBase;
     el_def=0;
    };
    objs_vars {
     name="objs_vars";
     el_typ=ProgVar;
     el_def=0;
    };
    types {
     name="types";
     el_typ=DynEnumType;
     el_def=0;
    };
    args {
     name="args";
     el_typ=ProgVar;
     el_def=0;
     ProgVar @[0] {
      name="input_weights_file";
      var_type=T_String;
      string_val="/home/jwgorman/Files1/SolarNetwork/emergent/weights/consumption_bp7f_nogui_20140802a_test2_gui.00_0000.wts.gz";
      object_scope=NULL;
      flags=CTRL_PANEL|NULL_CHECK|SAVE_VAL|USED|EDIT_VAL|PGRM_ARG;
      reference=0;
      desc=;
      init_from=NULL;
     };
     ProgVar @[1] {
      name="network";
      var_type=T_Object;
      object_type=Network;
      object_val=$.networks[0]$;
      object_scope=NULL;
      objs_ptr=0;
      flags=CTRL_PANEL|NULL_CHECK|SAVE_VAL|USED|EDIT_VAL|PGRM_ARG;
      reference=0;
      desc=;
      init_from=NULL;
     };
    };
    vars {
     name="vars";
     el_typ=ProgVar;
     el_def=0;
     ProgVar @[0] {
      name="input_weights_file";
      var_type=T_String;
      string_val=;
      object_scope=NULL;
      flags=CTRL_PANEL|CTRL_READ_ONLY|NULL_CHECK|SAVE_VAL|USED;
      reference=0;
      desc="weights file for loading";
      init_from=$.programs[0]$;
     };
    };
    functions {
     name="functions";
     el_typ=Function;
     el_def=0;
    };
    init_code {
     name="init_code";
     el_typ=ProgCode;
     el_def=0;
    };
    prog_code {
     name="prog_code";
     el_typ=ProgCode;
     el_def=0;
     MethodCall @[0] {
      name="MethodCall_networkLoadWeights";
      desc="load weights from that file name";
      flags=VERBOSE;
      code_string=;
      result_var=NULL;
      obj=.programs.gp[0][10].args[1]$$;
      method=Network::LoadWeights;
      meth_args {
       name="meth_args";
       el_typ=ProgArg;
       el_def=0;
       ProgArg @[0] {
	arg_type=const_taString_ref;
	type="taString&";
	name="fname";
	required=0;
	def_val="\"\"";
	prev_expr=;
	expr {
	 expr=;
	};
       };
       ProgArg @[1] {
	arg_type=bool;
	type="bool";
	name="quiet";
	required=0;
	def_val="false";
	prev_expr=;
	expr {
	 expr=;
	};
       };
      };
      meth_sig="bool LoadWeights(taString& fname, bool quiet = false)";
      meth_desc=" read weight values in from a simple ordered list of weights (fmt is read from file) (leave fname empty to pull up file chooser)";
     };
    };
    step_prog=NULL;
    step_n=1;
    doc {
     name="doc";
     desc=;
     web_doc=0;
     wiki=;
     url="local";
     full_url="local";
     text_size=1;
     text=;
     html_text=;
    };
   };
  };
  Program_Group @.gp[1] {
   name="BpAll_Test";
   el_typ=Program;
   el_def=0;
   tags="Bp, Std, All, Test";
   desc="The full set of programs for testing a standard Backpropagation network (starting with Epoch)";
   debug_mode=0;
   Program @[0] {
    UserDataItem_List @*(.user_data_) {
     name=;
     el_typ=UserData_DocLink;
     el_def=0;
     UserData_DocLink @[0] {name="DocLink": doc=.programs.gp[1][0].doc$$: };
    };
    name="BpEpochTest";
    short_nm="pchTst";
    tags="Bp, Std";
    desc="iterates over all of the items in a data table and calls BpTrial process on them";
    version {
     major=0;
     minor=0;
     step=0;
    };
    author=;
    email=;
    flags=0;
    stop_step_cond {
     expr=;
    };
    objs {
     name="objs";
     el_typ=taNBase;
     el_def=0;
    };
    objs_vars {
     name="objs_vars";
     el_typ=ProgVar;
     el_def=0;
    };
    types {
     name="types";
     el_typ=DynEnumType;
     el_def=0;
    };
    args {
     name="args";
     el_typ=ProgVar;
     el_def=0;
     ProgVar @[0] {
      name="network";
      var_type=T_Object;
      object_type=BpNetwork;
      object_val=$.networks[0]$;
      object_scope=NULL;
      objs_ptr=0;
      flags=CTRL_PANEL|NULL_CHECK|SAVE_VAL|USED|EDIT_VAL|PGRM_ARG;
      reference=0;
      desc="network to operate on";
      init_from=NULL;
     };
    };
    vars {
     name="vars";
     el_typ=ProgVar;
     el_def=0;
     ProgVar @[0] {
      name="input_data";
      var_type=T_Object;
      object_type=DataTable;
      object_val=$.data.gp[0][1]$;
      object_scope=NULL;
      objs_ptr=0;
      flags=CTRL_PANEL|NULL_CHECK|SAVE_VAL|USED|EDIT_VAL;
      reference=0;
      desc="table of patterns to present to the network, one row at a time";
      init_from=NULL;
     };
     ProgVar @[1] {
      name="output_file";
      var_type=T_String;
      string_val=;
      object_scope=NULL;
      flags=CTRL_PANEL|CTRL_READ_ONLY|NULL_CHECK|SAVE_VAL|USED;
      reference=0;
      desc="output file of export data";
      init_from=$.programs[0]$;
     };
     ProgVar @[2] {
      name="data_loop_order";
      var_type=T_HardEnum;
      int_val=0;
      object_scope=NULL;
      hard_enum_type=DataLoop::Order;
      flags=CTRL_PANEL|NULL_CHECK|SAVE_VAL|USED|EDIT_VAL;
      reference=0;
      desc="controls the order in which events (rows of the input data datatable) are presented to the network
(SEQUENTIAL, PERMUTED, RANDOM)";
      init_from=NULL;
     };
     ProgVar @[3] {
      name="trial";
      var_type=T_Int;
      int_val=0;
      object_scope=NULL;
      flags=CTRL_PANEL|CTRL_READ_ONLY|NULL_CHECK|SAVE_VAL|USED|EDIT_VAL;
      reference=0;
      desc="current trial (event) within the epoch -- increments automatically";
      init_from=NULL;
     };
     ProgVar @[4] {
      name="trial_mon_data";
      var_type=T_Object;
      object_type=DataTable;
      object_val=.data.gp[1][2]$$;
      object_scope=NULL;
      objs_ptr=0;
      flags=CTRL_PANEL|NULL_CHECK|SAVE_VAL|USED|EDIT_VAL;
      reference=0;
      desc="trial-level output data -- we reset it every epoch by default, so it just contains last epoch of data";
      init_from=NULL;
     };
     ProgVar @[5] {
      name="epoch_timer";
      var_type=T_Object;
      object_type=TimeUsed;
      object_val=$.networks[0].epoch_time$;
      object_scope=NULL;
      objs_ptr=0;
      flags=NULL_CHECK|SAVE_VAL|USED|EDIT_VAL;
      reference=0;
      desc="timer to record time required to perform one epoch of processing (object is on network -- this is a pointer to it)";
      init_from=NULL;
     };
     ProgVar @[6] {
      name="data_loop_index";
      var_type=T_Int;
      int_val=3792;
      object_scope=NULL;
      flags=NULL_CHECK|SAVE_VAL|USED|EDIT_VAL;
      reference=0;
      desc="index counter for the looping over items in the input_data datatable (not always the same as trial counter, depending on distributed memory computation)";
      init_from=NULL;
     };
    };
    functions {
     name="functions";
     el_typ=Function;
     el_def=0;
    };
    init_code {
     name="init_code";
     el_typ=ProgCode;
     el_def=0;
     NetCounterInit @[0] {
      name="NetCounterInit_NetCounterInittrial";
      desc="initialize trial counter (local variable and in the network)";
      flags=CAN_REVERT_TO_CODE;
      code_string="Net Counter Init: trial";
      network_var=.programs.gp[1][0].args[0]$$;
      local_ctr_var=.programs.gp[1][0].vars[3]$$;
      counter=Network::trial;
      update_after=0;
     };
     AssignExpr @[1] {
      name="AssignExpr_epochtimernetworkepochtime";
      desc="get pointer to epoch timer object on network";
      flags=CAN_REVERT_TO_CODE;
      code_string="epoch_timer = network.epoch_time";
      result_var=.programs.gp[1][0].vars[5]$$;
      expr {
       expr="network.epoch_time";
      };
     };
    };
    prog_code {
     name="prog_code";
     el_typ=ProgCode;
     el_def=0;
     NetCounterInit @[0] {
      name="NetCounterInit_NetCounterInittrial";
      desc="initialize trial counter (local variable and in the network)";
      flags=OFF;
      code_string=;
      network_var=$.programs.gp[1][0].args[0]$;
      local_ctr_var=$.programs.gp[1][0].vars[3]$;
      counter=Network::trial;
      update_after=0;
     };
     MemberAssign @[1] {
      name="MemberAssign_networktrainmodeNetworkTEST";
      desc="set to testing mode";
      flags=NEW_EL|CAN_REVERT_TO_CODE;
      code_string="network.train_mode = Network::TEST";
      obj=$.programs.gp[1][0].args[0]$;
      path="train_mode";
      expr {
       expr="Network::TEST";
      };
      update_after=0;
     };
     AssignExpr @[2] {
      name="AssignExpr_epochtimernetworkepochtime";
      desc="get pointer to epoch timer object on network";
      flags=CAN_REVERT_TO_CODE;
      code_string="epoch_timer = network.epoch_time";
      result_var=$.programs.gp[1][0].vars[5]$;
      expr {
       expr="network.epoch_time";
      };
     };
     MethodCall @[3] {
      name="MethodCall_epochtimerStartTimertrue";
      desc="start the epoch timer to record computation time per epoch";
      flags=CAN_REVERT_TO_CODE;
      code_string="epoch_timer->StartTimer(true)";
      result_var=NULL;
      obj=$.programs.gp[1][0].vars[5]$;
      method=TimeUsed::StartTimer;
      meth_args {
       name="meth_args";
       el_typ=ProgArg;
       el_def=0;
       ProgArg @[0] {
	arg_type=bool;
	type="bool";
	name="reset_used";
	required=0;
	def_val="true";
	prev_expr=;
	expr {
	 expr="true";
	};
       };
      };
      meth_sig="void StartTimer(bool reset_used = true)";
      meth_desc=" record the current time as the starting time, and optionally reset the time used information";
     };
     MethodCall @[4] {
      name="MethodCall_trialmondataResetData";
      desc="reset trial-level monitor data every epoch, so it reflects only the most recent epoch's worth of data (turn flags OFF to accumulate trial data across entire training run)";
      flags=CAN_REVERT_TO_CODE;
      code_string="trial_mon_data->ResetData()";
      result_var=NULL;
      obj=.programs.gp[1][0].vars[4]$$;
      method=DataTable::ResetData;
      meth_args {
       name="meth_args";
       el_typ=ProgArg;
       el_def=0;
      };
      meth_sig="void ResetData()";
      meth_desc=" deletes all the data (rows), but keeps the column structure -- this cannot be undone!";
     };
     NetDataLoop @[5] {
      name="NetDataLoop_NetDataLoopSEQUE_ardatalooporder";
      desc="iterates over the events/rows of input_data, according to data_loop_order variable";
      flags=CAN_REVERT_TO_CODE;
      code_string="Net Data Loop (SEQUENTIAL):  table=input_data  index=data_loop_index  order_var=data_loop_order ";
      loop_code {
       name="loop_code";
       el_typ=ProgCode;
       el_def=0;
       ProgramCall @[0] {
	name="ProgramCall_BpTrialTestnetworkinputdata";
	desc="run the trial program, passing network and input_data";
	flags=CAN_REVERT_TO_CODE;
	code_string="BpTrialTest(network, input_data)";
	prog_args {
	 name="prog_args";
	 el_typ=ProgArg;
	 el_def=0;
	 ProgArg @[0] {
	  arg_type=BpNetwork;
	  type="BpNetwork*";
	  name="network";
	  required=1;
	  def_val=;
	  prev_expr=;
	  expr {
	   expr="network";
	  };
	 };
	 ProgArg @[1] {
	  arg_type=DataTable;
	  type="DataTable*";
	  name="input_data";
	  required=1;
	  def_val=;
	  prev_expr=;
	  expr {
	   expr="input_data";
	  };
	 };
	};
	target=.programs.gp[1][1]$$;
	targ_ld_init="*BpTrial*";
       };
       If @[1] {
	name="If_ifnetworkCompute_ightsTesttrial1";
	desc="test if it is time to update the weight values from delta weights (dWt) computed over trials";
	flags=CAN_REVERT_TO_CODE;
	code_string="if (network.Compute_Weights_Test(trial+1))";
	cond {
	 expr="network.Compute_Weights_Test(trial+1)";
	};
	true_code {
	 name="true_code";
	 el_typ=ProgCode;
	 el_def=0;
	 MethodCall @[0] {
	  name="MethodCall_networkComputeWeights";
	  desc="update the weight values based on changes computed by trial program";
	  flags=CAN_REVERT_TO_CODE;
	  code_string="network->Compute_Weights()";
	  result_var=NULL;
	  obj=$.programs.gp[1][0].args[0]$;
	  method=Network::Compute_Weights;
	  meth_args {
	   name="meth_args";
	   el_typ=ProgArg;
	   el_def=0;
	  };
	  meth_sig="void Compute_Weights()";
	  meth_desc=" update weights for whole net: calls DMem_SumDWts before doing update if in dmem mode";
	 };
	};
       };
      };
      data_var=.programs.gp[1][0].vars[0]$$;
      index_var=.programs.gp[1][0].vars[6]$$;
      order_var=.programs.gp[1][0].vars[2]$$;
      order=SEQUENTIAL;
      update_after=0;
      dmem_nprocs=1;
      dmem_this_proc=0;
      grouped=0;
      group_col 9 0="Group";
      group_index_var=NULL;
      group_order_var=NULL;
      group_order=PERMUTED;
      group_idx_list{       };
     };
     If @[6] {
      name="If_ifnetworkwtupdateNetworkBATCH";
      desc="if full batch mode, update only at end of epoch";
      flags=CAN_REVERT_TO_CODE;
      code_string="if (network.wt_update == Network::BATCH)";
      cond {
       expr="network.wt_update == Network::BATCH";
      };
      true_code {
       name="true_code";
       el_typ=ProgCode;
       el_def=0;
       MethodCall @[0] {
	name="MethodCall_networkComputeWeights";
	desc="final update of weights based on accumulated changes";
	flags=CAN_REVERT_TO_CODE;
	code_string="network->Compute_Weights()";
	result_var=NULL;
	obj=$.programs.gp[1][0].args[0]$;
	method=Network::Compute_Weights;
	meth_args {
	 name="meth_args";
	 el_typ=ProgArg;
	 el_def=0;
	};
	meth_sig="void Compute_Weights()";
	meth_desc=" update weights for whole net: calls DMem_SumDWts before doing update if in dmem mode";
       };
      };
     };
     MethodCall @[7] {
      name="MethodCall_networkComputeEpochStats";
      desc="network accumulates some core statistics over the epoch -- this finalizes that process and computes summary stats";
      flags=CAN_REVERT_TO_CODE;
      code_string="network->Compute_EpochStats()";
      result_var=NULL;
      obj=$.programs.gp[1][0].args[0]$;
      method=LeabraNetwork::Compute_EpochStats;
      meth_args {
       name="meth_args";
       el_typ=ProgArg;
       el_def=0;
      };
      meth_sig="void Compute_EpochStats()";
      meth_desc=" compute epoch-level statistics; calls DMem_ComputeAggs (if dmem) and EpochSSE -- specific algos may add more compute epoch-level statistics, including SSE, AvgExtRew and AvgCycles";
     };
     MethodCall @[8] {
      name="MethodCall_epochtimerEndTimer";
      desc="done with the computation in the epoch -- record time it took";
      flags=CAN_REVERT_TO_CODE;
      code_string="epoch_timer->EndTimer()";
      result_var=NULL;
      obj=$.programs.gp[1][0].vars[5]$;
      method=TimeUsed::EndTimer;
      meth_args {
       name="meth_args";
       el_typ=ProgArg;
       el_def=0;
      };
      meth_sig="void EndTimer()";
      meth_desc=" record the current time as the ending time, and compute difference as the time used";
     };
     ProgramCall @[9] {
      name="ProgramCall_BpEpochMonitorTestnetwork";
      desc="run program that records data from network and possibly other sources about the epoch";
      flags=CAN_REVERT_TO_CODE;
      code_string="BpEpochMonitorTest(network)";
      prog_args {
       name="prog_args";
       el_typ=ProgArg;
       el_def=0;
       ProgArg @[0] {
	arg_type=Network;
	type="BpNetwork*";
	name="network";
	required=1;
	def_val=;
	prev_expr=;
	expr {
	 expr="network";
	};
       };
      };
      target=.programs.gp[1][4]$$;
      targ_ld_init="*BpEpochMonitor*";
     };
     ProgramCall @[10] {
      name="ProgramCall_ExportDatatrialmondataoutputfile";
      desc="run program that records data from network and possibly other sources about the epoch";
      flags=CAN_REVERT_TO_CODE;
      code_string="ExportData(trial_mon_data, output_file)";
      prog_args {
       name="prog_args";
       el_typ=ProgArg;
       el_def=0;
       ProgArg @[0] {
	arg_type=DataTable;
	type="DataTable*";
	name="FinalData";
	required=1;
	def_val=;
	prev_expr="trial_mon_data";
	expr {
	 expr="trial_mon_data";
	};
       };
       ProgArg @[1] {
	arg_type=taString;
	type="String";
	name="output_file";
	required=1;
	def_val=;
	prev_expr=;
	expr {
	 expr="output_file";
	};
       };
      };
      target=$.programs.gp[0][8]$;
      targ_ld_init="*ExportData*";
     };
     MemberAssign @[11] {
      name="MemberAssign_networktrainmodeNetworkTRAIN";
      desc="set back to training mode";
      flags=NEW_EL|CAN_REVERT_TO_CODE;
      code_string="network.train_mode = Network::TRAIN";
      obj=$.programs.gp[1][0].args[0]$;
      path="train_mode";
      expr {
       expr="Network::TRAIN";
      };
      update_after=0;
     };
    };
    step_prog=$.programs.gp[1][1]$;
    step_n=1;
    doc {
     name="doc";
     desc=;
     web_doc=0;
     wiki=;
     url="local";
     full_url="local";
     text_size=1;
     text=;
     html_text=;
    };
   };
   Program @[1] {
    UserDataItem_List @*(.user_data_) {
     name=;
     el_typ=UserData_DocLink;
     el_def=0;
     UserData_DocLink @[0] {name="DocLink": doc=.programs.gp[1][1].doc$$: };
    };
    name="BpTrialTest";
    short_nm="TrlTst";
    tags="Bp, Std";
    desc="Backpropagation processing of a single input/output event or external information";
    version {
     major=0;
     minor=0;
     step=0;
    };
    author=;
    email=;
    flags=0;
    stop_step_cond {
     expr=;
    };
    objs {
     name="objs";
     el_typ=taNBase;
     el_def=0;
    };
    objs_vars {
     name="objs_vars";
     el_typ=ProgVar;
     el_def=0;
    };
    types {
     name="types";
     el_typ=DynEnumType;
     el_def=0;
    };
    args {
     name="args";
     el_typ=ProgVar;
     el_def=0;
     ProgVar @[0] {
      name="network";
      var_type=T_Object;
      object_type=BpNetwork;
      object_val=$.networks[0]$;
      object_scope=NULL;
      objs_ptr=0;
      flags=NULL_CHECK|SAVE_VAL|USED|EDIT_VAL|PGRM_ARG;
      reference=0;
      desc="network to operate on -- typically set by higher-level calling programs";
      init_from=NULL;
     };
     ProgVar @[1] {
      name="input_data";
      var_type=T_Object;
      object_type=DataTable;
      object_val=$.data.gp[0][1]$;
      object_scope=NULL;
      objs_ptr=0;
      flags=NULL_CHECK|SAVE_VAL|USED|EDIT_VAL|PGRM_ARG;
      reference=0;
      desc="datatable containing training input/output patterns";
      init_from=NULL;
     };
    };
    vars {
     name="vars";
     el_typ=ProgVar;
     el_def=0;
     ProgVar @[0] {
      name="update_net_view";
      var_type=T_Bool;
      bool_val=1;
      object_scope=NULL;
      flags=CTRL_PANEL|NULL_CHECK|SAVE_VAL|USED|EDIT_VAL;
      reference=0;
      desc="determines whether to update any network view displays after trial is completed";
      init_from=NULL;
     };
    };
    functions {
     name="functions";
     el_typ=Function;
     el_def=0;
    };
    init_code {
     name="init_code";
     el_typ=ProgCode;
     el_def=0;
    };
    prog_code {
     name="prog_code";
     el_typ=ProgCode;
     el_def=0;
     MethodCall @[0] {
      name="MethodCall_networkInitInputData";
      desc="resets input data, before getting new external inputs data from apply inputs call";
      flags=CAN_REVERT_TO_CODE;
      code_string="network->Init_InputData()";
      result_var=NULL;
      obj=.programs.gp[1][1].args[0]$$;
      method=Network::Init_InputData;
      meth_args {
       name="meth_args";
       el_typ=ProgArg;
       el_def=0;
      };
      meth_sig="void Init_InputData()";
      meth_desc=" Initializes external and target inputs";
     };
     ProgramCall @[1] {
      name="ProgramCall_ApplyInputsTestnetworkinputdata";
      desc="apply external input activations from the input_data table to the network
this program can be extended to do arbitrary things to generate data and apply it to network layers";
      flags=CAN_REVERT_TO_CODE;
      code_string="ApplyInputsTest(network, input_data)";
      prog_args {
       name="prog_args";
       el_typ=ProgArg;
       el_def=0;
       ProgArg @[0] {
	arg_type=LeabraNetwork;
	type="BpNetwork*";
	name="network";
	required=1;
	def_val=;
	prev_expr=;
	expr {
	 expr="network";
	};
       };
       ProgArg @[1] {
	arg_type=DataTable;
	type="DataTable*";
	name="input_data";
	required=1;
	def_val=;
	prev_expr=;
	expr {
	 expr="input_data";
	};
       };
      };
      target=.programs.gp[1][2]$$;
      targ_ld_init="*ApplyInputs*";
     };
     MethodCall @[2] {
      name="MethodCall_networkTrialRun";
      desc="initializes various counters at start of trial";
      flags=CAN_REVERT_TO_CODE;
      code_string="network->Trial_Run()";
      result_var=NULL;
      obj=$.programs.gp[1][1].args[0]$;
      method=BpNetwork::Trial_Run;
      meth_args {
       name="meth_args";
       el_typ=ProgArg;
       el_def=0;
      };
      meth_sig="void Trial_Run()";
      meth_desc=" run one trial of Bp: calls SetCurLrate, Compute_NetinAct, Compute_dEdA_dEdNet, and, if train_mode == TRAIN, Compute_dWt. If you want to save some speed just for testing, you can just call Compute_NetinAct and skip the other two (esp Compute_dEdA_dEdNet, which does a full backprop and is expensive, but often useful for visualization & testing)";
     };
     MethodCall @[3] {
      name="MethodCall_networkComputeTrialStats";
      desc=;
      flags=CAN_REVERT_TO_CODE;
      code_string="network->Compute_TrialStats()";
      result_var=NULL;
      obj=$.programs.gp[1][1].args[0]$;
      method=LeabraNetwork::Compute_TrialStats;
      meth_args {
       name="meth_args";
       el_typ=ProgArg;
       el_def=0;
      };
      meth_sig="void Compute_TrialStats()";
      meth_desc=" compute trial-level statistics (SSE and others defined by specific algorithms) do not call this function anymore -- it is obsolete -- please use Compute_PhaseStats or Compute_MinusStats / Compute_PlusStats for more appropriate stats computation at the right time";
     };
     ProgramCall @[4] {
      name="ProgramCall_BpTrialMonitorTestnetwork";
      desc="records data about the trial-level processing to a datatable for graphing/processing";
      flags=CAN_REVERT_TO_CODE;
      code_string="BpTrialMonitorTest(network)";
      prog_args {
       name="prog_args";
       el_typ=ProgArg;
       el_def=0;
       ProgArg @[0] {
	arg_type=Network;
	type="BpNetwork*";
	name="network";
	required=1;
	def_val=;
	prev_expr=;
	expr {
	 expr="network";
	};
       };
      };
      target=.programs.gp[1][3]$$;
      targ_ld_init="*BpTrialMonitor*";
     };
     NetUpdateView @[5] {
      name="NetUpdateView_NetUpdateView";
      desc="update the network view(s) (only if update_net_view is true)";
      flags=CAN_REVERT_TO_CODE;
      code_string="Net Update View";
      network_var=$.programs.gp[1][1].args[0]$;
      update_var=.programs.gp[1][1].vars[0]$$;
     };
    };
    step_prog=NULL;
    step_n=1;
    doc {
     name="doc";
     desc=;
     web_doc=0;
     wiki=;
     url="local";
     full_url="local";
     text_size=1;
     text=;
     html_text=;
    };
   };
   Program @[2] {
    UserDataItem_List @*(.user_data_) {
     name=;
     el_typ=UserData_DocLink;
     el_def=0;
     UserData_DocLink @[0] {name="DocLink": doc=.programs.gp[1][2].doc$$: };
    };
    name="ApplyInputsTest";
    short_nm="AplyIn";
    tags="Network, InputData, Apply";
    desc="apply the current input data to the network as external input and target values";
    version {
     major=0;
     minor=0;
     step=0;
    };
    author=;
    email=;
    flags=NO_STOP_STEP;
    stop_step_cond {
     expr=;
    };
    objs {
     name="objs";
     el_typ=LayerWriter;
     el_def=0;
     LayerWriter @[0] {
      name="LayerWriter_0";
      data=$.data.gp[0][1]$;
      network=$.networks[0]$;
      layer_data {
       name="layer_data";
       el_typ=LayerWriterEl;
       el_def=0;
       LayerWriterEl @[0] {
	col_name="Input";
	net_target=LAYER;
	layer_name="Input";
	offset {x=0: y=0: };
	use_layer_type=1;
	quiet=0;
	na_by_range=0;
	ext_flags=EXT;
	noise {name="noise": type=NONE: mean=0: var=0.5: par=1: };
       };
       LayerWriterEl @[1] {
	col_name="Output";
	net_target=LAYER;
	layer_name="Output";
	offset {x=0: y=0: };
	use_layer_type=1;
	quiet=0;
	na_by_range=0;
	ext_flags=TARG;
	noise {name="noise": type=NONE: mean=0: var=0.5: par=1: };
       };
       LayerWriterEl @[2] {
	col_name="Name";
	net_target=TRIAL_NAME;
	layer_name="Name";
	offset {x=0: y=0: };
	use_layer_type=1;
	quiet=0;
	na_by_range=0;
	ext_flags=0;
	noise {name="noise": type=NONE: mean=0: var=0.5: par=1: };
       };
      };
     };
    };
    objs_vars {
     name="objs_vars";
     el_typ=ProgVar;
     el_def=0;
     ProgVar @[0] {
      name="layer_writer_0";
      var_type=T_Object;
      object_type=LayerWriter;
      object_val=.programs.gp[1][2].objs[0]$$;
      object_scope=NULL;
      objs_ptr=1;
      flags=NULL_CHECK|SAVE_VAL|USED|EDIT_VAL;
      reference=0;
      desc="this is a pointer to the LayerWriter object in objs -- edit that object to determine how information is presented to the network";
      init_from=NULL;
     };
    };
    types {
     name="types";
     el_typ=DynEnumType;
     el_def=0;
    };
    args {
     name="args";
     el_typ=ProgVar;
     el_def=0;
     ProgVar @[0] {
      name="network";
      var_type=T_Object;
      object_type=LeabraNetwork;
      object_val=$.networks[0]$;
      object_scope=NULL;
      objs_ptr=0;
      flags=NULL_CHECK|SAVE_VAL|USED|EDIT_VAL|PGRM_ARG;
      reference=0;
      desc="network to apply inputs to -- typically set by calling program";
      init_from=NULL;
     };
     ProgVar @[1] {
      name="input_data";
      var_type=T_Object;
      object_type=DataTable;
      object_val=$.data.gp[0][1]$;
      object_scope=NULL;
      objs_ptr=0;
      flags=NULL_CHECK|SAVE_VAL|USED|EDIT_VAL|PGRM_ARG;
      reference=0;
      desc="input datatable containing input/output patterns";
      init_from=NULL;
     };
    };
    vars {
     name="vars";
     el_typ=ProgVar;
     el_def=0;
    };
    functions {
     name="functions";
     el_typ=Function;
     el_def=0;
    };
    init_code {
     name="init_code";
     el_typ=ProgCode;
     el_def=0;
     MethodCall @[0] {
      name="MethodCall_layerwriter0SetD_nputdatanetwork";
      desc="sets the datatable and network for the layer writer, so it knows what to write to";
      flags=CAN_REVERT_TO_CODE;
      code_string="layer_writer_0->SetDataNetwork(input_data, network)";
      result_var=NULL;
      obj=.programs.gp[1][2].objs_vars[0]$$;
      method=LayerWriter::SetDataNetwork;
      meth_args {
       name="meth_args";
       el_typ=ProgArg;
       el_def=0;
       ProgArg @[0] {
	arg_type=DataTable_ptr;
	type="DataTable*";
	name="db";
	required=1;
	def_val=;
	prev_expr=;
	expr {
	 expr="input_data";
	};
       };
       ProgArg @[1] {
	arg_type=Network_ptr;
	type="Network*";
	name="net";
	required=1;
	def_val=;
	prev_expr=;
	expr {
	 expr="network";
	};
       };
      };
      meth_sig="void SetDataNetwork(DataTable* db, Network* net)";
      meth_desc=" set the data table and network pointers -- convenience function for programs ";
     };
     MethodCall @[1] {
      name="MethodCall_layerwriter0CheckConfigfalse";
      desc="check the configuration of the layer writer -- will emit warnings and errors for missing or misconfigured items";
      flags=CAN_REVERT_TO_CODE;
      code_string="layer_writer_0->CheckConfig(false)";
      result_var=NULL;
      obj=$.programs.gp[1][2].objs_vars[0]$;
      method=taList_impl::CheckConfig;
      meth_args {
       name="meth_args";
       el_typ=ProgArg;
       el_def=0;
       ProgArg @[0] {
	arg_type=bool;
	type="bool";
	name="quiet";
	required=0;
	def_val="false";
	prev_expr=;
	expr {
	 expr="false";
	};
       };
      };
      meth_sig="bool CheckConfig(bool quiet = false)";
      meth_desc=" check the configuration of this object and all its children (defaults to no confirm of success)";
     };
    };
    prog_code {
     name="prog_code";
     el_typ=ProgCode;
     el_def=0;
     MethodCall @[0] {
      name="MethodCall_layerwriter0ApplyInputData";
      desc="apply inputs to the network!  layer writer has all the key specs";
      flags=CAN_REVERT_TO_CODE;
      code_string="layer_writer_0->ApplyInputData()";
      result_var=NULL;
      obj=$.programs.gp[1][2].objs_vars[0]$;
      method=LayerWriter::ApplyInputData;
      meth_args {
       name="meth_args";
       el_typ=ProgArg;
       el_def=0;
      };
      meth_sig="bool ApplyInputData()";
      meth_desc=" apply data to the layers, using the network's current context settings (TEST,TRAIN,etc) -- returns success";
     };
    };
    step_prog=NULL;
    step_n=1;
    doc {
     name="doc";
     desc=;
     web_doc=0;
     wiki=;
     url="local";
     full_url="local";
     text_size=1;
     text=;
     html_text=;
    };
   };
   Program @[3] {
    UserDataItem_List @*(.user_data_) {
     name=;
     el_typ=UserData_DocLink;
     el_def=0;
     UserData_DocLink @[0] {name="DocLink": doc=.programs.gp[1][3].doc$$: };
    };
    name="BpTrialMonitorTest";
    short_nm="TrlMon";
    tags="Bp, Std, Monitor";
    desc="monitor trial-level data from the network (and potentially other sources) -- stores results in datatable (TrialOutputData typically) that can be used for graph/grid views and further analysis ";
    version {
     major=0;
     minor=0;
     step=0;
    };
    author=;
    email=;
    flags=NO_STOP_STEP;
    stop_step_cond {
     expr=;
    };
    objs {
     name="objs";
     el_typ=NetMonitor;
     el_def=0;
     NetMonitor @[0] {
      name="trial_netmon";
      items {
       name="items";
       el_typ=NetMonItem;
       el_def=0;
       NetMonItem @[0] {
	name="batch";
	computed=0;
	object_type=LeabraNetwork;
	object=$.networks[0]$;
	variable="batch";
	var_label=;
	name_style=AUTO_NAME;
	max_name_len=6;
	options=HIDDEN_LAYERS|OUTPUT_LAYERS|TARGET_LAYERS;
	val_type=VT_FLOAT;
	matrix=0;
	matrix_geom{ 	};
	data_agg=0;
	data_src=NULL;
	agg_col {
	 col_name=;
	};
	agg {name="agg": op=NONE: rel={name="rel": rel=LESSTHANOREQUAL: val=0: val_string="": use_var=0: var=NULL: }: };
	select_rows=0;
	select_spec {
	 col_name=;
	 name="_EQUAL_";
	 on=1;
	 rel=EQUAL;
	 use_var=0;
	 cmp 0 1;
	 var=NULL;
	 enable_var=NULL;
	};
	pre_proc_1 {name="pre_proc_1": opr=NONE: arg=0: lw=-1: hi=1: };
	pre_proc_2 {name="pre_proc_2": opr=NONE: arg=0: lw=-1: hi=1: };
	pre_proc_3 {name="pre_proc_3": opr=NONE: arg=0: lw=-1: hi=1: };
       };
       NetMonItem @[1] {
	name="epoch";
	computed=0;
	object_type=LeabraNetwork;
	object=$.networks[0]$;
	variable="epoch";
	var_label=;
	name_style=AUTO_NAME;
	max_name_len=6;
	options=HIDDEN_LAYERS|OUTPUT_LAYERS|TARGET_LAYERS;
	val_type=VT_FLOAT;
	matrix=0;
	matrix_geom{ 	};
	data_agg=0;
	data_src=NULL;
	agg_col {
	 col_name=;
	};
	agg {name="agg": op=NONE: rel={name="rel": rel=LESSTHANOREQUAL: val=0: val_string="": use_var=0: var=NULL: }: };
	select_rows=0;
	select_spec {
	 col_name=;
	 name="_EQUAL_";
	 on=1;
	 rel=EQUAL;
	 use_var=0;
	 cmp 0 1;
	 var=NULL;
	 enable_var=NULL;
	};
	pre_proc_1 {name="pre_proc_1": opr=NONE: arg=0: lw=-1: hi=1: };
	pre_proc_2 {name="pre_proc_2": opr=NONE: arg=0: lw=-1: hi=1: };
	pre_proc_3 {name="pre_proc_3": opr=NONE: arg=0: lw=-1: hi=1: };
       };
       NetMonItem @[2] {
	name="trial";
	computed=0;
	object_type=LeabraNetwork;
	object=$.networks[0]$;
	variable="trial";
	var_label=;
	name_style=AUTO_NAME;
	max_name_len=6;
	options=HIDDEN_LAYERS|OUTPUT_LAYERS|TARGET_LAYERS;
	val_type=VT_FLOAT;
	matrix=0;
	matrix_geom{ 	};
	data_agg=0;
	data_src=NULL;
	agg_col {
	 col_name=;
	};
	agg {name="agg": op=NONE: rel={name="rel": rel=LESSTHANOREQUAL: val=0: val_string="": use_var=0: var=NULL: }: };
	select_rows=0;
	select_spec {
	 col_name=;
	 name="_EQUAL_";
	 on=1;
	 rel=EQUAL;
	 use_var=0;
	 cmp 0 1;
	 var=NULL;
	 enable_var=NULL;
	};
	pre_proc_1 {name="pre_proc_1": opr=NONE: arg=0: lw=-1: hi=1: };
	pre_proc_2 {name="pre_proc_2": opr=NONE: arg=0: lw=-1: hi=1: };
	pre_proc_3 {name="pre_proc_3": opr=NONE: arg=0: lw=-1: hi=1: };
       };
       NetMonItem @[3] {
	name="trial_name";
	computed=0;
	object_type=LeabraNetwork;
	object=$.networks[0]$;
	variable="trial_name";
	var_label=;
	name_style=AUTO_NAME;
	max_name_len=6;
	options=HIDDEN_LAYERS|OUTPUT_LAYERS|TARGET_LAYERS;
	val_type=VT_FLOAT;
	matrix=0;
	matrix_geom{ 	};
	data_agg=0;
	data_src=NULL;
	agg_col {
	 col_name=;
	};
	agg {name="agg": op=NONE: rel={name="rel": rel=LESSTHANOREQUAL: val=0: val_string="": use_var=0: var=NULL: }: };
	select_rows=0;
	select_spec {
	 col_name=;
	 name="_EQUAL_";
	 on=1;
	 rel=EQUAL;
	 use_var=0;
	 cmp 0 1;
	 var=NULL;
	 enable_var=NULL;
	};
	pre_proc_1 {name="pre_proc_1": opr=NONE: arg=0: lw=-1: hi=1: };
	pre_proc_2 {name="pre_proc_2": opr=NONE: arg=0: lw=-1: hi=1: };
	pre_proc_3 {name="pre_proc_3": opr=NONE: arg=0: lw=-1: hi=1: };
       };
       NetMonItem @[4] {
	name="group_name";
	computed=0;
	object_type=LeabraNetwork;
	object=$.networks[0]$;
	variable="group_name";
	var_label=;
	name_style=AUTO_NAME;
	max_name_len=6;
	options=HIDDEN_LAYERS|OUTPUT_LAYERS|TARGET_LAYERS;
	val_type=VT_FLOAT;
	matrix=0;
	matrix_geom{ 	};
	data_agg=0;
	data_src=NULL;
	agg_col {
	 col_name=;
	};
	agg {name="agg": op=NONE: rel={name="rel": rel=LESSTHANOREQUAL: val=0: val_string="": use_var=0: var=NULL: }: };
	select_rows=0;
	select_spec {
	 col_name=;
	 name="_EQUAL_";
	 on=1;
	 rel=EQUAL;
	 use_var=0;
	 cmp 0 1;
	 var=NULL;
	 enable_var=NULL;
	};
	pre_proc_1 {name="pre_proc_1": opr=NONE: arg=0: lw=-1: hi=1: };
	pre_proc_2 {name="pre_proc_2": opr=NONE: arg=0: lw=-1: hi=1: };
	pre_proc_3 {name="pre_proc_3": opr=NONE: arg=0: lw=-1: hi=1: };
       };
       NetMonItem @[5] {
	name="sse";
	computed=0;
	object_type=LeabraNetwork;
	object=$.networks[0]$;
	variable="sse";
	var_label=;
	name_style=AUTO_NAME;
	max_name_len=6;
	options=HIDDEN_LAYERS|OUTPUT_LAYERS|TARGET_LAYERS;
	val_type=VT_FLOAT;
	matrix=0;
	matrix_geom{ 	};
	data_agg=0;
	data_src=NULL;
	agg_col {
	 col_name=;
	};
	agg {name="agg": op=NONE: rel={name="rel": rel=LESSTHANOREQUAL: val=0: val_string="": use_var=0: var=NULL: }: };
	select_rows=0;
	select_spec {
	 col_name=;
	 name="_EQUAL_";
	 on=1;
	 rel=EQUAL;
	 use_var=0;
	 cmp 0 1;
	 var=NULL;
	 enable_var=NULL;
	};
	pre_proc_1 {name="pre_proc_1": opr=NONE: arg=0: lw=-1: hi=1: };
	pre_proc_2 {name="pre_proc_2": opr=NONE: arg=0: lw=-1: hi=1: };
	pre_proc_3 {name="pre_proc_3": opr=NONE: arg=0: lw=-1: hi=1: };
       };
       NetMonItem @[6] {
	name="Output_act";
	computed=0;
	object_type=BpLayer;
	object=.networks[0].layers[2]$$;
	variable="act";
	var_label=;
	name_style=AUTO_NAME;
	max_name_len=6;
	options=HIDDEN_LAYERS|OUTPUT_LAYERS|TARGET_LAYERS;
	val_type=VT_FLOAT;
	matrix=0;
	matrix_geom{ 	};
	data_agg=0;
	data_src=NULL;
	agg_col {
	 col_name=;
	};
	agg {name="agg": op=NONE: rel={name="Relation": rel=LESSTHANOREQUAL: val=0: val_string="": use_var=0: var=NULL: }: };
	select_rows=0;
	select_spec {
	 col_name=;
	 name="_EQUAL_";
	 on=1;
	 rel=EQUAL;
	 use_var=0;
	 cmp 0 1;
	 var=NULL;
	 enable_var=NULL;
	};
	pre_proc_1 {name="pre_proc_1": opr=NONE: arg=0: lw=-1: hi=1: };
	pre_proc_2 {name="pre_proc_2": opr=NONE: arg=0: lw=-1: hi=1: };
	pre_proc_3 {name="pre_proc_3": opr=NONE: arg=0: lw=-1: hi=1: };
       };
       NetMonItem @[7] {
	name="Output_targ";
	computed=0;
	object_type=BpLayer;
	object=$.networks[0].layers[2]$;
	variable="targ";
	var_label=;
	name_style=AUTO_NAME;
	max_name_len=6;
	options=HIDDEN_LAYERS|OUTPUT_LAYERS|TARGET_LAYERS;
	val_type=VT_FLOAT;
	matrix=0;
	matrix_geom{ 	};
	data_agg=0;
	data_src=NULL;
	agg_col {
	 col_name=;
	};
	agg {name="agg": op=NONE: rel={name="Relation": rel=LESSTHANOREQUAL: val=0: val_string="": use_var=0: var=NULL: }: };
	select_rows=0;
	select_spec {
	 col_name=;
	 name="_EQUAL_";
	 on=1;
	 rel=EQUAL;
	 use_var=0;
	 cmp 0 1;
	 var=NULL;
	 enable_var=NULL;
	};
	pre_proc_1 {name="pre_proc_1": opr=NONE: arg=0: lw=-1: hi=1: };
	pre_proc_2 {name="pre_proc_2": opr=NONE: arg=0: lw=-1: hi=1: };
	pre_proc_3 {name="pre_proc_3": opr=NONE: arg=0: lw=-1: hi=1: };
       };
       NetMonItem @[8] {
	name="Output_Output";
	computed=0;
	object_type=BpLayer;
	object=$.networks[0].layers[2]$;
	variable="Output";
	var_label=;
	name_style=AUTO_NAME;
	max_name_len=6;
	options=HIDDEN_LAYERS|OUTPUT_LAYERS|TARGET_LAYERS;
	val_type=VT_FLOAT;
	matrix=0;
	matrix_geom{ 	};
	data_agg=0;
	data_src=NULL;
	agg_col {
	 col_name=;
	};
	agg {name="agg": op=NONE: rel={name="Relation_26": rel=LESSTHANOREQUAL: val=0: val_string="": use_var=0: var=NULL: }: };
	select_rows=0;
	select_spec {
	 col_name=;
	 name="_EQUAL_";
	 on=1;
	 rel=EQUAL;
	 use_var=0;
	 cmp 2 0=0;
	 var=NULL;
	 enable_var=NULL;
	};
	pre_proc_1 {name="pre_proc_1": opr=NONE: arg=0: lw=-1: hi=1: };
	pre_proc_2 {name="pre_proc_2": opr=NONE: arg=0: lw=-1: hi=1: };
	pre_proc_3 {name="pre_proc_3": opr=NONE: arg=0: lw=-1: hi=1: };
       };
      };
      network=$.networks[0]$;
      data=$.data.gp[1][2]$;
      rmv_orphan_cols=1;
     };
    };
    objs_vars {
     name="objs_vars";
     el_typ=ProgVar;
     el_def=0;
     ProgVar @[0] {
      name="trial_netmon";
      var_type=T_Object;
      object_type=NetMonitor;
      object_val=.programs.gp[1][3].objs[0]$$;
      object_scope=NULL;
      objs_ptr=1;
      flags=NULL_CHECK|SAVE_VAL|USED|EDIT_VAL;
      reference=0;
      desc="pointer to the NetMonitor object in objs secton of this program that contains configuration for what to record and where to get it";
      init_from=NULL;
     };
    };
    types {
     name="types";
     el_typ=DynEnumType;
     el_def=0;
    };
    args {
     name="args";
     el_typ=ProgVar;
     el_def=0;
     ProgVar @[0] {
      name="network";
      var_type=T_Object;
      object_type=Network;
      object_val=$.networks[0]$;
      object_scope=NULL;
      objs_ptr=0;
      flags=CTRL_PANEL|NULL_CHECK|SAVE_VAL|USED|EDIT_VAL|PGRM_ARG;
      reference=0;
      desc="network to record data from";
      init_from=NULL;
     };
    };
    vars {
     name="vars";
     el_typ=ProgVar;
     el_def=0;
     ProgVar @[0] {
      name="trial_mon_data";
      var_type=T_Object;
      object_type=DataTable;
      object_val=$.data.gp[1][2]$;
      object_scope=NULL;
      objs_ptr=0;
      flags=CTRL_PANEL|NULL_CHECK|SAVE_VAL|USED|EDIT_VAL;
      reference=0;
      desc="data table to record trial-level data to (this program writes new data to this table!)";
      init_from=NULL;
     };
    };
    functions {
     name="functions";
     el_typ=Function;
     el_def=0;
    };
    init_code {
     name="init_code";
     el_typ=ProgCode;
     el_def=0;
     MethodCall @[0] {
      name="MethodCall_trialnetmonSetDa_lmondatanetwork";
      desc="set the network and datatable for the NetMonitor";
      flags=CAN_REVERT_TO_CODE;
      code_string="trial_netmon->SetDataNetwork(trial_mon_data, network)";
      result_var=NULL;
      obj=.programs.gp[1][3].objs_vars[0]$$;
      method=NetMonitor::SetDataNetwork;
      meth_args {
       name="meth_args";
       el_typ=ProgArg;
       el_def=0;
       ProgArg @[0] {
	arg_type=DataTable_ptr;
	type="DataTable*";
	name="dt";
	required=1;
	def_val=;
	prev_expr=;
	expr {
	 expr="trial_mon_data";
	};
       };
       ProgArg @[1] {
	arg_type=Network_ptr;
	type="Network*";
	name="net";
	required=1;
	def_val=;
	prev_expr=;
	expr {
	 expr="network";
	};
       };
      };
      meth_sig="void SetDataNetwork(DataTable* dt, Network* net)";
      meth_desc=" set both the data table and network -- convenient for programs -- calls ResetDataTableCols too -- don't call if columns are manually added or this is adding additional rows to a table";
     };
     MethodCall @[1] {
      name="MethodCall_trialnetmonCheckConfigfalse";
      desc="check the configuration of the network monitor -- will emit warnings and errors for misconfigurations";
      flags=CAN_REVERT_TO_CODE;
      code_string="trial_netmon->CheckConfig(false)";
      result_var=NULL;
      obj=$.programs.gp[1][3].objs_vars[0]$;
      method=taBase::CheckConfig;
      meth_args {
       name="meth_args";
       el_typ=ProgArg;
       el_def=0;
       ProgArg @[0] {
	arg_type=bool;
	type="bool";
	name="quiet";
	required=0;
	def_val="false";
	prev_expr=;
	expr {
	 expr="false";
	};
       };
      };
      meth_sig="bool CheckConfig(bool quiet = false)";
      meth_desc=" check the configuration of this object and all its children (defaults to no confirm of success)";
     };
     MethodCall @[2] {
      name="MethodCall_trialnetmonUpdateMonitorstrue";
      desc="update the monitor items and data schema based on current settings of the NetMonitor object";
      flags=CAN_REVERT_TO_CODE;
      code_string="trial_netmon->UpdateMonitors(true)";
      result_var=NULL;
      obj=$.programs.gp[1][3].objs_vars[0]$;
      method=NetMonitor::UpdateMonitors;
      meth_args {
       name="meth_args";
       el_typ=ProgArg;
       el_def=0;
       ProgArg @[0] {
	arg_type=bool;
	type="bool";
	name="reset_first";
	required=0;
	def_val="false";
	prev_expr=;
	expr {
	 expr="true";
	};
       };
      };
      meth_sig="void UpdateMonitors(bool reset_first = false)";
      meth_desc=" old name for UpdateDataTable";
     };
    };
    prog_code {
     name="prog_code";
     el_typ=ProgCode;
     el_def=0;
     MethodCall @[0] {
      name="MethodCall_trialmondataAddBlankRow";
      desc="add a new blank row to the data";
      flags=CAN_REVERT_TO_CODE;
      code_string="trial_mon_data->AddBlankRow()";
      result_var=NULL;
      obj=.programs.gp[1][3].vars[0]$$;
      method=DataTable::AddBlankRow;
      meth_args {
       name="meth_args";
       el_typ=ProgArg;
       el_def=0;
      };
      meth_sig="int AddBlankRow()";
      meth_desc=" add a new row to the data table, sets read (source) and write (sink) index to this last row (as in ReadItem or WriteItem), so that subsequent data routines refer to this new row, and returns row ";
     };
     MethodCall @[1] {
      name="MethodCall_trialnetmonGetMonVals";
      desc="get the new monitor data from the network and other sources -- this does the main work";
      flags=CAN_REVERT_TO_CODE;
      code_string="trial_netmon->GetMonVals()";
      result_var=NULL;
      obj=$.programs.gp[1][3].objs_vars[0]$;
      method=NetMonitor::GetMonVals;
      meth_args {
       name="meth_args";
       el_typ=ProgArg;
       el_def=0;
      };
      meth_sig="void GetMonVals()";
      meth_desc=" get all the values and store in current row of data table -- call in program to get new data";
     };
     MethodCall @[2] {
      name="MethodCall_trialmondataWriteClose";
      desc="update views and other things after writing new data to monitor data table";
      flags=CAN_REVERT_TO_CODE;
      code_string="trial_mon_data->WriteClose()";
      result_var=NULL;
      obj=$.programs.gp[1][3].vars[0]$;
      method=DataTable::WriteClose;
      meth_args {
       name="meth_args";
       el_typ=ProgArg;
       el_def=0;
      };
      meth_sig="void WriteClose()";
      meth_desc=" closes up a write operation -- call when done writing data -- performs any post-writing cleanup/closing of files, etc";
     };
     MethodCall @[3] {
      name="MethodCall_networkDMemShare_tatrialmondata1";
      desc="only functional for dmem projects: synchronizes trial data across processes so that all distributed memory processors have the same trial-level data, despite having run only a subset of them each";
      flags=CAN_REVERT_TO_CODE;
      code_string="network->DMem_ShareTrialData(trial_mon_data, 1)";
      result_var=NULL;
      obj=.programs.gp[1][3].args[0]$$;
      method=Network::DMem_ShareTrialData;
      meth_args {
       name="meth_args";
       el_typ=ProgArg;
       el_def=0;
       ProgArg @[0] {
	arg_type=DataTable_ptr;
	type="DataTable*";
	name="dt";
	required=1;
	def_val=;
	prev_expr=;
	expr {
	 expr="trial_mon_data";
	};
       };
       ProgArg @[1] {
	arg_type=int;
	type="int";
	name="n_rows";
	required=0;
	def_val="1";
	prev_expr=;
	expr {
	 expr="1";
	};
       };
      };
      meth_sig="void DMem_ShareTrialData(DataTable* dt, int n_rows = 1)";
      meth_desc=" share trial data from given datatable across the trial-level dmem communicator (outer loop) -- each processor gets data from all other processors; if called every trial with n_rows = 1, data will be identical to non-dmem; if called at end of epoch with n_rows = -1 data will be grouped by processor but this is more efficient";
     };
    };
    step_prog=NULL;
    step_n=1;
    doc {
     name="doc";
     desc=;
     web_doc=0;
     wiki=;
     url="local";
     full_url="local";
     text_size=1;
     text=;
     html_text=;
    };
   };
   Program @[4] {
    UserDataItem_List @*(.user_data_) {
     name=;
     el_typ=UserData_DocLink;
     el_def=0;
     UserData_DocLink @[0] {name="DocLink": doc=.programs.gp[1][4].doc$$: };
    };
    name="BpEpochMonitorTest";
    short_nm="EpcMon";
    tags="Bp, Std, Monitor";
    desc="monitor epoch-level data from the network to a datatable (EpochOutputData typically) for use in graphing and viewing and further analysis";
    version {
     major=0;
     minor=0;
     step=0;
    };
    author=;
    email=;
    flags=NO_STOP_STEP;
    stop_step_cond {
     expr=;
    };
    objs {
     name="objs";
     el_typ=NetMonitor;
     el_def=0;
     NetMonitor @[0] {
      name="epoch_netmon";
      items {
       name="items";
       el_typ=NetMonItem;
       el_def=0;
       NetMonItem @[0] {
	name="batch";
	computed=0;
	object_type=LeabraNetwork;
	object=$.networks[0]$;
	variable="batch";
	var_label=;
	name_style=AUTO_NAME;
	max_name_len=6;
	options=HIDDEN_LAYERS|OUTPUT_LAYERS|TARGET_LAYERS;
	val_type=VT_FLOAT;
	matrix=0;
	matrix_geom{ 	};
	data_agg=0;
	data_src=NULL;
	agg_col {
	 col_name=;
	};
	agg {name="agg": op=NONE: rel={name="rel": rel=LESSTHANOREQUAL: val=0: val_string="": use_var=0: var=NULL: }: };
	select_rows=0;
	select_spec {
	 col_name=;
	 name="_EQUAL_";
	 on=1;
	 rel=EQUAL;
	 use_var=0;
	 cmp 0 1;
	 var=NULL;
	 enable_var=NULL;
	};
	pre_proc_1 {name="pre_proc_1": opr=NONE: arg=0: lw=-1: hi=1: };
	pre_proc_2 {name="pre_proc_2": opr=NONE: arg=0: lw=-1: hi=1: };
	pre_proc_3 {name="pre_proc_3": opr=NONE: arg=0: lw=-1: hi=1: };
       };
       NetMonItem @[1] {
	name="epoch";
	computed=0;
	object_type=LeabraNetwork;
	object=$.networks[0]$;
	variable="epoch";
	var_label=;
	name_style=AUTO_NAME;
	max_name_len=6;
	options=HIDDEN_LAYERS|OUTPUT_LAYERS|TARGET_LAYERS;
	val_type=VT_FLOAT;
	matrix=0;
	matrix_geom{ 	};
	data_agg=0;
	data_src=NULL;
	agg_col {
	 col_name=;
	};
	agg {name="agg": op=NONE: rel={name="rel": rel=LESSTHANOREQUAL: val=0: val_string="": use_var=0: var=NULL: }: };
	select_rows=0;
	select_spec {
	 col_name=;
	 name="_EQUAL_";
	 on=1;
	 rel=EQUAL;
	 use_var=0;
	 cmp 0 1;
	 var=NULL;
	 enable_var=NULL;
	};
	pre_proc_1 {name="pre_proc_1": opr=NONE: arg=0: lw=-1: hi=1: };
	pre_proc_2 {name="pre_proc_2": opr=NONE: arg=0: lw=-1: hi=1: };
	pre_proc_3 {name="pre_proc_3": opr=NONE: arg=0: lw=-1: hi=1: };
       };
       NetMonItem @[2] {
	name="avg_sse";
	computed=0;
	object_type=LeabraNetwork;
	object=$.networks[0]$;
	variable="avg_sse";
	var_label=;
	name_style=AUTO_NAME;
	max_name_len=6;
	options=HIDDEN_LAYERS|OUTPUT_LAYERS|TARGET_LAYERS;
	val_type=VT_FLOAT;
	matrix=0;
	matrix_geom{ 	};
	data_agg=0;
	data_src=NULL;
	agg_col {
	 col_name=;
	};
	agg {name="agg": op=NONE: rel={name="rel": rel=LESSTHANOREQUAL: val=0: val_string="": use_var=0: var=NULL: }: };
	select_rows=0;
	select_spec {
	 col_name=;
	 name="_EQUAL_";
	 on=1;
	 rel=EQUAL;
	 use_var=0;
	 cmp 0 1;
	 var=NULL;
	 enable_var=NULL;
	};
	pre_proc_1 {name="pre_proc_1": opr=NONE: arg=0: lw=-1: hi=1: };
	pre_proc_2 {name="pre_proc_2": opr=NONE: arg=0: lw=-1: hi=1: };
	pre_proc_3 {name="pre_proc_3": opr=NONE: arg=0: lw=-1: hi=1: };
       };
       NetMonItem @[3] {
	name="cnt_err";
	computed=0;
	object_type=LeabraNetwork;
	object=$.networks[0]$;
	variable="cnt_err";
	var_label=;
	name_style=AUTO_NAME;
	max_name_len=6;
	options=HIDDEN_LAYERS|OUTPUT_LAYERS|TARGET_LAYERS;
	val_type=VT_FLOAT;
	matrix=0;
	matrix_geom{ 	};
	data_agg=0;
	data_src=NULL;
	agg_col {
	 col_name=;
	};
	agg {name="agg": op=NONE: rel={name="rel": rel=LESSTHANOREQUAL: val=0: val_string="": use_var=0: var=NULL: }: };
	select_rows=0;
	select_spec {
	 col_name=;
	 name="_EQUAL_";
	 on=1;
	 rel=EQUAL;
	 use_var=0;
	 cmp 0 1;
	 var=NULL;
	 enable_var=NULL;
	};
	pre_proc_1 {name="pre_proc_1": opr=NONE: arg=0: lw=-1: hi=1: };
	pre_proc_2 {name="pre_proc_2": opr=NONE: arg=0: lw=-1: hi=1: };
	pre_proc_3 {name="pre_proc_3": opr=NONE: arg=0: lw=-1: hi=1: };
       };
       NetMonItem @[4] {
	name="epoch_time_tot";
	computed=1;
	object_type=NULL;
	object=NULL;
	variable="act";
	var_label=;
	name_style=MY_NAME;
	max_name_len=6;
	options=HIDDEN_LAYERS|OUTPUT_LAYERS|TARGET_LAYERS;
	val_type=VT_FLOAT;
	matrix=0;
	matrix_geom{ 	};
	data_agg=0;
	data_src=NULL;
	agg_col {
	 col_name=;
	};
	agg {name="agg": op=NONE: rel={name="rel": rel=LESSTHANOREQUAL: val=0: val_string="": use_var=0: var=NULL: }: };
	select_rows=0;
	select_spec {
	 col_name=;
	 name="_EQUAL_";
	 on=1;
	 rel=EQUAL;
	 use_var=0;
	 cmp 0 1;
	 var=NULL;
	 enable_var=NULL;
	};
	pre_proc_1 {name="pre_proc_1": opr=NONE: arg=0: lw=-1: hi=1: };
	pre_proc_2 {name="pre_proc_2": opr=NONE: arg=0: lw=-1: hi=1: };
	pre_proc_3 {name="pre_proc_3": opr=NONE: arg=0: lw=-1: hi=1: };
       };
       NetMonItem @[5] {
	name="epoch_time_usr";
	computed=1;
	object_type=NULL;
	object=NULL;
	variable="act";
	var_label=;
	name_style=MY_NAME;
	max_name_len=6;
	options=HIDDEN_LAYERS|OUTPUT_LAYERS|TARGET_LAYERS;
	val_type=VT_FLOAT;
	matrix=0;
	matrix_geom{ 	};
	data_agg=0;
	data_src=NULL;
	agg_col {
	 col_name=;
	};
	agg {name="agg": op=NONE: rel={name="rel": rel=LESSTHANOREQUAL: val=0: val_string="": use_var=0: var=NULL: }: };
	select_rows=0;
	select_spec {
	 col_name=;
	 name="_EQUAL_";
	 on=1;
	 rel=EQUAL;
	 use_var=0;
	 cmp 0 1;
	 var=NULL;
	 enable_var=NULL;
	};
	pre_proc_1 {name="pre_proc_1": opr=NONE: arg=0: lw=-1: hi=1: };
	pre_proc_2 {name="pre_proc_2": opr=NONE: arg=0: lw=-1: hi=1: };
	pre_proc_3 {name="pre_proc_3": opr=NONE: arg=0: lw=-1: hi=1: };
       };
      };
      network=$.networks[0]$;
      data=.data.gp[1][3]$$;
      rmv_orphan_cols=1;
     };
    };
    objs_vars {
     name="objs_vars";
     el_typ=ProgVar;
     el_def=0;
     ProgVar @[0] {
      name="epoch_netmon";
      var_type=T_Object;
      object_type=NetMonitor;
      object_val=.programs.gp[1][4].objs[0]$$;
      object_scope=NULL;
      objs_ptr=1;
      flags=NULL_CHECK|SAVE_VAL|USED|EDIT_VAL;
      reference=0;
      desc="network monitor object that contains full specs for what to record and where to get it";
      init_from=NULL;
     };
    };
    types {
     name="types";
     el_typ=DynEnumType;
     el_def=0;
    };
    args {
     name="args";
     el_typ=ProgVar;
     el_def=0;
     ProgVar @[0] {
      name="network";
      var_type=T_Object;
      object_type=Network;
      object_val=$.networks[0]$;
      object_scope=NULL;
      objs_ptr=0;
      flags=CTRL_PANEL|NULL_CHECK|SAVE_VAL|USED|EDIT_VAL|PGRM_ARG;
      reference=0;
      desc="network to get data from";
      init_from=NULL;
     };
    };
    vars {
     name="vars";
     el_typ=ProgVar;
     el_def=0;
     ProgVar @[0] {
      name="epoch_mon_data";
      var_type=T_Object;
      object_type=DataTable;
      object_val=$.data.gp[1][3]$;
      object_scope=NULL;
      objs_ptr=0;
      flags=CTRL_PANEL|NULL_CHECK|SAVE_VAL|USED|EDIT_VAL;
      reference=0;
      desc="data table to write the epoch data to";
      init_from=NULL;
     };
     ProgVar @[1] {
      name="epoch_timer";
      var_type=T_Object;
      object_type=TimeUsed;
      object_val=$.networks[0].epoch_time$;
      object_scope=NULL;
      objs_ptr=0;
      flags=NULL_CHECK|SAVE_VAL|USED|EDIT_VAL;
      reference=0;
      desc="pointer to the network's epoch-level timer, to record how long it took to process an epoch";
      init_from=NULL;
     };
    };
    functions {
     name="functions";
     el_typ=Function;
     el_def=0;
    };
    init_code {
     name="init_code";
     el_typ=ProgCode;
     el_def=0;
     AssignExpr @[0] {
      name="AssignExpr_epochtimernetworkepochtime";
      desc="get the epoch timer from current network";
      flags=CAN_REVERT_TO_CODE;
      code_string="epoch_timer = network.epoch_time";
      result_var=.programs.gp[1][4].vars[1]$$;
      expr {
       expr="network.epoch_time";
      };
     };
     MethodCall @[1] {
      name="MethodCall_epochnetmonSetDa_hmondatanetwork";
      desc="set data and network on NetMonitor object";
      flags=CAN_REVERT_TO_CODE;
      code_string="epoch_netmon->SetDataNetwork(epoch_mon_data, network)";
      result_var=NULL;
      obj=.programs.gp[1][4].objs_vars[0]$$;
      method=NetMonitor::SetDataNetwork;
      meth_args {
       name="meth_args";
       el_typ=ProgArg;
       el_def=0;
       ProgArg @[0] {
	arg_type=DataTable_ptr;
	type="DataTable*";
	name="dt";
	required=1;
	def_val=;
	prev_expr=;
	expr {
	 expr="epoch_mon_data";
	};
       };
       ProgArg @[1] {
	arg_type=Network_ptr;
	type="Network*";
	name="net";
	required=1;
	def_val=;
	prev_expr=;
	expr {
	 expr="network";
	};
       };
      };
      meth_sig="void SetDataNetwork(DataTable* dt, Network* net)";
      meth_desc=" set both the data table and network -- convenient for programs -- calls ResetDataTableCols too -- don't call if columns are manually added or this is adding additional rows to a table";
     };
     MethodCall @[2] {
      name="MethodCall_epochnetmonCheckConfigfalse";
      desc="check configuration and emit errors/warnings for problems";
      flags=CAN_REVERT_TO_CODE;
      code_string="epoch_netmon->CheckConfig(false)";
      result_var=NULL;
      obj=$.programs.gp[1][4].objs_vars[0]$;
      method=taBase::CheckConfig;
      meth_args {
       name="meth_args";
       el_typ=ProgArg;
       el_def=0;
       ProgArg @[0] {
	arg_type=bool;
	type="bool";
	name="quiet";
	required=0;
	def_val="false";
	prev_expr=;
	expr {
	 expr="false";
	};
       };
      };
      meth_sig="bool CheckConfig(bool quiet = false)";
      meth_desc=" check the configuration of this object and all its children (defaults to no confirm of success)";
     };
     MethodCall @[3] {
      name="MethodCall_epochnetmonUpdateMonitorstrue";
      desc="update the monitor items and data schema based on current settings of NetMonitor";
      flags=CAN_REVERT_TO_CODE;
      code_string="epoch_netmon->UpdateMonitors(true)";
      result_var=NULL;
      obj=$.programs.gp[1][4].objs_vars[0]$;
      method=NetMonitor::UpdateMonitors;
      meth_args {
       name="meth_args";
       el_typ=ProgArg;
       el_def=0;
       ProgArg @[0] {
	arg_type=bool;
	type="bool";
	name="reset_first";
	required=0;
	def_val="false";
	prev_expr=;
	expr {
	 expr="true";
	};
       };
      };
      meth_sig="void UpdateMonitors(bool reset_first = false)";
      meth_desc=" old name for UpdateDataTable";
     };
    };
    prog_code {
     name="prog_code";
     el_typ=ProgCode;
     el_def=0;
     MethodCall @[0] {
      name="MethodCall_epochmondataAddBlankRow";
      desc="add a new blank row to the data";
      flags=CAN_REVERT_TO_CODE;
      code_string="epoch_mon_data->AddBlankRow()";
      result_var=NULL;
      obj=.programs.gp[1][4].vars[0]$$;
      method=DataTable::AddBlankRow;
      meth_args {
       name="meth_args";
       el_typ=ProgArg;
       el_def=0;
      };
      meth_sig="int AddBlankRow()";
      meth_desc=" add a new row to the data table, sets read (source) and write (sink) index to this last row (as in ReadItem or WriteItem), so that subsequent data routines refer to this new row, and returns row ";
     };
     MethodCall @[1] {
      name="MethodCall_epochnetmonGetMonVals";
      desc="get the new monitor data and stor it into the data table -- this does the main job here";
      flags=CAN_REVERT_TO_CODE;
      code_string="epoch_netmon->GetMonVals()";
      result_var=NULL;
      obj=$.programs.gp[1][4].objs_vars[0]$;
      method=NetMonitor::GetMonVals;
      meth_args {
       name="meth_args";
       el_typ=ProgArg;
       el_def=0;
      };
      meth_sig="void GetMonVals()";
      meth_desc=" get all the values and store in current row of data table -- call in program to get new data";
     };
     AssignExpr @[2] {
      name="AssignExpr_epochtimernetworkepochtime";
      desc="get the epoch timer from current network";
      flags=CAN_REVERT_TO_CODE;
      code_string="epoch_timer = network.epoch_time";
      result_var=$.programs.gp[1][4].vars[1]$;
      expr {
       expr="network.epoch_time";
      };
     };
     MethodCall @[3] {
      name="MethodCall_epochmondataSetV_csepochtimetot1";
      desc="set the total time to compute the epoch (epoch_time_tot -- wall clock time) to time used data from network timer";
      flags=CAN_REVERT_TO_CODE;
      code_string="epoch_mon_data->SetValColName(epoch_timer.used.GetTotSecs(), \"epoch_time_tot\", -1, )";
      result_var=NULL;
      obj=$.programs.gp[1][4].vars[0]$;
      method=DataTable::SetValColName;
      meth_args {
       name="meth_args";
       el_typ=ProgArg;
       el_def=0;
       ProgArg @[0] {
	arg_type=const_Variant_ref;
	type="Variant&";
	name="val";
	required=1;
	def_val=;
	prev_expr=;
	expr {
	 expr="epoch_timer.used.GetTotSecs()";
	};
       };
       ProgArg @[1] {
	arg_type=const_taString_ref;
	type="taString&";
	name="col_name";
	required=1;
	def_val="\"\"";
	prev_expr=;
	expr {
	 expr="\"epoch_time_tot\"";
	};
       };
       ProgArg @[2] {
	arg_type=int;
	type="int";
	name="row";
	required=1;
	def_val=;
	prev_expr=;
	expr {
	 expr="-1";
	};
       };
       ProgArg @[3] {
	arg_type=bool;
	type="bool";
	name="quiet";
	required=0;
	def_val="false";
	prev_expr=;
	expr {
	 expr=;
	};
       };
      };
      meth_sig="bool SetValColName(Variant& val, taString& col_name, int row, bool quiet = false)";
      meth_desc=" set data of scalar type, in Variant form (any data type, use for Programs), for given column name, row; returns 'true' if valid access and set is successful -- quiet = fail quietly";
     };
     MethodCall @[4] {
      name="MethodCall_epochmondataSetV_csepochtimeusr1";
      desc="set the user process time (cpu time for this process, epoch_time_usr) to time used data from network timer";
      flags=CAN_REVERT_TO_CODE;
      code_string="epoch_mon_data->SetValColName(epoch_timer.used.GetUsrSecs(), \"epoch_time_usr\", -1, )";
      result_var=NULL;
      obj=$.programs.gp[1][4].vars[0]$;
      method=DataTable::SetValColName;
      meth_args {
       name="meth_args";
       el_typ=ProgArg;
       el_def=0;
       ProgArg @[0] {
	arg_type=const_Variant_ref;
	type="Variant&";
	name="val";
	required=1;
	def_val=;
	prev_expr=;
	expr {
	 expr="epoch_timer.used.GetUsrSecs()";
	};
       };
       ProgArg @[1] {
	arg_type=const_taString_ref;
	type="taString&";
	name="col_name";
	required=1;
	def_val="\"\"";
	prev_expr=;
	expr {
	 expr="\"epoch_time_usr\"";
	};
       };
       ProgArg @[2] {
	arg_type=int;
	type="int";
	name="row";
	required=1;
	def_val=;
	prev_expr=;
	expr {
	 expr="-1";
	};
       };
       ProgArg @[3] {
	arg_type=bool;
	type="bool";
	name="quiet";
	required=0;
	def_val="false";
	prev_expr=;
	expr {
	 expr=;
	};
       };
      };
      meth_sig="bool SetValColName(Variant& val, taString& col_name, int row, bool quiet = false)";
      meth_desc=" set data of scalar type, in Variant form (any data type, use for Programs), for given column name, row; returns 'true' if valid access and set is successful -- quiet = fail quietly";
     };
     MethodCall @[5] {
      name="MethodCall_epochmondataWriteClose";
      desc="update after writing new data to monitor data table";
      flags=CAN_REVERT_TO_CODE;
      code_string="epoch_mon_data->WriteClose()";
      result_var=NULL;
      obj=$.programs.gp[1][4].vars[0]$;
      method=DataTable::WriteClose;
      meth_args {
       name="meth_args";
       el_typ=ProgArg;
       el_def=0;
      };
      meth_sig="void WriteClose()";
      meth_desc=" closes up a write operation -- call when done writing data -- performs any post-writing cleanup/closing of files, etc";
     };
    };
    step_prog=NULL;
    step_n=1;
    doc {
     name="doc";
     desc=;
     web_doc=0;
     wiki=;
     url="local";
     full_url="local";
     text_size=1;
     text=;
     html_text=;
    };
   };
  };
 };
 viewers {
  name="viewers";
  el_typ=MainWindowViewer;
  el_def=0;
  MainWindowViewer @[0] {
   UserDataItem_List @*(.user_data_) {
    name="UserDataItem_List_58";
    el_typ=UserDataItem;
    el_def=0;
    UserDataItem @[0] {name="view_win_lft": value=0: val_type_fixed=0: };
    UserDataItem @[1] {name="view_win_top": value=0: val_type_fixed=0: };
    UserDataItem @[2] {name="view_win_wd": value=1: val_type_fixed=0: };
    UserDataItem @[3] {name="view_win_ht": value=1: val_type_fixed=0: };
    UserDataItem @[4] {name="view_win_iconified": value=0: val_type_fixed=0: };
    UserDataItem @[5] {name="view_splitter_state": value=AAAA/wAAAAEAAAADAAABOAAAA8gAAAHZAQAAAAYBAAAAAQA=: val_type_fixed=0: };
   };
   name="Browser3";
   m_data=.$$;
   cur_font_size=10;
   visible=1;
   win_name=".projects[\"good\"] - good_recover6.proj [*]";
   m_is_root=0;
   m_is_viewer_xor_browser=0;
   m_is_proj_viewer=1;
   m_is_dialog=0;
   revert_to_tab_no=-1;
   toolbars {
    name="toolbars";
    el_typ=ToolBar;
    el_def=0;
    ToolBar @[0] {
     UserDataItem_List @*(.user_data_) {
      name="UserDataItem_List_59";
      el_typ=UserDataItem;
      el_def=0;
      UserDataItem @[0] {name="view_win_visible": value=0: val_type_fixed=0: };
     };
     name="Application";
     m_data=NULL;
     cur_font_size=10;
     visible=0;
     lft=0;
     top=0.01704546;
     o=Horizontal;
    };
   };
   frames {
    name="frames";
    el_typ=FrameViewer;
    el_def=0;
    BrowseViewerTaBase @[0] {
     name="Navigator";
     m_data=NULL;
     cur_font_size=10;
     visible=1;
     root_typ=BpProject;
     root_md=NULL;
     m_root=$.$;
    };
    PanelViewer @[1] {
     name="Editor";
     m_data=NULL;
     cur_font_size=10;
     visible=1;
    };
    T3PanelViewer @[2] {
     UserDataItem_List @*(.user_data_) {
      name="UserDataItem_List_60";
      el_typ=UserDataItem;
      el_def=0;
      UserDataItem @[0] {name="view_panel_selected": value=1: val_type_fixed=0: };
     };
     name="Visualizer";
     m_data=NULL;
     cur_font_size=10;
     visible=1;
     panels {
      name="panels";
      el_typ=T3Panel;
      el_def=0;
      T3Panel @[0] {
       name="Panel2";
       m_data=NULL;
       cur_font_size=10;
       visible=1;
       root_view {
	name="root_view";
	m_data=NULL;
	cur_font_size=10;
	m_transform=NULL;
	children {
	 name="children";
	 el_typ=T3DataViewMain;
	 el_def=0;
	};
       };
       bg_color {r=1: g=1: b=1: a=1: };
       text_color {r=0: g=0: b=0: a=1: };
       headlight_on=1;
       headlight_intensity=1;
       ambient_light=0;
       camera_params {field_of_view=45: near_distance=0.1: focal=5: far_distance=1000: };
       stereo_view=STEREO_NONE;
       saved_views {
	name="saved_views";
	el_typ=T3SavedView;
	el_def=0;
	T3SavedView @[0] {
	 name="Vw_0";
	 view_saved=1;
	 pos {x=0: y=0: z=-0.4765596: };
	 orient {x=0: y=0: z=1: rot=0: };
	 focal_dist=3.52344;
	};
	T3SavedView @[1] {
	 name="Vw_1";
	 view_saved=0;
	 pos {x=0: y=0: z=0: };
	 orient {x=0: y=0: z=1: rot=0: };
	 focal_dist=0;
	};
	T3SavedView @[2] {
	 name="Vw_2";
	 view_saved=0;
	 pos {x=0: y=0: z=0: };
	 orient {x=0: y=0: z=1: rot=0: };
	 focal_dist=0;
	};
	T3SavedView @[3] {
	 name="Vw_3";
	 view_saved=0;
	 pos {x=0: y=0: z=0: };
	 orient {x=0: y=0: z=1: rot=0: };
	 focal_dist=0;
	};
	T3SavedView @[4] {
	 name="Vw_4";
	 view_saved=0;
	 pos {x=0: y=0: z=0: };
	 orient {x=0: y=0: z=1: rot=0: };
	 focal_dist=0;
	};
	T3SavedView @[5] {
	 name="Vw_5";
	 view_saved=0;
	 pos {x=0: y=0: z=0: };
	 orient {x=0: y=0: z=1: rot=0: };
	 focal_dist=0;
	};
	T3SavedView @[6] {
	 name="Vw_6";
	 view_saved=0;
	 pos {x=0: y=0: z=0: };
	 orient {x=0: y=0: z=1: rot=0: };
	 focal_dist=0;
	};
	T3SavedView @[7] {
	 name="Vw_7";
	 view_saved=0;
	 pos {x=0: y=0: z=0: };
	 orient {x=0: y=0: z=1: rot=0: };
	 focal_dist=0;
	};
	T3SavedView @[8] {
	 name="Vw_8";
	 view_saved=0;
	 pos {x=0: y=0: z=0: };
	 orient {x=0: y=0: z=1: rot=0: };
	 focal_dist=0;
	};
	T3SavedView @[9] {
	 name="Vw_9";
	 view_saved=0;
	 pos {x=0: y=0: z=0: };
	 orient {x=0: y=0: z=1: rot=0: };
	 focal_dist=0;
	};
       };
      };
     };
    };
   };
   docks {
    name="docks";
    el_typ=DockViewer;
    el_def=0;
    ToolBoxDockViewer @[0] {
     UserDataItem_List @*(.user_data_) {
      name="UserDataItem_List_61";
      el_typ=UserDataItem;
      el_def=0;
      UserDataItem @[0] {name="view_win_lft": value=-0.03504043: val_type_fixed=0: };
      UserDataItem @[1] {name="view_win_top": value=-0.02272727: val_type_fixed=0: };
      UserDataItem @[2] {name="view_win_wd": value=0.04528302: val_type_fixed=0: };
      UserDataItem @[3] {name="view_win_ht": value=0.9791667: val_type_fixed=0: };
      UserDataItem @[4] {name="view_win_iconified": value=0: val_type_fixed=0: };
      UserDataItem @[5] {name="view_visible": value=1: val_type_fixed=0: };
     };
     name="ProgramToolbar";
     m_data=NULL;
     cur_font_size=10;
     visible=1;
     win_name=;
     dock_flags=DV_MOVABLE|DV_FLOATABLE;
     dock_area=1;
    };
   };
  };
 };
 save_view=1;
 save_as_only=0;
 auto_name=1;
 last_change_desc="using a bp network

trying bidirectional

think it's still feed forward

set error level crit

ran test

running new training on 9, 15 and 11

trained on 4500+ trials from nodes 15,11,9

saved as bp6";
 tree_state{ .;.patches;.docs;.wizards;.ctrl_panels;.active_params;.data;.data.gp[0];.data.gp[2];.programs;.programs.break_points;.programs.gp[0];.networks;.networks[0];.networks[0].spec_tables;.networks[0].specs;.networks[0].param_seqs;.networks[0].layers;.networks[0].layers[1].projections;.networks[0].weights; };
 networks {
  name="networks";
  el_typ=BpNetwork;
  el_def=0;
  BpNetwork @[0] {
   UserDataItem_List @*(.user_data_) {
    name=;
    el_typ=UserDataItem;
    el_def=0;
    UserDataItem @[0] {name="sse": value=1: val_type_fixed=1: };
    UserDataItem @[1] {name="output_name": value=1: val_type_fixed=1: };
    UserDataItem @[2] {name="trial_name": value=1: val_type_fixed=1: };
    UserDataItem @[3] {name="group_name": value=1: val_type_fixed=1: };
    UserDataItem @[4] {name="total_trials": value=1: val_type_fixed=1: };
    UserDataItem @[5] {name="time": value=1: val_type_fixed=1: };
    UserDataItem @[6] {name="cycle": value=1: val_type_fixed=1: };
    UserDataItem @[7] {name="tick": value=1: val_type_fixed=1: };
    UserDataItem @[8] {name="trial": value=1: val_type_fixed=1: };
    UserDataItem @[9] {name="group": value=1: val_type_fixed=1: };
    UserDataItem @[10] {name="epoch": value=1: val_type_fixed=1: };
    UserDataItem @[11] {name="batch": value=1: val_type_fixed=1: };
   };
   name="Network_0";
   desc=;
   specs {
    name="specs";
    el_typ=BpUnitSpec;
    el_def=0;
    BpUnitSpec @[0] {
     name="BpUnitSpec_0";
     is_used=1;
     used_status=USED;
     desc=;
     unique{      };
     saved{      };
     children {
      name="children";
      el_typ=BpUnitSpec;
      el_def=0;
     };
     act_range {min=0: max=1: range=1: scale=1: };
     bias_spec {type=BpConSpec: spec=.networks[0].specs[1]$$: };
     sse_tol=0;
     act_fun=SIGMOID;
     error_fun=SQUARED_ERR;
     err_tol=0;
     save_err=0;
     nlxx1 {ramp_start=-3: ramp_max=0.1: ramp_gain=-0.03333334: };
     gauss {mean=0: std_dev=1: std_dev_r=1: };
     noise_type=NO_NOISE;
     noise {name="noise": type=UNIFORM: mean=0: var=1: par=1: };
    };
    BpConSpec @[1] {
     name="BpConSpec_0";
     is_used=1;
     used_status=USED;
     desc=;
     unique{      };
     saved{      };
     children {
      name="children";
      el_typ=BpConSpec;
      el_def=0;
     };
     rnd {name="rnd": type=UNIFORM: mean=0: var=0.5: par=1: };
     wt_limits {type=NONE: min=-1: max=1: sym=0: sym_fm_top=0: };
     lrate=0.25;
     cur_lrate=0.25;
     lrate_sched {
      name="lrate_sched";
      el_typ=SchedItem;
      el_def=0;
      default_val=1;
      interpolate=0;
     };
     momentum=0.9;
     decay_type=NO_DECAY;
     decay=0;
     wt_updt=WU_MOMENT;
    };
    FullPrjnSpec @[2] {
     name="FullPrjnSpec_0";
     is_used=1;
     used_status=USED;
     desc=;
     unique{      };
     saved{      };
     children {
      name="children";
      el_typ=FullPrjnSpec;
      el_def=0;
     };
     self_con=0;
     init_wts=0;
     set_scale=0;
     init_wt_val=1;
     add_rnd_var=0;
     renorm_wts {on=0: mult_norm=1: avg_wt=0.5: };
    };
   };
   param_seqs {
    name="param_seqs";
    el_typ=ParamSeq;
    el_def=0;
   };
   layers {
    name="layers";
    el_typ=BpLayer;
    el_def=0;
    pos {x=0: y=0: z=0: };
    pos2d {x=0: y=0: };
    max_disp_size {x=25: y=1: z=1: };
    max_disp_size2d {x=25: y=1: };
    BpLayer @[0] {
     name="Input";
     desc=;
     flags=0;
     layer_type=INPUT;
     pos_rel {rel=ABS_POS: other=NULL: x_align=LEFT: x_off=0: y_align=FRONT: y_off=0: space=2: };
     pos {x=0: y=0: z=0: };
     pos_abs {x=0: y=0: z=0: };
     pos2d {x=0: y=0: };
     pos2d_abs {x=0: y=0: };
     disp_scale=1;
     un_geom {x=17: y=1: n_not_xy=0: n=17: };
     unit_groups=0;
     virt_groups=1;
     gp_geom {x=1: y=1: n_not_xy=0: n=1: };
     gp_spc {x=1: y=1: };
     flat_geom {x=17: y=1: n_not_xy=0: n=17: };
     disp_geom {x=17: y=1: n_not_xy=0: n=17: };
     scaled_disp_geom {x=17: y=1: n_not_xy=0: n=17: };
     n_recv_prjns=0;
     n_send_prjns=1;
     projections {
      name="projections";
      el_typ=Projection;
      el_def=0;
     };
     send_prjns {
      name="send_prjns";
      el_typ=Projection;
      el_def=0;
      Projection_Group @. = [0] = Projection .networks[0].layers[1].projections[0];
     };
     units {
      name="units";
      el_typ=BpUnit;
      el_def=0;
      pos {x=0: y=0: z=0: };
      output_name=;
     };
     unit_spec {type=BpUnitSpec: spec=.networks[0].specs[0]$$: };
     dist {fm_input=0: fm_output=2: };
     units_lesioned=0;
     gp_unit_names_4d=0;
     brain_area=;
     voxel_fill_pct=1;
    };
    BpLayer @[1] {
     name="Hidden";
     desc=;
     flags=0;
     layer_type=HIDDEN;
     pos_rel {rel=ABS_POS: other=NULL: x_align=LEFT: x_off=0: y_align=FRONT: y_off=0: space=2: };
     pos {x=0: y=0: z=0: };
     pos_abs {x=0: y=0: z=0: };
     pos2d {x=0: y=0: };
     pos2d_abs {x=0: y=0: };
     disp_scale=1;
     un_geom {x=25: y=1: n_not_xy=0: n=25: };
     unit_groups=0;
     virt_groups=1;
     gp_geom {x=1: y=1: n_not_xy=0: n=1: };
     gp_spc {x=1: y=1: };
     flat_geom {x=25: y=1: n_not_xy=0: n=25: };
     disp_geom {x=25: y=1: n_not_xy=0: n=25: };
     scaled_disp_geom {x=25: y=1: n_not_xy=0: n=25: };
     n_recv_prjns=1;
     n_send_prjns=1;
     projections {
      name="projections";
      el_typ=Projection;
      el_def=0;
      Projection @[0] {
       name="Fm_Input";
       off=0;
       disp=1;
       notes=;
       from_type=CUSTOM;
       from=.networks[0].layers[0]$$;
       spec {type=FullPrjnSpec: spec=.networks[0].specs[2]$$: };
       con_type=BpCon;
       con_spec {type=BpConSpec: spec=$.networks[0].specs[1]$: };
       recv_idx=0;
       send_idx=0;
       recv_n=1;
       send_n=1;
       projected=1;
       dir_fixed=0;
       direction=FM_INPUT;
       prjn_clr {r=1: g=0.9: b=0.5: a=1: };
      };
     };
     send_prjns {
      name="send_prjns";
      el_typ=Projection;
      el_def=0;
      Projection_Group @. = [0] = Projection .networks[0].layers[2].projections[0];
     };
     units {
      name="units";
      el_typ=BpUnit;
      el_def=0;
      pos {x=0: y=0: z=0: };
      output_name=;
     };
     unit_spec {type=BpUnitSpec: spec=$.networks[0].specs[0]$: };
     dist {fm_input=1: fm_output=1: };
     units_lesioned=0;
     gp_unit_names_4d=0;
     brain_area=;
     voxel_fill_pct=1;
    };
    BpLayer @[2] {
     name="Output";
     desc=;
     flags=0;
     layer_type=TARGET;
     pos_rel {rel=ABS_POS: other=NULL: x_align=LEFT: x_off=0: y_align=FRONT: y_off=0: space=2: };
     pos {x=0: y=0: z=0: };
     pos_abs {x=0: y=0: z=0: };
     pos2d {x=0: y=0: };
     pos2d_abs {x=0: y=0: };
     disp_scale=1;
     un_geom {x=1: y=1: n_not_xy=0: n=1: };
     unit_groups=0;
     virt_groups=1;
     gp_geom {x=1: y=1: n_not_xy=0: n=1: };
     gp_spc {x=1: y=1: };
     flat_geom {x=1: y=1: n_not_xy=0: n=1: };
     disp_geom {x=1: y=1: n_not_xy=0: n=1: };
     scaled_disp_geom {x=1: y=1: n_not_xy=0: n=1: };
     n_recv_prjns=1;
     n_send_prjns=0;
     projections {
      name="projections";
      el_typ=Projection;
      el_def=0;
      Projection @[0] {
       name="Fm_Hidden";
       off=0;
       disp=1;
       notes=;
       from_type=CUSTOM;
       from=.networks[0].layers[1]$$;
       spec {type=FullPrjnSpec: spec=$.networks[0].specs[2]$: };
       con_type=BpCon;
       con_spec {type=BpConSpec: spec=$.networks[0].specs[1]$: };
       recv_idx=0;
       send_idx=0;
       recv_n=1;
       send_n=1;
       projected=1;
       dir_fixed=0;
       direction=FM_INPUT;
       prjn_clr {r=1: g=0.9: b=0.5: a=1: };
      };
     };
     send_prjns {
      name="send_prjns";
      el_typ=Projection;
      el_def=0;
     };
     units {
      name="units";
      el_typ=BpUnit;
      el_def=0;
      pos {x=0: y=0: z=0: };
      output_name=;
     };
     unit_spec {type=BpUnitSpec: spec=$.networks[0].specs[0]$: };
     dist {fm_input=2: fm_output=0: };
     units_lesioned=0;
     gp_unit_names_4d=0;
     brain_area=;
     voxel_fill_pct=1;
    };
   };
   weights {
    name="weights";
    el_typ=Weights;
    el_def=0;
   };
   flags=BUILD_INIT_WTS;
   unit_vars_type=BpUnitVars;
   con_group_type=ConGroup;
   auto_build=AUTO_BUILD;
   auto_load_wts=NO_AUTO_LOAD;
   auto_load_file=;
   brain_atlas_name=;
   train_mode=TRAIN;
   wt_update=ON_LINE;
   small_batch_n=10;
   stats {sse_unit_avg=0: sse_sqrt=0: cnt_err_tol=0: prerr=0: };
   threads {run_time={name="": s_used=0: n_used=0: avg_used={avg=0: sum=0: n=0: }: }: sync_time={name="": s_used=0: n_used=0: avg_used={avg=0: sum=0: n=0: }: }: total_time={name="": s_used=0: n_used=0: avg_used={avg=0: sum=0: n=0: }: }: n_wake_in_sync=0: run_time_pct=0: sync_time_pct=0: wake_in_sync_pct=-9.362986856279606e+306: };
   cuda {sync_units=0: sync_cons=0: min_threads=32: max_threads=1024: cons_per_thread=2: timers_on=0: n_threads=32: };
   usr1_save_fmt=FULL_NET;
   wt_save_fmt=TEXT;
   n_units=44;
   n_cons=450;
   max_prjns=1;
   max_disp_size {x=25: y=1: z=1: };
   max_disp_size2d {x=25: y=1: };
   bp_to_inputs=0;
  };
 };
};
